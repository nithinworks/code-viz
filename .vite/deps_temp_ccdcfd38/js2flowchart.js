import {
  __commonJS
} from "./chunk-PR4QN5HX.js";

// node_modules/js2flowchart/dist/js2flowchart.js
var require_js2flowchart = __commonJS({
  "node_modules/js2flowchart/dist/js2flowchart.js"(exports, module) {
    !function(e, t) {
      "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define("js2flowchart", [], t) : "object" == typeof exports ? exports.js2flowchart = t() : e.js2flowchart = t();
    }("undefined" != typeof window ? window : exports, () => (() => {
      var e = { 2509: function(e2, t2, n2) {
        !function(e3, t3, n3, r2) {
          "use strict";
          let i;
          e3.addSegment = void 0, e3.addMapping = void 0, e3.maybeAddSegment = void 0, e3.maybeAddMapping = void 0, e3.setSourceContent = void 0, e3.toDecodedMap = void 0, e3.toEncodedMap = void 0, e3.fromMap = void 0, e3.allMappings = void 0;
          class s {
            constructor({ file: e4, sourceRoot: n4 } = {}) {
              this._names = new t3.SetArray(), this._sources = new t3.SetArray(), this._sourcesContent = [], this._mappings = [], this.file = e4, this.sourceRoot = n4;
            }
          }
          function a(e4, t4, n4) {
            for (let n5 = e4.length; n5 > t4; n5--) e4[n5] = e4[n5 - 1];
            e4[t4] = n4;
          }
          function o(e4, n4) {
            for (let r3 = 0; r3 < n4.length; r3++) t3.put(e4, n4[r3]);
          }
          function l(e4, t4, n4) {
            const { generated: r3, source: s2, original: a2, name: o2, content: l2 } = n4;
            if (!s2) return i(e4, t4, r3.line - 1, r3.column, null, null, null, null, null);
            const c = s2;
            return i(e4, t4, r3.line - 1, r3.column, c, a2.line - 1, a2.column, o2, l2);
          }
          e3.addSegment = (e4, t4, n4, r3, s2, a2, o2, l2) => i(false, e4, t4, n4, r3, s2, a2, o2, l2), e3.maybeAddSegment = (e4, t4, n4, r3, s2, a2, o2, l2) => i(true, e4, t4, n4, r3, s2, a2, o2, l2), e3.addMapping = (e4, t4) => l(false, e4, t4), e3.maybeAddMapping = (e4, t4) => l(true, e4, t4), e3.setSourceContent = (e4, n4, r3) => {
            const { _sources: i2, _sourcesContent: s2 } = e4;
            s2[t3.put(i2, n4)] = r3;
          }, e3.toDecodedMap = (e4) => {
            const { file: t4, sourceRoot: n4, _mappings: r3, _sources: i2, _sourcesContent: s2, _names: a2 } = e4;
            return function(e5) {
              const { length: t5 } = e5;
              let n5 = t5;
              for (let t6 = n5 - 1; t6 >= 0 && !(e5[t6].length > 0); n5 = t6, t6--) ;
              n5 < t5 && (e5.length = n5);
            }(r3), { version: 3, file: t4 || void 0, names: a2.array, sourceRoot: n4 || void 0, sources: i2.array, sourcesContent: s2, mappings: r3 };
          }, e3.toEncodedMap = (t4) => {
            const r3 = e3.toDecodedMap(t4);
            return Object.assign(Object.assign({}, r3), { mappings: n3.encode(r3.mappings) });
          }, e3.allMappings = (e4) => {
            const t4 = [], { _mappings: n4, _sources: r3, _names: i2 } = e4;
            for (let e5 = 0; e5 < n4.length; e5++) {
              const s2 = n4[e5];
              for (let n5 = 0; n5 < s2.length; n5++) {
                const a2 = s2[n5], o2 = { line: e5 + 1, column: a2[0] };
                let l2, c, u;
                1 !== a2.length && (l2 = r3.array[a2[1]], c = { line: a2[2] + 1, column: a2[3] }, 5 === a2.length && (u = i2.array[a2[4]])), t4.push({ generated: o2, source: l2, original: c, name: u });
              }
            }
            return t4;
          }, e3.fromMap = (e4) => {
            const t4 = new r2.TraceMap(e4), n4 = new s({ file: t4.file, sourceRoot: t4.sourceRoot });
            return o(n4._names, t4.names), o(n4._sources, t4.sources), n4._sourcesContent = t4.sourcesContent || t4.sources.map(() => null), n4._mappings = r2.decodedMappings(t4), n4;
          }, i = (e4, n4, r3, i2, s2, o2, l2, c, u) => {
            const { _mappings: p, _sources: h, _sourcesContent: d, _names: f } = n4, y = function(e5, t4) {
              for (let n5 = e5.length; n5 <= t4; n5++) e5[n5] = [];
              return e5[t4];
            }(p, r3), m = function(e5, t4) {
              let n5 = e5.length;
              for (let r4 = n5 - 1; r4 >= 0 && !(t4 >= e5[r4][0]); n5 = r4--) ;
              return n5;
            }(y, i2);
            if (!s2) {
              if (e4 && function(e5, t4) {
                return 0 === t4 || 1 === e5[t4 - 1].length;
              }(y, m)) return;
              return a(y, m, [i2]);
            }
            const T = t3.put(h, s2), g = c ? t3.put(f, c) : -1;
            if (T === d.length && (d[T] = null != u ? u : null), !e4 || !function(e5, t4, n5, r4, i3, s3) {
              if (0 === t4) return false;
              const a2 = e5[t4 - 1];
              return 1 !== a2.length && n5 === a2[1] && r4 === a2[2] && i3 === a2[3] && s3 === (5 === a2.length ? a2[4] : -1);
            }(y, m, T, o2, l2, g)) return a(y, m, c ? [i2, T, o2, l2, g] : [i2, T, o2, l2]);
          }, e3.GenMapping = s, Object.defineProperty(e3, "__esModule", { value: true });
        }(t2, n2(2208), n2(2297), n2(3446));
      }, 8435: function(e2) {
        e2.exports = function() {
          "use strict";
          const e3 = /^[\w+.-]+:\/\//, t2 = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/, n2 = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
          var r2;
          function i(e4) {
            return e4.startsWith("/");
          }
          function s(e4) {
            return /^[.?#]/.test(e4);
          }
          function a(e4) {
            const n3 = t2.exec(e4);
            return o(n3[1], n3[2] || "", n3[3], n3[4] || "", n3[5] || "/", n3[6] || "", n3[7] || "");
          }
          function o(e4, t3, n3, i2, s2, a2, o2) {
            return { scheme: e4, user: t3, host: n3, port: i2, path: s2, query: a2, hash: o2, type: r2.Absolute };
          }
          function l(t3) {
            if (function(e4) {
              return e4.startsWith("//");
            }(t3)) {
              const e4 = a("http:" + t3);
              return e4.scheme = "", e4.type = r2.SchemeRelative, e4;
            }
            if (i(t3)) {
              const e4 = a("http://foo.com" + t3);
              return e4.scheme = "", e4.host = "", e4.type = r2.AbsolutePath, e4;
            }
            if (function(e4) {
              return e4.startsWith("file:");
            }(t3)) return function(e4) {
              const t4 = n2.exec(e4), r3 = t4[2];
              return o("file:", "", t4[1] || "", "", i(r3) ? r3 : "/" + r3, t4[3] || "", t4[4] || "");
            }(t3);
            if (function(t4) {
              return e3.test(t4);
            }(t3)) return a(t3);
            const s2 = a("http://foo.com/" + t3);
            return s2.scheme = "", s2.host = "", s2.type = t3 ? t3.startsWith("?") ? r2.Query : t3.startsWith("#") ? r2.Hash : r2.RelativePath : r2.Empty, s2;
          }
          function c(e4, t3) {
            const n3 = t3 <= r2.RelativePath, i2 = e4.path.split("/");
            let s2 = 1, a2 = 0, o2 = false;
            for (let e5 = 1; e5 < i2.length; e5++) {
              const t4 = i2[e5];
              t4 ? (o2 = false, "." !== t4 && (".." !== t4 ? (i2[s2++] = t4, a2++) : a2 ? (o2 = true, a2--, s2--) : n3 && (i2[s2++] = t4))) : o2 = true;
            }
            let l2 = "";
            for (let e5 = 1; e5 < s2; e5++) l2 += "/" + i2[e5];
            (!l2 || o2 && !l2.endsWith("/..")) && (l2 += "/"), e4.path = l2;
          }
          return function(e4) {
            e4[e4.Empty = 1] = "Empty", e4[e4.Hash = 2] = "Hash", e4[e4.Query = 3] = "Query", e4[e4.RelativePath = 4] = "RelativePath", e4[e4.AbsolutePath = 5] = "AbsolutePath", e4[e4.SchemeRelative = 6] = "SchemeRelative", e4[e4.Absolute = 7] = "Absolute";
          }(r2 || (r2 = {})), function(e4, t3) {
            if (!e4 && !t3) return "";
            const n3 = l(e4);
            let i2 = n3.type;
            if (t3 && i2 !== r2.Absolute) {
              const e5 = l(t3), s2 = e5.type;
              switch (i2) {
                case r2.Empty:
                  n3.hash = e5.hash;
                case r2.Hash:
                  n3.query = e5.query;
                case r2.Query:
                case r2.RelativePath:
                  !function(e6, t4) {
                    c(t4, t4.type), "/" === e6.path ? e6.path = t4.path : e6.path = function(e7) {
                      if (e7.endsWith("/..")) return e7;
                      const t5 = e7.lastIndexOf("/");
                      return e7.slice(0, t5 + 1);
                    }(t4.path) + e6.path;
                  }(n3, e5);
                case r2.AbsolutePath:
                  n3.user = e5.user, n3.host = e5.host, n3.port = e5.port;
                case r2.SchemeRelative:
                  n3.scheme = e5.scheme;
              }
              s2 > i2 && (i2 = s2);
            }
            c(n3, i2);
            const a2 = n3.query + n3.hash;
            switch (i2) {
              case r2.Hash:
              case r2.Query:
                return a2;
              case r2.RelativePath: {
                const r3 = n3.path.slice(1);
                return r3 ? s(t3 || e4) && !s(r3) ? "./" + r3 + a2 : r3 + a2 : a2 || ".";
              }
              case r2.AbsolutePath:
                return n3.path + a2;
              default:
                return n3.scheme + "//" + n3.user + n3.host + n3.port + n3.path + a2;
            }
          };
        }();
      }, 2208: function(e2, t2) {
        !function(e3) {
          "use strict";
          e3.get = void 0, e3.put = void 0, e3.pop = void 0;
          e3.get = (e4, t3) => e4._indexes[t3], e3.put = (t3, n2) => {
            const r2 = e3.get(t3, n2);
            if (void 0 !== r2) return r2;
            const { array: i, _indexes: s } = t3;
            return s[n2] = i.push(n2) - 1;
          }, e3.pop = (e4) => {
            const { array: t3, _indexes: n2 } = e4;
            0 !== t3.length && (n2[t3.pop()] = void 0);
          }, e3.SetArray = class {
            constructor() {
              this._indexes = { __proto__: null }, this.array = [];
            }
          }, Object.defineProperty(e3, "__esModule", { value: true });
        }(t2);
      }, 2297: function(e2, t2, n2) {
        var r2 = n2(8764).lW;
        !function(e3) {
          "use strict";
          const t3 = ",".charCodeAt(0), n3 = ";".charCodeAt(0), i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", s = new Uint8Array(64), a = new Uint8Array(128);
          for (let e4 = 0; e4 < 64; e4++) {
            const t4 = i.charCodeAt(e4);
            s[e4] = t4, a[t4] = e4;
          }
          const o = "undefined" != typeof TextDecoder ? new TextDecoder() : void 0 !== r2 ? { decode: (e4) => r2.from(e4.buffer, e4.byteOffset, e4.byteLength).toString() } : { decode(e4) {
            let t4 = "";
            for (let n4 = 0; n4 < e4.length; n4++) t4 += String.fromCharCode(e4[n4]);
            return t4;
          } };
          function l(e4, t4) {
            const n4 = e4.indexOf(";", t4);
            return -1 === n4 ? e4.length : n4;
          }
          function c(e4, t4, n4, r3) {
            let i2 = 0, s2 = 0, o2 = 0;
            do {
              const n5 = e4.charCodeAt(t4++);
              o2 = a[n5], i2 |= (31 & o2) << s2, s2 += 5;
            } while (32 & o2);
            const l2 = 1 & i2;
            return i2 >>>= 1, l2 && (i2 = -2147483648 | -i2), n4[r3] += i2, t4;
          }
          function u(e4, n4, r3) {
            return !(n4 >= r3) && e4.charCodeAt(n4) !== t3;
          }
          function p(e4) {
            e4.sort(h);
          }
          function h(e4, t4) {
            return e4[0] - t4[0];
          }
          function d(e4, t4, n4, r3, i2) {
            const a2 = r3[i2];
            let o2 = a2 - n4[i2];
            n4[i2] = a2, o2 = o2 < 0 ? -o2 << 1 | 1 : o2 << 1;
            do {
              let n5 = 31 & o2;
              o2 >>>= 5, o2 > 0 && (n5 |= 32), e4[t4++] = s[n5];
            } while (o2 > 0);
            return t4;
          }
          e3.decode = function(e4) {
            const t4 = new Int32Array(5), n4 = [];
            let r3 = 0;
            do {
              const i2 = l(e4, r3), s2 = [];
              let a2 = true, o2 = 0;
              t4[0] = 0;
              for (let n5 = r3; n5 < i2; n5++) {
                let r4;
                n5 = c(e4, n5, t4, 0);
                const l2 = t4[0];
                l2 < o2 && (a2 = false), o2 = l2, u(e4, n5, i2) ? (n5 = c(e4, n5, t4, 1), n5 = c(e4, n5, t4, 2), n5 = c(e4, n5, t4, 3), u(e4, n5, i2) ? (n5 = c(e4, n5, t4, 4), r4 = [l2, t4[1], t4[2], t4[3], t4[4]]) : r4 = [l2, t4[1], t4[2], t4[3]]) : r4 = [l2], s2.push(r4);
              }
              a2 || p(s2), n4.push(s2), r3 = i2 + 1;
            } while (r3 <= e4.length);
            return n4;
          }, e3.encode = function(e4) {
            const r3 = new Int32Array(5), i2 = 16384, s2 = 16348, a2 = new Uint8Array(i2), l2 = a2.subarray(0, s2);
            let c2 = 0, u2 = "";
            for (let p2 = 0; p2 < e4.length; p2++) {
              const h2 = e4[p2];
              if (p2 > 0 && (c2 === i2 && (u2 += o.decode(a2), c2 = 0), a2[c2++] = n3), 0 !== h2.length) {
                r3[0] = 0;
                for (let e5 = 0; e5 < h2.length; e5++) {
                  const n4 = h2[e5];
                  c2 > s2 && (u2 += o.decode(l2), a2.copyWithin(0, s2, c2), c2 -= s2), e5 > 0 && (a2[c2++] = t3), c2 = d(a2, c2, r3, n4, 0), 1 !== n4.length && (c2 = d(a2, c2, r3, n4, 1), c2 = d(a2, c2, r3, n4, 2), c2 = d(a2, c2, r3, n4, 3), 4 !== n4.length && (c2 = d(a2, c2, r3, n4, 4)));
                }
              }
            }
            return u2 + o.decode(a2.subarray(0, c2));
          }, Object.defineProperty(e3, "__esModule", { value: true });
        }(t2);
      }, 3446: function(e2, t2, n2) {
        !function(e3, t3, n3) {
          "use strict";
          function r2(e4) {
            return e4 && "object" == typeof e4 && "default" in e4 ? e4 : { default: e4 };
          }
          var i = r2(n3);
          function s(e4, t4) {
            return t4 && !t4.endsWith("/") && (t4 += "/"), i.default(e4, t4);
          }
          const a = 0, o = 1, l = 2, c = 3, u = 4;
          function p(e4, t4) {
            for (let n4 = t4; n4 < e4.length; n4++) if (!h(e4[n4])) return n4;
            return e4.length;
          }
          function h(e4) {
            for (let t4 = 1; t4 < e4.length; t4++) if (e4[t4][a] < e4[t4 - 1][a]) return false;
            return true;
          }
          function d(e4, t4) {
            return t4 || (e4 = e4.slice()), e4.sort(f);
          }
          function f(e4, t4) {
            return e4[a] - t4[a];
          }
          let y = false;
          function m(e4, t4, n4) {
            for (let r3 = n4 + 1; r3 < e4.length && e4[r3][a] === t4; n4 = r3++) ;
            return n4;
          }
          function T(e4, t4, n4) {
            for (let r3 = n4 - 1; r3 >= 0 && e4[r3][a] === t4; n4 = r3--) ;
            return n4;
          }
          function g() {
            return { lastKey: -1, lastNeedle: -1, lastIndex: -1 };
          }
          function b(e4, t4, n4, r3) {
            const { lastKey: i2, lastNeedle: s2, lastIndex: o2 } = n4;
            let l2 = 0, c2 = e4.length - 1;
            if (r3 === i2) {
              if (t4 === s2) return y = -1 !== o2 && e4[o2][a] === t4, o2;
              t4 >= s2 ? l2 = -1 === o2 ? 0 : o2 : c2 = o2;
            }
            return n4.lastKey = r3, n4.lastNeedle = t4, n4.lastIndex = function(e5, t5, n5, r4) {
              for (; n5 <= r4; ) {
                const i3 = n5 + (r4 - n5 >> 1), s3 = e5[i3][a] - t5;
                if (0 === s3) return y = true, i3;
                s3 < 0 ? n5 = i3 + 1 : r4 = i3 - 1;
              }
              return y = false, n5 - 1;
            }(e4, t4, l2, c2);
          }
          function E(e4, t4, n4) {
            for (let n5 = e4.length; n5 > t4; n5--) e4[n5] = e4[n5 - 1];
            e4[t4] = n4;
          }
          function S() {
            return { __proto__: null };
          }
          function P(e4, t4, n4, r3, i2, s2, a2, o2, l2, c2) {
            const { sections: u2 } = e4;
            for (let e5 = 0; e5 < u2.length; e5++) {
              const { map: p2, offset: h2 } = u2[e5];
              let d2 = l2, f2 = c2;
              if (e5 + 1 < u2.length) {
                const t5 = u2[e5 + 1].offset;
                d2 = Math.min(l2, a2 + t5.line), d2 === l2 ? f2 = Math.min(c2, o2 + t5.column) : d2 < l2 && (f2 = o2 + t5.column);
              }
              x(p2, t4, n4, r3, i2, s2, a2 + h2.line, o2 + h2.column, d2, f2);
            }
          }
          function x(t4, n4, r3, i2, s2, p2, h2, d2, f2, y2) {
            if ("sections" in t4) return P(...arguments);
            const m2 = new O(t4, n4), T2 = i2.length, g2 = p2.length, b2 = e3.decodedMappings(m2), { resolvedSources: E2, sourcesContent: S2 } = m2;
            if (D(i2, E2), D(p2, m2.names), S2) D(s2, S2);
            else for (let e4 = 0; e4 < E2.length; e4++) s2.push(null);
            for (let e4 = 0; e4 < b2.length; e4++) {
              const t5 = h2 + e4;
              if (t5 > f2) return;
              const n5 = A(r3, t5), i3 = 0 === e4 ? d2 : 0, s3 = b2[e4];
              for (let e5 = 0; e5 < s3.length; e5++) {
                const r4 = s3[e5], p3 = i3 + r4[a];
                if (t5 === f2 && p3 >= y2) return;
                if (1 === r4.length) {
                  n5.push([p3]);
                  continue;
                }
                const h3 = T2 + r4[o], d3 = r4[l], m3 = r4[c];
                n5.push(4 === r4.length ? [p3, h3, d3, m3] : [p3, h3, d3, m3, g2 + r4[u]]);
              }
            }
          }
          function D(e4, t4) {
            for (let n4 = 0; n4 < t4.length; n4++) e4.push(t4[n4]);
          }
          function A(e4, t4) {
            for (let n4 = e4.length; n4 <= t4; n4++) e4[n4] = [];
            return e4[t4];
          }
          const v = "`line` must be greater than 0 (lines start at line 1)", C = "`column` must be greater than or equal to 0 (columns start at column 0)", w = -1;
          e3.encodedMappings = void 0, e3.decodedMappings = void 0, e3.traceSegment = void 0, e3.originalPositionFor = void 0, e3.generatedPositionFor = void 0, e3.allGeneratedPositionsFor = void 0, e3.eachMapping = void 0, e3.sourceContentFor = void 0, e3.presortedDecodedMap = void 0, e3.decodedMap = void 0, e3.encodedMap = void 0;
          class O {
            constructor(e4, t4) {
              const n4 = "string" == typeof e4;
              if (!n4 && e4._decodedMemo) return e4;
              const r3 = n4 ? JSON.parse(e4) : e4, { version: i2, file: a2, names: o2, sourceRoot: l2, sources: c2, sourcesContent: u2 } = r3;
              this.version = i2, this.file = a2, this.names = o2, this.sourceRoot = l2, this.sources = c2, this.sourcesContent = u2;
              const h2 = s(l2 || "", function(e5) {
                if (!e5) return "";
                const t5 = e5.lastIndexOf("/");
                return e5.slice(0, t5 + 1);
              }(t4));
              this.resolvedSources = c2.map((e5) => s(e5 || "", h2));
              const { mappings: f2 } = r3;
              "string" == typeof f2 ? (this._encoded = f2, this._decoded = void 0) : (this._encoded = void 0, this._decoded = function(e5, t5) {
                const n5 = p(e5, 0);
                if (n5 === e5.length) return e5;
                t5 || (e5 = e5.slice());
                for (let r4 = n5; r4 < e5.length; r4 = p(e5, r4 + 1)) e5[r4] = d(e5[r4], t5);
                return e5;
              }(f2, n4)), this._decodedMemo = { lastKey: -1, lastNeedle: -1, lastIndex: -1 }, this._bySources = void 0, this._bySourceMemos = void 0;
            }
          }
          function I(e4, t4) {
            return { version: e4.version, file: e4.file, names: e4.names, sourceRoot: e4.sourceRoot, sources: e4.sources, sourcesContent: e4.sourcesContent, mappings: t4 };
          }
          function N(e4, t4, n4, r3) {
            return { source: e4, line: t4, column: n4, name: r3 };
          }
          function F(e4, t4) {
            return { line: e4, column: t4 };
          }
          function k(e4, t4, n4, r3, i2) {
            let s2 = b(e4, r3, t4, n4);
            return y ? s2 = (i2 === w ? m : T)(e4, r3, s2) : i2 === w && s2++, -1 === s2 || s2 === e4.length ? -1 : s2;
          }
          (() => {
            function n4(t4, n5, r3, i2, s2, u2) {
              if (--r3 < 0) throw new Error(v);
              if (i2 < 0) throw new Error(C);
              const { sources: p2, resolvedSources: h2 } = t4;
              let d2 = p2.indexOf(n5);
              if (-1 === d2 && (d2 = h2.indexOf(n5)), -1 === d2) return u2 ? [] : F(null, null);
              const f2 = (t4._bySources || (t4._bySources = function(e4, t5) {
                const n6 = t5.map(S);
                for (let r4 = 0; r4 < e4.length; r4++) {
                  const i3 = e4[r4];
                  for (let e5 = 0; e5 < i3.length; e5++) {
                    const s3 = i3[e5];
                    if (1 === s3.length) continue;
                    const u3 = s3[o], p3 = s3[l], h3 = s3[c], d3 = n6[u3], f3 = d3[p3] || (d3[p3] = []), y2 = t5[u3], T2 = m(f3, h3, b(f3, h3, y2, p3));
                    E(f3, y2.lastIndex = T2 + 1, [h3, r4, s3[a]]);
                  }
                }
                return n6;
              }(e3.decodedMappings(t4), t4._bySourceMemos = p2.map(g))))[d2][r3];
              if (null == f2) return u2 ? [] : F(null, null);
              const P2 = t4._bySourceMemos[d2];
              if (u2) return function(e4, t5, n6, r4, i3) {
                let s3 = k(e4, t5, n6, r4, 1);
                if (y || i3 !== w || s3++, -1 === s3 || s3 === e4.length) return [];
                const o2 = y ? r4 : e4[s3][a];
                y || (s3 = T(e4, o2, s3));
                const l2 = m(e4, o2, s3), c2 = [];
                for (; s3 <= l2; s3++) {
                  const t6 = e4[s3];
                  c2.push(F(t6[1] + 1, t6[2]));
                }
                return c2;
              }(f2, P2, r3, i2, s2);
              const x2 = k(f2, P2, r3, i2, s2);
              if (-1 === x2) return F(null, null);
              const D2 = f2[x2];
              return F(D2[1] + 1, D2[2]);
            }
            e3.encodedMappings = (e4) => {
              var n5;
              return null !== (n5 = e4._encoded) && void 0 !== n5 ? n5 : e4._encoded = t3.encode(e4._decoded);
            }, e3.decodedMappings = (e4) => e4._decoded || (e4._decoded = t3.decode(e4._encoded)), e3.traceSegment = (t4, n5, r3) => {
              const i2 = e3.decodedMappings(t4);
              if (n5 >= i2.length) return null;
              const s2 = i2[n5], a2 = k(s2, t4._decodedMemo, n5, r3, 1);
              return -1 === a2 ? null : s2[a2];
            }, e3.originalPositionFor = (t4, { line: n5, column: r3, bias: i2 }) => {
              if (--n5 < 0) throw new Error(v);
              if (r3 < 0) throw new Error(C);
              const s2 = e3.decodedMappings(t4);
              if (n5 >= s2.length) return N(null, null, null, null);
              const a2 = s2[n5], p2 = k(a2, t4._decodedMemo, n5, r3, i2 || 1);
              if (-1 === p2) return N(null, null, null, null);
              const h2 = a2[p2];
              if (1 === h2.length) return N(null, null, null, null);
              const { names: d2, resolvedSources: f2 } = t4;
              return N(f2[h2[o]], h2[l] + 1, h2[c], 5 === h2.length ? d2[h2[u]] : null);
            }, e3.allGeneratedPositionsFor = (e4, { source: t4, line: r3, column: i2, bias: s2 }) => n4(e4, t4, r3, i2, s2 || w, true), e3.generatedPositionFor = (e4, { source: t4, line: r3, column: i2, bias: s2 }) => n4(e4, t4, r3, i2, s2 || 1, false), e3.eachMapping = (t4, n5) => {
              const r3 = e3.decodedMappings(t4), { names: i2, resolvedSources: s2 } = t4;
              for (let e4 = 0; e4 < r3.length; e4++) {
                const t5 = r3[e4];
                for (let r4 = 0; r4 < t5.length; r4++) {
                  const a2 = t5[r4], o2 = e4 + 1, l2 = a2[0];
                  let c2 = null, u2 = null, p2 = null, h2 = null;
                  1 !== a2.length && (c2 = s2[a2[1]], u2 = a2[2] + 1, p2 = a2[3]), 5 === a2.length && (h2 = i2[a2[4]]), n5({ generatedLine: o2, generatedColumn: l2, source: c2, originalLine: u2, originalColumn: p2, name: h2 });
                }
              }
            }, e3.sourceContentFor = (e4, t4) => {
              const { sources: n5, resolvedSources: r3, sourcesContent: i2 } = e4;
              if (null == i2) return null;
              let s2 = n5.indexOf(t4);
              return -1 === s2 && (s2 = r3.indexOf(t4)), -1 === s2 ? null : i2[s2];
            }, e3.presortedDecodedMap = (e4, t4) => {
              const n5 = new O(I(e4, []), t4);
              return n5._decoded = e4.mappings, n5;
            }, e3.decodedMap = (t4) => I(t4, e3.decodedMappings(t4)), e3.encodedMap = (t4) => I(t4, e3.encodedMappings(t4));
          })(), e3.AnyMap = function(t4, n4) {
            const r3 = "string" == typeof t4 ? JSON.parse(t4) : t4;
            if (!("sections" in r3)) return new O(r3, n4);
            const i2 = [], s2 = [], a2 = [], o2 = [];
            P(r3, n4, i2, s2, a2, o2, 0, 0, 1 / 0, 1 / 0);
            const l2 = { version: 3, file: r3.file, names: o2, sources: s2, sourcesContent: a2, mappings: i2 };
            return e3.presortedDecodedMap(l2);
          }, e3.GREATEST_LOWER_BOUND = 1, e3.LEAST_UPPER_BOUND = w, e3.TraceMap = O, Object.defineProperty(e3, "__esModule", { value: true });
        }(t2, n2(2297), n2(8435));
      }, 6434: (e2, t2, n2) => {
        "use strict";
        e2 = n2.nmd(e2);
        const r2 = n2(2085), i = (e3, t3) => function() {
          return `\x1B[${e3.apply(r2, arguments) + t3}m`;
        }, s = (e3, t3) => function() {
          const n3 = e3.apply(r2, arguments);
          return `\x1B[${38 + t3};5;${n3}m`;
        }, a = (e3, t3) => function() {
          const n3 = e3.apply(r2, arguments);
          return `\x1B[${38 + t3};2;${n3[0]};${n3[1]};${n3[2]}m`;
        };
        Object.defineProperty(e2, "exports", { enumerable: true, get: function() {
          const e3 = /* @__PURE__ */ new Map(), t3 = { modifier: { reset: [0, 0], bold: [1, 22], dim: [2, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], hidden: [8, 28], strikethrough: [9, 29] }, color: { black: [30, 39], red: [31, 39], green: [32, 39], yellow: [33, 39], blue: [34, 39], magenta: [35, 39], cyan: [36, 39], white: [37, 39], gray: [90, 39], redBright: [91, 39], greenBright: [92, 39], yellowBright: [93, 39], blueBright: [94, 39], magentaBright: [95, 39], cyanBright: [96, 39], whiteBright: [97, 39] }, bgColor: { bgBlack: [40, 49], bgRed: [41, 49], bgGreen: [42, 49], bgYellow: [43, 49], bgBlue: [44, 49], bgMagenta: [45, 49], bgCyan: [46, 49], bgWhite: [47, 49], bgBlackBright: [100, 49], bgRedBright: [101, 49], bgGreenBright: [102, 49], bgYellowBright: [103, 49], bgBlueBright: [104, 49], bgMagentaBright: [105, 49], bgCyanBright: [106, 49], bgWhiteBright: [107, 49] } };
          t3.color.grey = t3.color.gray;
          for (const n4 of Object.keys(t3)) {
            const r3 = t3[n4];
            for (const n5 of Object.keys(r3)) {
              const i2 = r3[n5];
              t3[n5] = { open: `\x1B[${i2[0]}m`, close: `\x1B[${i2[1]}m` }, r3[n5] = t3[n5], e3.set(i2[0], i2[1]);
            }
            Object.defineProperty(t3, n4, { value: r3, enumerable: false }), Object.defineProperty(t3, "codes", { value: e3, enumerable: false });
          }
          const n3 = (e4) => e4, o = (e4, t4, n4) => [e4, t4, n4];
          t3.color.close = "\x1B[39m", t3.bgColor.close = "\x1B[49m", t3.color.ansi = { ansi: i(n3, 0) }, t3.color.ansi256 = { ansi256: s(n3, 0) }, t3.color.ansi16m = { rgb: a(o, 0) }, t3.bgColor.ansi = { ansi: i(n3, 10) }, t3.bgColor.ansi256 = { ansi256: s(n3, 10) }, t3.bgColor.ansi16m = { rgb: a(o, 10) };
          for (let e4 of Object.keys(r2)) {
            if ("object" != typeof r2[e4]) continue;
            const n4 = r2[e4];
            "ansi16" === e4 && (e4 = "ansi"), "ansi16" in n4 && (t3.color.ansi[e4] = i(n4.ansi16, 0), t3.bgColor.ansi[e4] = i(n4.ansi16, 10)), "ansi256" in n4 && (t3.color.ansi256[e4] = s(n4.ansi256, 0), t3.bgColor.ansi256[e4] = s(n4.ansi256, 10)), "rgb" in n4 && (t3.color.ansi16m[e4] = a(n4.rgb, 0), t3.bgColor.ansi16m[e4] = a(n4.rgb, 10));
          }
          return t3;
        } });
      }, 9742: (e2, t2) => {
        "use strict";
        t2.byteLength = function(e3) {
          var t3 = o(e3), n3 = t3[0], r3 = t3[1];
          return 3 * (n3 + r3) / 4 - r3;
        }, t2.toByteArray = function(e3) {
          var t3, n3, s2 = o(e3), a2 = s2[0], l2 = s2[1], c = new i(function(e4, t4, n4) {
            return 3 * (t4 + n4) / 4 - n4;
          }(0, a2, l2)), u = 0, p = l2 > 0 ? a2 - 4 : a2;
          for (n3 = 0; n3 < p; n3 += 4) t3 = r2[e3.charCodeAt(n3)] << 18 | r2[e3.charCodeAt(n3 + 1)] << 12 | r2[e3.charCodeAt(n3 + 2)] << 6 | r2[e3.charCodeAt(n3 + 3)], c[u++] = t3 >> 16 & 255, c[u++] = t3 >> 8 & 255, c[u++] = 255 & t3;
          return 2 === l2 && (t3 = r2[e3.charCodeAt(n3)] << 2 | r2[e3.charCodeAt(n3 + 1)] >> 4, c[u++] = 255 & t3), 1 === l2 && (t3 = r2[e3.charCodeAt(n3)] << 10 | r2[e3.charCodeAt(n3 + 1)] << 4 | r2[e3.charCodeAt(n3 + 2)] >> 2, c[u++] = t3 >> 8 & 255, c[u++] = 255 & t3), c;
        }, t2.fromByteArray = function(e3) {
          for (var t3, r3 = e3.length, i2 = r3 % 3, s2 = [], a2 = 16383, o2 = 0, c = r3 - i2; o2 < c; o2 += a2) s2.push(l(e3, o2, o2 + a2 > c ? c : o2 + a2));
          return 1 === i2 ? (t3 = e3[r3 - 1], s2.push(n2[t3 >> 2] + n2[t3 << 4 & 63] + "==")) : 2 === i2 && (t3 = (e3[r3 - 2] << 8) + e3[r3 - 1], s2.push(n2[t3 >> 10] + n2[t3 >> 4 & 63] + n2[t3 << 2 & 63] + "=")), s2.join("");
        };
        for (var n2 = [], r2 = [], i = "undefined" != typeof Uint8Array ? Uint8Array : Array, s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", a = 0; a < 64; ++a) n2[a] = s[a], r2[s.charCodeAt(a)] = a;
        function o(e3) {
          var t3 = e3.length;
          if (t3 % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
          var n3 = e3.indexOf("=");
          return -1 === n3 && (n3 = t3), [n3, n3 === t3 ? 0 : 4 - n3 % 4];
        }
        function l(e3, t3, r3) {
          for (var i2, s2, a2 = [], o2 = t3; o2 < r3; o2 += 3) i2 = (e3[o2] << 16 & 16711680) + (e3[o2 + 1] << 8 & 65280) + (255 & e3[o2 + 2]), a2.push(n2[(s2 = i2) >> 18 & 63] + n2[s2 >> 12 & 63] + n2[s2 >> 6 & 63] + n2[63 & s2]);
          return a2.join("");
        }
        r2["-".charCodeAt(0)] = 62, r2["_".charCodeAt(0)] = 63;
      }, 8764: (e2, t2, n2) => {
        "use strict";
        const r2 = n2(9742), i = n2(645), s = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null;
        t2.lW = l, t2.h2 = 50;
        const a = 2147483647;
        function o(e3) {
          if (e3 > a) throw new RangeError('The value "' + e3 + '" is invalid for option "size"');
          const t3 = new Uint8Array(e3);
          return Object.setPrototypeOf(t3, l.prototype), t3;
        }
        function l(e3, t3, n3) {
          if ("number" == typeof e3) {
            if ("string" == typeof t3) throw new TypeError('The "string" argument must be of type string. Received type number');
            return p(e3);
          }
          return c(e3, t3, n3);
        }
        function c(e3, t3, n3) {
          if ("string" == typeof e3) return function(e4, t4) {
            if ("string" == typeof t4 && "" !== t4 || (t4 = "utf8"), !l.isEncoding(t4)) throw new TypeError("Unknown encoding: " + t4);
            const n4 = 0 | y(e4, t4);
            let r4 = o(n4);
            const i3 = r4.write(e4, t4);
            return i3 !== n4 && (r4 = r4.slice(0, i3)), r4;
          }(e3, t3);
          if (ArrayBuffer.isView(e3)) return function(e4) {
            if ($(e4, Uint8Array)) {
              const t4 = new Uint8Array(e4);
              return d(t4.buffer, t4.byteOffset, t4.byteLength);
            }
            return h(e4);
          }(e3);
          if (null == e3) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e3);
          if ($(e3, ArrayBuffer) || e3 && $(e3.buffer, ArrayBuffer)) return d(e3, t3, n3);
          if ("undefined" != typeof SharedArrayBuffer && ($(e3, SharedArrayBuffer) || e3 && $(e3.buffer, SharedArrayBuffer))) return d(e3, t3, n3);
          if ("number" == typeof e3) throw new TypeError('The "value" argument must not be of type number. Received type number');
          const r3 = e3.valueOf && e3.valueOf();
          if (null != r3 && r3 !== e3) return l.from(r3, t3, n3);
          const i2 = function(e4) {
            if (l.isBuffer(e4)) {
              const t4 = 0 | f(e4.length), n4 = o(t4);
              return 0 === n4.length || e4.copy(n4, 0, 0, t4), n4;
            }
            return void 0 !== e4.length ? "number" != typeof e4.length || G(e4.length) ? o(0) : h(e4) : "Buffer" === e4.type && Array.isArray(e4.data) ? h(e4.data) : void 0;
          }(e3);
          if (i2) return i2;
          if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof e3[Symbol.toPrimitive]) return l.from(e3[Symbol.toPrimitive]("string"), t3, n3);
          throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e3);
        }
        function u(e3) {
          if ("number" != typeof e3) throw new TypeError('"size" argument must be of type number');
          if (e3 < 0) throw new RangeError('The value "' + e3 + '" is invalid for option "size"');
        }
        function p(e3) {
          return u(e3), o(e3 < 0 ? 0 : 0 | f(e3));
        }
        function h(e3) {
          const t3 = e3.length < 0 ? 0 : 0 | f(e3.length), n3 = o(t3);
          for (let r3 = 0; r3 < t3; r3 += 1) n3[r3] = 255 & e3[r3];
          return n3;
        }
        function d(e3, t3, n3) {
          if (t3 < 0 || e3.byteLength < t3) throw new RangeError('"offset" is outside of buffer bounds');
          if (e3.byteLength < t3 + (n3 || 0)) throw new RangeError('"length" is outside of buffer bounds');
          let r3;
          return r3 = void 0 === t3 && void 0 === n3 ? new Uint8Array(e3) : void 0 === n3 ? new Uint8Array(e3, t3) : new Uint8Array(e3, t3, n3), Object.setPrototypeOf(r3, l.prototype), r3;
        }
        function f(e3) {
          if (e3 >= a) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + a.toString(16) + " bytes");
          return 0 | e3;
        }
        function y(e3, t3) {
          if (l.isBuffer(e3)) return e3.length;
          if (ArrayBuffer.isView(e3) || $(e3, ArrayBuffer)) return e3.byteLength;
          if ("string" != typeof e3) throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e3);
          const n3 = e3.length, r3 = arguments.length > 2 && true === arguments[2];
          if (!r3 && 0 === n3) return 0;
          let i2 = false;
          for (; ; ) switch (t3) {
            case "ascii":
            case "latin1":
            case "binary":
              return n3;
            case "utf8":
            case "utf-8":
              return q(e3).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return 2 * n3;
            case "hex":
              return n3 >>> 1;
            case "base64":
              return H(e3).length;
            default:
              if (i2) return r3 ? -1 : q(e3).length;
              t3 = ("" + t3).toLowerCase(), i2 = true;
          }
        }
        function m(e3, t3, n3) {
          let r3 = false;
          if ((void 0 === t3 || t3 < 0) && (t3 = 0), t3 > this.length) return "";
          if ((void 0 === n3 || n3 > this.length) && (n3 = this.length), n3 <= 0) return "";
          if ((n3 >>>= 0) <= (t3 >>>= 0)) return "";
          for (e3 || (e3 = "utf8"); ; ) switch (e3) {
            case "hex":
              return I(this, t3, n3);
            case "utf8":
            case "utf-8":
              return v(this, t3, n3);
            case "ascii":
              return w(this, t3, n3);
            case "latin1":
            case "binary":
              return O(this, t3, n3);
            case "base64":
              return A(this, t3, n3);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return N(this, t3, n3);
            default:
              if (r3) throw new TypeError("Unknown encoding: " + e3);
              e3 = (e3 + "").toLowerCase(), r3 = true;
          }
        }
        function T(e3, t3, n3) {
          const r3 = e3[t3];
          e3[t3] = e3[n3], e3[n3] = r3;
        }
        function g(e3, t3, n3, r3, i2) {
          if (0 === e3.length) return -1;
          if ("string" == typeof n3 ? (r3 = n3, n3 = 0) : n3 > 2147483647 ? n3 = 2147483647 : n3 < -2147483648 && (n3 = -2147483648), G(n3 = +n3) && (n3 = i2 ? 0 : e3.length - 1), n3 < 0 && (n3 = e3.length + n3), n3 >= e3.length) {
            if (i2) return -1;
            n3 = e3.length - 1;
          } else if (n3 < 0) {
            if (!i2) return -1;
            n3 = 0;
          }
          if ("string" == typeof t3 && (t3 = l.from(t3, r3)), l.isBuffer(t3)) return 0 === t3.length ? -1 : b(e3, t3, n3, r3, i2);
          if ("number" == typeof t3) return t3 &= 255, "function" == typeof Uint8Array.prototype.indexOf ? i2 ? Uint8Array.prototype.indexOf.call(e3, t3, n3) : Uint8Array.prototype.lastIndexOf.call(e3, t3, n3) : b(e3, [t3], n3, r3, i2);
          throw new TypeError("val must be string, number or Buffer");
        }
        function b(e3, t3, n3, r3, i2) {
          let s2, a2 = 1, o2 = e3.length, l2 = t3.length;
          if (void 0 !== r3 && ("ucs2" === (r3 = String(r3).toLowerCase()) || "ucs-2" === r3 || "utf16le" === r3 || "utf-16le" === r3)) {
            if (e3.length < 2 || t3.length < 2) return -1;
            a2 = 2, o2 /= 2, l2 /= 2, n3 /= 2;
          }
          function c2(e4, t4) {
            return 1 === a2 ? e4[t4] : e4.readUInt16BE(t4 * a2);
          }
          if (i2) {
            let r4 = -1;
            for (s2 = n3; s2 < o2; s2++) if (c2(e3, s2) === c2(t3, -1 === r4 ? 0 : s2 - r4)) {
              if (-1 === r4 && (r4 = s2), s2 - r4 + 1 === l2) return r4 * a2;
            } else -1 !== r4 && (s2 -= s2 - r4), r4 = -1;
          } else for (n3 + l2 > o2 && (n3 = o2 - l2), s2 = n3; s2 >= 0; s2--) {
            let n4 = true;
            for (let r4 = 0; r4 < l2; r4++) if (c2(e3, s2 + r4) !== c2(t3, r4)) {
              n4 = false;
              break;
            }
            if (n4) return s2;
          }
          return -1;
        }
        function E(e3, t3, n3, r3) {
          n3 = Number(n3) || 0;
          const i2 = e3.length - n3;
          r3 ? (r3 = Number(r3)) > i2 && (r3 = i2) : r3 = i2;
          const s2 = t3.length;
          let a2;
          for (r3 > s2 / 2 && (r3 = s2 / 2), a2 = 0; a2 < r3; ++a2) {
            const r4 = parseInt(t3.substr(2 * a2, 2), 16);
            if (G(r4)) return a2;
            e3[n3 + a2] = r4;
          }
          return a2;
        }
        function S(e3, t3, n3, r3) {
          return J(q(t3, e3.length - n3), e3, n3, r3);
        }
        function P(e3, t3, n3, r3) {
          return J(function(e4) {
            const t4 = [];
            for (let n4 = 0; n4 < e4.length; ++n4) t4.push(255 & e4.charCodeAt(n4));
            return t4;
          }(t3), e3, n3, r3);
        }
        function x(e3, t3, n3, r3) {
          return J(H(t3), e3, n3, r3);
        }
        function D(e3, t3, n3, r3) {
          return J(function(e4, t4) {
            let n4, r4, i2;
            const s2 = [];
            for (let a2 = 0; a2 < e4.length && !((t4 -= 2) < 0); ++a2) n4 = e4.charCodeAt(a2), r4 = n4 >> 8, i2 = n4 % 256, s2.push(i2), s2.push(r4);
            return s2;
          }(t3, e3.length - n3), e3, n3, r3);
        }
        function A(e3, t3, n3) {
          return 0 === t3 && n3 === e3.length ? r2.fromByteArray(e3) : r2.fromByteArray(e3.slice(t3, n3));
        }
        function v(e3, t3, n3) {
          n3 = Math.min(e3.length, n3);
          const r3 = [];
          let i2 = t3;
          for (; i2 < n3; ) {
            const t4 = e3[i2];
            let s2 = null, a2 = t4 > 239 ? 4 : t4 > 223 ? 3 : t4 > 191 ? 2 : 1;
            if (i2 + a2 <= n3) {
              let n4, r4, o2, l2;
              switch (a2) {
                case 1:
                  t4 < 128 && (s2 = t4);
                  break;
                case 2:
                  n4 = e3[i2 + 1], 128 == (192 & n4) && (l2 = (31 & t4) << 6 | 63 & n4, l2 > 127 && (s2 = l2));
                  break;
                case 3:
                  n4 = e3[i2 + 1], r4 = e3[i2 + 2], 128 == (192 & n4) && 128 == (192 & r4) && (l2 = (15 & t4) << 12 | (63 & n4) << 6 | 63 & r4, l2 > 2047 && (l2 < 55296 || l2 > 57343) && (s2 = l2));
                  break;
                case 4:
                  n4 = e3[i2 + 1], r4 = e3[i2 + 2], o2 = e3[i2 + 3], 128 == (192 & n4) && 128 == (192 & r4) && 128 == (192 & o2) && (l2 = (15 & t4) << 18 | (63 & n4) << 12 | (63 & r4) << 6 | 63 & o2, l2 > 65535 && l2 < 1114112 && (s2 = l2));
              }
            }
            null === s2 ? (s2 = 65533, a2 = 1) : s2 > 65535 && (s2 -= 65536, r3.push(s2 >>> 10 & 1023 | 55296), s2 = 56320 | 1023 & s2), r3.push(s2), i2 += a2;
          }
          return function(e4) {
            const t4 = e4.length;
            if (t4 <= C) return String.fromCharCode.apply(String, e4);
            let n4 = "", r4 = 0;
            for (; r4 < t4; ) n4 += String.fromCharCode.apply(String, e4.slice(r4, r4 += C));
            return n4;
          }(r3);
        }
        l.TYPED_ARRAY_SUPPORT = function() {
          try {
            const e3 = new Uint8Array(1), t3 = { foo: function() {
              return 42;
            } };
            return Object.setPrototypeOf(t3, Uint8Array.prototype), Object.setPrototypeOf(e3, t3), 42 === e3.foo();
          } catch (e3) {
            return false;
          }
        }(), l.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(l.prototype, "parent", { enumerable: true, get: function() {
          if (l.isBuffer(this)) return this.buffer;
        } }), Object.defineProperty(l.prototype, "offset", { enumerable: true, get: function() {
          if (l.isBuffer(this)) return this.byteOffset;
        } }), l.poolSize = 8192, l.from = function(e3, t3, n3) {
          return c(e3, t3, n3);
        }, Object.setPrototypeOf(l.prototype, Uint8Array.prototype), Object.setPrototypeOf(l, Uint8Array), l.alloc = function(e3, t3, n3) {
          return function(e4, t4, n4) {
            return u(e4), e4 <= 0 ? o(e4) : void 0 !== t4 ? "string" == typeof n4 ? o(e4).fill(t4, n4) : o(e4).fill(t4) : o(e4);
          }(e3, t3, n3);
        }, l.allocUnsafe = function(e3) {
          return p(e3);
        }, l.allocUnsafeSlow = function(e3) {
          return p(e3);
        }, l.isBuffer = function(e3) {
          return null != e3 && true === e3._isBuffer && e3 !== l.prototype;
        }, l.compare = function(e3, t3) {
          if ($(e3, Uint8Array) && (e3 = l.from(e3, e3.offset, e3.byteLength)), $(t3, Uint8Array) && (t3 = l.from(t3, t3.offset, t3.byteLength)), !l.isBuffer(e3) || !l.isBuffer(t3)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
          if (e3 === t3) return 0;
          let n3 = e3.length, r3 = t3.length;
          for (let i2 = 0, s2 = Math.min(n3, r3); i2 < s2; ++i2) if (e3[i2] !== t3[i2]) {
            n3 = e3[i2], r3 = t3[i2];
            break;
          }
          return n3 < r3 ? -1 : r3 < n3 ? 1 : 0;
        }, l.isEncoding = function(e3) {
          switch (String(e3).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return true;
            default:
              return false;
          }
        }, l.concat = function(e3, t3) {
          if (!Array.isArray(e3)) throw new TypeError('"list" argument must be an Array of Buffers');
          if (0 === e3.length) return l.alloc(0);
          let n3;
          if (void 0 === t3) for (t3 = 0, n3 = 0; n3 < e3.length; ++n3) t3 += e3[n3].length;
          const r3 = l.allocUnsafe(t3);
          let i2 = 0;
          for (n3 = 0; n3 < e3.length; ++n3) {
            let t4 = e3[n3];
            if ($(t4, Uint8Array)) i2 + t4.length > r3.length ? (l.isBuffer(t4) || (t4 = l.from(t4)), t4.copy(r3, i2)) : Uint8Array.prototype.set.call(r3, t4, i2);
            else {
              if (!l.isBuffer(t4)) throw new TypeError('"list" argument must be an Array of Buffers');
              t4.copy(r3, i2);
            }
            i2 += t4.length;
          }
          return r3;
        }, l.byteLength = y, l.prototype._isBuffer = true, l.prototype.swap16 = function() {
          const e3 = this.length;
          if (e3 % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
          for (let t3 = 0; t3 < e3; t3 += 2) T(this, t3, t3 + 1);
          return this;
        }, l.prototype.swap32 = function() {
          const e3 = this.length;
          if (e3 % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
          for (let t3 = 0; t3 < e3; t3 += 4) T(this, t3, t3 + 3), T(this, t3 + 1, t3 + 2);
          return this;
        }, l.prototype.swap64 = function() {
          const e3 = this.length;
          if (e3 % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
          for (let t3 = 0; t3 < e3; t3 += 8) T(this, t3, t3 + 7), T(this, t3 + 1, t3 + 6), T(this, t3 + 2, t3 + 5), T(this, t3 + 3, t3 + 4);
          return this;
        }, l.prototype.toString = function() {
          const e3 = this.length;
          return 0 === e3 ? "" : 0 === arguments.length ? v(this, 0, e3) : m.apply(this, arguments);
        }, l.prototype.toLocaleString = l.prototype.toString, l.prototype.equals = function(e3) {
          if (!l.isBuffer(e3)) throw new TypeError("Argument must be a Buffer");
          return this === e3 || 0 === l.compare(this, e3);
        }, l.prototype.inspect = function() {
          let e3 = "";
          const n3 = t2.h2;
          return e3 = this.toString("hex", 0, n3).replace(/(.{2})/g, "$1 ").trim(), this.length > n3 && (e3 += " ... "), "<Buffer " + e3 + ">";
        }, s && (l.prototype[s] = l.prototype.inspect), l.prototype.compare = function(e3, t3, n3, r3, i2) {
          if ($(e3, Uint8Array) && (e3 = l.from(e3, e3.offset, e3.byteLength)), !l.isBuffer(e3)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e3);
          if (void 0 === t3 && (t3 = 0), void 0 === n3 && (n3 = e3 ? e3.length : 0), void 0 === r3 && (r3 = 0), void 0 === i2 && (i2 = this.length), t3 < 0 || n3 > e3.length || r3 < 0 || i2 > this.length) throw new RangeError("out of range index");
          if (r3 >= i2 && t3 >= n3) return 0;
          if (r3 >= i2) return -1;
          if (t3 >= n3) return 1;
          if (this === e3) return 0;
          let s2 = (i2 >>>= 0) - (r3 >>>= 0), a2 = (n3 >>>= 0) - (t3 >>>= 0);
          const o2 = Math.min(s2, a2), c2 = this.slice(r3, i2), u2 = e3.slice(t3, n3);
          for (let e4 = 0; e4 < o2; ++e4) if (c2[e4] !== u2[e4]) {
            s2 = c2[e4], a2 = u2[e4];
            break;
          }
          return s2 < a2 ? -1 : a2 < s2 ? 1 : 0;
        }, l.prototype.includes = function(e3, t3, n3) {
          return -1 !== this.indexOf(e3, t3, n3);
        }, l.prototype.indexOf = function(e3, t3, n3) {
          return g(this, e3, t3, n3, true);
        }, l.prototype.lastIndexOf = function(e3, t3, n3) {
          return g(this, e3, t3, n3, false);
        }, l.prototype.write = function(e3, t3, n3, r3) {
          if (void 0 === t3) r3 = "utf8", n3 = this.length, t3 = 0;
          else if (void 0 === n3 && "string" == typeof t3) r3 = t3, n3 = this.length, t3 = 0;
          else {
            if (!isFinite(t3)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
            t3 >>>= 0, isFinite(n3) ? (n3 >>>= 0, void 0 === r3 && (r3 = "utf8")) : (r3 = n3, n3 = void 0);
          }
          const i2 = this.length - t3;
          if ((void 0 === n3 || n3 > i2) && (n3 = i2), e3.length > 0 && (n3 < 0 || t3 < 0) || t3 > this.length) throw new RangeError("Attempt to write outside buffer bounds");
          r3 || (r3 = "utf8");
          let s2 = false;
          for (; ; ) switch (r3) {
            case "hex":
              return E(this, e3, t3, n3);
            case "utf8":
            case "utf-8":
              return S(this, e3, t3, n3);
            case "ascii":
            case "latin1":
            case "binary":
              return P(this, e3, t3, n3);
            case "base64":
              return x(this, e3, t3, n3);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return D(this, e3, t3, n3);
            default:
              if (s2) throw new TypeError("Unknown encoding: " + r3);
              r3 = ("" + r3).toLowerCase(), s2 = true;
          }
        }, l.prototype.toJSON = function() {
          return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
        };
        const C = 4096;
        function w(e3, t3, n3) {
          let r3 = "";
          n3 = Math.min(e3.length, n3);
          for (let i2 = t3; i2 < n3; ++i2) r3 += String.fromCharCode(127 & e3[i2]);
          return r3;
        }
        function O(e3, t3, n3) {
          let r3 = "";
          n3 = Math.min(e3.length, n3);
          for (let i2 = t3; i2 < n3; ++i2) r3 += String.fromCharCode(e3[i2]);
          return r3;
        }
        function I(e3, t3, n3) {
          const r3 = e3.length;
          (!t3 || t3 < 0) && (t3 = 0), (!n3 || n3 < 0 || n3 > r3) && (n3 = r3);
          let i2 = "";
          for (let r4 = t3; r4 < n3; ++r4) i2 += z[e3[r4]];
          return i2;
        }
        function N(e3, t3, n3) {
          const r3 = e3.slice(t3, n3);
          let i2 = "";
          for (let e4 = 0; e4 < r3.length - 1; e4 += 2) i2 += String.fromCharCode(r3[e4] + 256 * r3[e4 + 1]);
          return i2;
        }
        function F(e3, t3, n3) {
          if (e3 % 1 != 0 || e3 < 0) throw new RangeError("offset is not uint");
          if (e3 + t3 > n3) throw new RangeError("Trying to access beyond buffer length");
        }
        function k(e3, t3, n3, r3, i2, s2) {
          if (!l.isBuffer(e3)) throw new TypeError('"buffer" argument must be a Buffer instance');
          if (t3 > i2 || t3 < s2) throw new RangeError('"value" argument is out of bounds');
          if (n3 + r3 > e3.length) throw new RangeError("Index out of range");
        }
        function L(e3, t3, n3, r3, i2) {
          K(t3, r3, i2, e3, n3, 7);
          let s2 = Number(t3 & BigInt(4294967295));
          e3[n3++] = s2, s2 >>= 8, e3[n3++] = s2, s2 >>= 8, e3[n3++] = s2, s2 >>= 8, e3[n3++] = s2;
          let a2 = Number(t3 >> BigInt(32) & BigInt(4294967295));
          return e3[n3++] = a2, a2 >>= 8, e3[n3++] = a2, a2 >>= 8, e3[n3++] = a2, a2 >>= 8, e3[n3++] = a2, n3;
        }
        function _(e3, t3, n3, r3, i2) {
          K(t3, r3, i2, e3, n3, 7);
          let s2 = Number(t3 & BigInt(4294967295));
          e3[n3 + 7] = s2, s2 >>= 8, e3[n3 + 6] = s2, s2 >>= 8, e3[n3 + 5] = s2, s2 >>= 8, e3[n3 + 4] = s2;
          let a2 = Number(t3 >> BigInt(32) & BigInt(4294967295));
          return e3[n3 + 3] = a2, a2 >>= 8, e3[n3 + 2] = a2, a2 >>= 8, e3[n3 + 1] = a2, a2 >>= 8, e3[n3] = a2, n3 + 8;
        }
        function M(e3, t3, n3, r3, i2, s2) {
          if (n3 + r3 > e3.length) throw new RangeError("Index out of range");
          if (n3 < 0) throw new RangeError("Index out of range");
        }
        function B(e3, t3, n3, r3, s2) {
          return t3 = +t3, n3 >>>= 0, s2 || M(e3, 0, n3, 4), i.write(e3, t3, n3, r3, 23, 4), n3 + 4;
        }
        function j(e3, t3, n3, r3, s2) {
          return t3 = +t3, n3 >>>= 0, s2 || M(e3, 0, n3, 8), i.write(e3, t3, n3, r3, 52, 8), n3 + 8;
        }
        l.prototype.slice = function(e3, t3) {
          const n3 = this.length;
          (e3 = ~~e3) < 0 ? (e3 += n3) < 0 && (e3 = 0) : e3 > n3 && (e3 = n3), (t3 = void 0 === t3 ? n3 : ~~t3) < 0 ? (t3 += n3) < 0 && (t3 = 0) : t3 > n3 && (t3 = n3), t3 < e3 && (t3 = e3);
          const r3 = this.subarray(e3, t3);
          return Object.setPrototypeOf(r3, l.prototype), r3;
        }, l.prototype.readUintLE = l.prototype.readUIntLE = function(e3, t3, n3) {
          e3 >>>= 0, t3 >>>= 0, n3 || F(e3, t3, this.length);
          let r3 = this[e3], i2 = 1, s2 = 0;
          for (; ++s2 < t3 && (i2 *= 256); ) r3 += this[e3 + s2] * i2;
          return r3;
        }, l.prototype.readUintBE = l.prototype.readUIntBE = function(e3, t3, n3) {
          e3 >>>= 0, t3 >>>= 0, n3 || F(e3, t3, this.length);
          let r3 = this[e3 + --t3], i2 = 1;
          for (; t3 > 0 && (i2 *= 256); ) r3 += this[e3 + --t3] * i2;
          return r3;
        }, l.prototype.readUint8 = l.prototype.readUInt8 = function(e3, t3) {
          return e3 >>>= 0, t3 || F(e3, 1, this.length), this[e3];
        }, l.prototype.readUint16LE = l.prototype.readUInt16LE = function(e3, t3) {
          return e3 >>>= 0, t3 || F(e3, 2, this.length), this[e3] | this[e3 + 1] << 8;
        }, l.prototype.readUint16BE = l.prototype.readUInt16BE = function(e3, t3) {
          return e3 >>>= 0, t3 || F(e3, 2, this.length), this[e3] << 8 | this[e3 + 1];
        }, l.prototype.readUint32LE = l.prototype.readUInt32LE = function(e3, t3) {
          return e3 >>>= 0, t3 || F(e3, 4, this.length), (this[e3] | this[e3 + 1] << 8 | this[e3 + 2] << 16) + 16777216 * this[e3 + 3];
        }, l.prototype.readUint32BE = l.prototype.readUInt32BE = function(e3, t3) {
          return e3 >>>= 0, t3 || F(e3, 4, this.length), 16777216 * this[e3] + (this[e3 + 1] << 16 | this[e3 + 2] << 8 | this[e3 + 3]);
        }, l.prototype.readBigUInt64LE = Q(function(e3) {
          W(e3 >>>= 0, "offset");
          const t3 = this[e3], n3 = this[e3 + 7];
          void 0 !== t3 && void 0 !== n3 || X(e3, this.length - 8);
          const r3 = t3 + 256 * this[++e3] + 65536 * this[++e3] + this[++e3] * 2 ** 24, i2 = this[++e3] + 256 * this[++e3] + 65536 * this[++e3] + n3 * 2 ** 24;
          return BigInt(r3) + (BigInt(i2) << BigInt(32));
        }), l.prototype.readBigUInt64BE = Q(function(e3) {
          W(e3 >>>= 0, "offset");
          const t3 = this[e3], n3 = this[e3 + 7];
          void 0 !== t3 && void 0 !== n3 || X(e3, this.length - 8);
          const r3 = t3 * 2 ** 24 + 65536 * this[++e3] + 256 * this[++e3] + this[++e3], i2 = this[++e3] * 2 ** 24 + 65536 * this[++e3] + 256 * this[++e3] + n3;
          return (BigInt(r3) << BigInt(32)) + BigInt(i2);
        }), l.prototype.readIntLE = function(e3, t3, n3) {
          e3 >>>= 0, t3 >>>= 0, n3 || F(e3, t3, this.length);
          let r3 = this[e3], i2 = 1, s2 = 0;
          for (; ++s2 < t3 && (i2 *= 256); ) r3 += this[e3 + s2] * i2;
          return i2 *= 128, r3 >= i2 && (r3 -= Math.pow(2, 8 * t3)), r3;
        }, l.prototype.readIntBE = function(e3, t3, n3) {
          e3 >>>= 0, t3 >>>= 0, n3 || F(e3, t3, this.length);
          let r3 = t3, i2 = 1, s2 = this[e3 + --r3];
          for (; r3 > 0 && (i2 *= 256); ) s2 += this[e3 + --r3] * i2;
          return i2 *= 128, s2 >= i2 && (s2 -= Math.pow(2, 8 * t3)), s2;
        }, l.prototype.readInt8 = function(e3, t3) {
          return e3 >>>= 0, t3 || F(e3, 1, this.length), 128 & this[e3] ? -1 * (255 - this[e3] + 1) : this[e3];
        }, l.prototype.readInt16LE = function(e3, t3) {
          e3 >>>= 0, t3 || F(e3, 2, this.length);
          const n3 = this[e3] | this[e3 + 1] << 8;
          return 32768 & n3 ? 4294901760 | n3 : n3;
        }, l.prototype.readInt16BE = function(e3, t3) {
          e3 >>>= 0, t3 || F(e3, 2, this.length);
          const n3 = this[e3 + 1] | this[e3] << 8;
          return 32768 & n3 ? 4294901760 | n3 : n3;
        }, l.prototype.readInt32LE = function(e3, t3) {
          return e3 >>>= 0, t3 || F(e3, 4, this.length), this[e3] | this[e3 + 1] << 8 | this[e3 + 2] << 16 | this[e3 + 3] << 24;
        }, l.prototype.readInt32BE = function(e3, t3) {
          return e3 >>>= 0, t3 || F(e3, 4, this.length), this[e3] << 24 | this[e3 + 1] << 16 | this[e3 + 2] << 8 | this[e3 + 3];
        }, l.prototype.readBigInt64LE = Q(function(e3) {
          W(e3 >>>= 0, "offset");
          const t3 = this[e3], n3 = this[e3 + 7];
          void 0 !== t3 && void 0 !== n3 || X(e3, this.length - 8);
          const r3 = this[e3 + 4] + 256 * this[e3 + 5] + 65536 * this[e3 + 6] + (n3 << 24);
          return (BigInt(r3) << BigInt(32)) + BigInt(t3 + 256 * this[++e3] + 65536 * this[++e3] + this[++e3] * 2 ** 24);
        }), l.prototype.readBigInt64BE = Q(function(e3) {
          W(e3 >>>= 0, "offset");
          const t3 = this[e3], n3 = this[e3 + 7];
          void 0 !== t3 && void 0 !== n3 || X(e3, this.length - 8);
          const r3 = (t3 << 24) + 65536 * this[++e3] + 256 * this[++e3] + this[++e3];
          return (BigInt(r3) << BigInt(32)) + BigInt(this[++e3] * 2 ** 24 + 65536 * this[++e3] + 256 * this[++e3] + n3);
        }), l.prototype.readFloatLE = function(e3, t3) {
          return e3 >>>= 0, t3 || F(e3, 4, this.length), i.read(this, e3, true, 23, 4);
        }, l.prototype.readFloatBE = function(e3, t3) {
          return e3 >>>= 0, t3 || F(e3, 4, this.length), i.read(this, e3, false, 23, 4);
        }, l.prototype.readDoubleLE = function(e3, t3) {
          return e3 >>>= 0, t3 || F(e3, 8, this.length), i.read(this, e3, true, 52, 8);
        }, l.prototype.readDoubleBE = function(e3, t3) {
          return e3 >>>= 0, t3 || F(e3, 8, this.length), i.read(this, e3, false, 52, 8);
        }, l.prototype.writeUintLE = l.prototype.writeUIntLE = function(e3, t3, n3, r3) {
          e3 = +e3, t3 >>>= 0, n3 >>>= 0, r3 || k(this, e3, t3, n3, Math.pow(2, 8 * n3) - 1, 0);
          let i2 = 1, s2 = 0;
          for (this[t3] = 255 & e3; ++s2 < n3 && (i2 *= 256); ) this[t3 + s2] = e3 / i2 & 255;
          return t3 + n3;
        }, l.prototype.writeUintBE = l.prototype.writeUIntBE = function(e3, t3, n3, r3) {
          e3 = +e3, t3 >>>= 0, n3 >>>= 0, r3 || k(this, e3, t3, n3, Math.pow(2, 8 * n3) - 1, 0);
          let i2 = n3 - 1, s2 = 1;
          for (this[t3 + i2] = 255 & e3; --i2 >= 0 && (s2 *= 256); ) this[t3 + i2] = e3 / s2 & 255;
          return t3 + n3;
        }, l.prototype.writeUint8 = l.prototype.writeUInt8 = function(e3, t3, n3) {
          return e3 = +e3, t3 >>>= 0, n3 || k(this, e3, t3, 1, 255, 0), this[t3] = 255 & e3, t3 + 1;
        }, l.prototype.writeUint16LE = l.prototype.writeUInt16LE = function(e3, t3, n3) {
          return e3 = +e3, t3 >>>= 0, n3 || k(this, e3, t3, 2, 65535, 0), this[t3] = 255 & e3, this[t3 + 1] = e3 >>> 8, t3 + 2;
        }, l.prototype.writeUint16BE = l.prototype.writeUInt16BE = function(e3, t3, n3) {
          return e3 = +e3, t3 >>>= 0, n3 || k(this, e3, t3, 2, 65535, 0), this[t3] = e3 >>> 8, this[t3 + 1] = 255 & e3, t3 + 2;
        }, l.prototype.writeUint32LE = l.prototype.writeUInt32LE = function(e3, t3, n3) {
          return e3 = +e3, t3 >>>= 0, n3 || k(this, e3, t3, 4, 4294967295, 0), this[t3 + 3] = e3 >>> 24, this[t3 + 2] = e3 >>> 16, this[t3 + 1] = e3 >>> 8, this[t3] = 255 & e3, t3 + 4;
        }, l.prototype.writeUint32BE = l.prototype.writeUInt32BE = function(e3, t3, n3) {
          return e3 = +e3, t3 >>>= 0, n3 || k(this, e3, t3, 4, 4294967295, 0), this[t3] = e3 >>> 24, this[t3 + 1] = e3 >>> 16, this[t3 + 2] = e3 >>> 8, this[t3 + 3] = 255 & e3, t3 + 4;
        }, l.prototype.writeBigUInt64LE = Q(function(e3, t3 = 0) {
          return L(this, e3, t3, BigInt(0), BigInt("0xffffffffffffffff"));
        }), l.prototype.writeBigUInt64BE = Q(function(e3, t3 = 0) {
          return _(this, e3, t3, BigInt(0), BigInt("0xffffffffffffffff"));
        }), l.prototype.writeIntLE = function(e3, t3, n3, r3) {
          if (e3 = +e3, t3 >>>= 0, !r3) {
            const r4 = Math.pow(2, 8 * n3 - 1);
            k(this, e3, t3, n3, r4 - 1, -r4);
          }
          let i2 = 0, s2 = 1, a2 = 0;
          for (this[t3] = 255 & e3; ++i2 < n3 && (s2 *= 256); ) e3 < 0 && 0 === a2 && 0 !== this[t3 + i2 - 1] && (a2 = 1), this[t3 + i2] = (e3 / s2 >> 0) - a2 & 255;
          return t3 + n3;
        }, l.prototype.writeIntBE = function(e3, t3, n3, r3) {
          if (e3 = +e3, t3 >>>= 0, !r3) {
            const r4 = Math.pow(2, 8 * n3 - 1);
            k(this, e3, t3, n3, r4 - 1, -r4);
          }
          let i2 = n3 - 1, s2 = 1, a2 = 0;
          for (this[t3 + i2] = 255 & e3; --i2 >= 0 && (s2 *= 256); ) e3 < 0 && 0 === a2 && 0 !== this[t3 + i2 + 1] && (a2 = 1), this[t3 + i2] = (e3 / s2 >> 0) - a2 & 255;
          return t3 + n3;
        }, l.prototype.writeInt8 = function(e3, t3, n3) {
          return e3 = +e3, t3 >>>= 0, n3 || k(this, e3, t3, 1, 127, -128), e3 < 0 && (e3 = 255 + e3 + 1), this[t3] = 255 & e3, t3 + 1;
        }, l.prototype.writeInt16LE = function(e3, t3, n3) {
          return e3 = +e3, t3 >>>= 0, n3 || k(this, e3, t3, 2, 32767, -32768), this[t3] = 255 & e3, this[t3 + 1] = e3 >>> 8, t3 + 2;
        }, l.prototype.writeInt16BE = function(e3, t3, n3) {
          return e3 = +e3, t3 >>>= 0, n3 || k(this, e3, t3, 2, 32767, -32768), this[t3] = e3 >>> 8, this[t3 + 1] = 255 & e3, t3 + 2;
        }, l.prototype.writeInt32LE = function(e3, t3, n3) {
          return e3 = +e3, t3 >>>= 0, n3 || k(this, e3, t3, 4, 2147483647, -2147483648), this[t3] = 255 & e3, this[t3 + 1] = e3 >>> 8, this[t3 + 2] = e3 >>> 16, this[t3 + 3] = e3 >>> 24, t3 + 4;
        }, l.prototype.writeInt32BE = function(e3, t3, n3) {
          return e3 = +e3, t3 >>>= 0, n3 || k(this, e3, t3, 4, 2147483647, -2147483648), e3 < 0 && (e3 = 4294967295 + e3 + 1), this[t3] = e3 >>> 24, this[t3 + 1] = e3 >>> 16, this[t3 + 2] = e3 >>> 8, this[t3 + 3] = 255 & e3, t3 + 4;
        }, l.prototype.writeBigInt64LE = Q(function(e3, t3 = 0) {
          return L(this, e3, t3, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
        }), l.prototype.writeBigInt64BE = Q(function(e3, t3 = 0) {
          return _(this, e3, t3, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
        }), l.prototype.writeFloatLE = function(e3, t3, n3) {
          return B(this, e3, t3, true, n3);
        }, l.prototype.writeFloatBE = function(e3, t3, n3) {
          return B(this, e3, t3, false, n3);
        }, l.prototype.writeDoubleLE = function(e3, t3, n3) {
          return j(this, e3, t3, true, n3);
        }, l.prototype.writeDoubleBE = function(e3, t3, n3) {
          return j(this, e3, t3, false, n3);
        }, l.prototype.copy = function(e3, t3, n3, r3) {
          if (!l.isBuffer(e3)) throw new TypeError("argument should be a Buffer");
          if (n3 || (n3 = 0), r3 || 0 === r3 || (r3 = this.length), t3 >= e3.length && (t3 = e3.length), t3 || (t3 = 0), r3 > 0 && r3 < n3 && (r3 = n3), r3 === n3) return 0;
          if (0 === e3.length || 0 === this.length) return 0;
          if (t3 < 0) throw new RangeError("targetStart out of bounds");
          if (n3 < 0 || n3 >= this.length) throw new RangeError("Index out of range");
          if (r3 < 0) throw new RangeError("sourceEnd out of bounds");
          r3 > this.length && (r3 = this.length), e3.length - t3 < r3 - n3 && (r3 = e3.length - t3 + n3);
          const i2 = r3 - n3;
          return this === e3 && "function" == typeof Uint8Array.prototype.copyWithin ? this.copyWithin(t3, n3, r3) : Uint8Array.prototype.set.call(e3, this.subarray(n3, r3), t3), i2;
        }, l.prototype.fill = function(e3, t3, n3, r3) {
          if ("string" == typeof e3) {
            if ("string" == typeof t3 ? (r3 = t3, t3 = 0, n3 = this.length) : "string" == typeof n3 && (r3 = n3, n3 = this.length), void 0 !== r3 && "string" != typeof r3) throw new TypeError("encoding must be a string");
            if ("string" == typeof r3 && !l.isEncoding(r3)) throw new TypeError("Unknown encoding: " + r3);
            if (1 === e3.length) {
              const t4 = e3.charCodeAt(0);
              ("utf8" === r3 && t4 < 128 || "latin1" === r3) && (e3 = t4);
            }
          } else "number" == typeof e3 ? e3 &= 255 : "boolean" == typeof e3 && (e3 = Number(e3));
          if (t3 < 0 || this.length < t3 || this.length < n3) throw new RangeError("Out of range index");
          if (n3 <= t3) return this;
          let i2;
          if (t3 >>>= 0, n3 = void 0 === n3 ? this.length : n3 >>> 0, e3 || (e3 = 0), "number" == typeof e3) for (i2 = t3; i2 < n3; ++i2) this[i2] = e3;
          else {
            const s2 = l.isBuffer(e3) ? e3 : l.from(e3, r3), a2 = s2.length;
            if (0 === a2) throw new TypeError('The value "' + e3 + '" is invalid for argument "value"');
            for (i2 = 0; i2 < n3 - t3; ++i2) this[i2 + t3] = s2[i2 % a2];
          }
          return this;
        };
        const R = {};
        function U(e3, t3, n3) {
          R[e3] = class extends n3 {
            constructor() {
              super(), Object.defineProperty(this, "message", { value: t3.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${e3}]`, this.stack, delete this.name;
            }
            get code() {
              return e3;
            }
            set code(e4) {
              Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: e4, writable: true });
            }
            toString() {
              return `${this.name} [${e3}]: ${this.message}`;
            }
          };
        }
        function V(e3) {
          let t3 = "", n3 = e3.length;
          const r3 = "-" === e3[0] ? 1 : 0;
          for (; n3 >= r3 + 4; n3 -= 3) t3 = `_${e3.slice(n3 - 3, n3)}${t3}`;
          return `${e3.slice(0, n3)}${t3}`;
        }
        function K(e3, t3, n3, r3, i2, s2) {
          if (e3 > n3 || e3 < t3) {
            const r4 = "bigint" == typeof t3 ? "n" : "";
            let i3;
            throw i3 = s2 > 3 ? 0 === t3 || t3 === BigInt(0) ? `>= 0${r4} and < 2${r4} ** ${8 * (s2 + 1)}${r4}` : `>= -(2${r4} ** ${8 * (s2 + 1) - 1}${r4}) and < 2 ** ${8 * (s2 + 1) - 1}${r4}` : `>= ${t3}${r4} and <= ${n3}${r4}`, new R.ERR_OUT_OF_RANGE("value", i3, e3);
          }
          !function(e4, t4, n4) {
            W(t4, "offset"), void 0 !== e4[t4] && void 0 !== e4[t4 + n4] || X(t4, e4.length - (n4 + 1));
          }(r3, i2, s2);
        }
        function W(e3, t3) {
          if ("number" != typeof e3) throw new R.ERR_INVALID_ARG_TYPE(t3, "number", e3);
        }
        function X(e3, t3, n3) {
          if (Math.floor(e3) !== e3) throw W(e3, n3), new R.ERR_OUT_OF_RANGE(n3 || "offset", "an integer", e3);
          if (t3 < 0) throw new R.ERR_BUFFER_OUT_OF_BOUNDS();
          throw new R.ERR_OUT_OF_RANGE(n3 || "offset", `>= ${n3 ? 1 : 0} and <= ${t3}`, e3);
        }
        U("ERR_BUFFER_OUT_OF_BOUNDS", function(e3) {
          return e3 ? `${e3} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
        }, RangeError), U("ERR_INVALID_ARG_TYPE", function(e3, t3) {
          return `The "${e3}" argument must be of type number. Received type ${typeof t3}`;
        }, TypeError), U("ERR_OUT_OF_RANGE", function(e3, t3, n3) {
          let r3 = `The value of "${e3}" is out of range.`, i2 = n3;
          return Number.isInteger(n3) && Math.abs(n3) > 2 ** 32 ? i2 = V(String(n3)) : "bigint" == typeof n3 && (i2 = String(n3), (n3 > BigInt(2) ** BigInt(32) || n3 < -(BigInt(2) ** BigInt(32))) && (i2 = V(i2)), i2 += "n"), r3 += ` It must be ${t3}. Received ${i2}`, r3;
        }, RangeError);
        const Y = /[^+/0-9A-Za-z-_]/g;
        function q(e3, t3) {
          let n3;
          t3 = t3 || 1 / 0;
          const r3 = e3.length;
          let i2 = null;
          const s2 = [];
          for (let a2 = 0; a2 < r3; ++a2) {
            if (n3 = e3.charCodeAt(a2), n3 > 55295 && n3 < 57344) {
              if (!i2) {
                if (n3 > 56319) {
                  (t3 -= 3) > -1 && s2.push(239, 191, 189);
                  continue;
                }
                if (a2 + 1 === r3) {
                  (t3 -= 3) > -1 && s2.push(239, 191, 189);
                  continue;
                }
                i2 = n3;
                continue;
              }
              if (n3 < 56320) {
                (t3 -= 3) > -1 && s2.push(239, 191, 189), i2 = n3;
                continue;
              }
              n3 = 65536 + (i2 - 55296 << 10 | n3 - 56320);
            } else i2 && (t3 -= 3) > -1 && s2.push(239, 191, 189);
            if (i2 = null, n3 < 128) {
              if ((t3 -= 1) < 0) break;
              s2.push(n3);
            } else if (n3 < 2048) {
              if ((t3 -= 2) < 0) break;
              s2.push(n3 >> 6 | 192, 63 & n3 | 128);
            } else if (n3 < 65536) {
              if ((t3 -= 3) < 0) break;
              s2.push(n3 >> 12 | 224, n3 >> 6 & 63 | 128, 63 & n3 | 128);
            } else {
              if (!(n3 < 1114112)) throw new Error("Invalid code point");
              if ((t3 -= 4) < 0) break;
              s2.push(n3 >> 18 | 240, n3 >> 12 & 63 | 128, n3 >> 6 & 63 | 128, 63 & n3 | 128);
            }
          }
          return s2;
        }
        function H(e3) {
          return r2.toByteArray(function(e4) {
            if ((e4 = (e4 = e4.split("=")[0]).trim().replace(Y, "")).length < 2) return "";
            for (; e4.length % 4 != 0; ) e4 += "=";
            return e4;
          }(e3));
        }
        function J(e3, t3, n3, r3) {
          let i2;
          for (i2 = 0; i2 < r3 && !(i2 + n3 >= t3.length || i2 >= e3.length); ++i2) t3[i2 + n3] = e3[i2];
          return i2;
        }
        function $(e3, t3) {
          return e3 instanceof t3 || null != e3 && null != e3.constructor && null != e3.constructor.name && e3.constructor.name === t3.name;
        }
        function G(e3) {
          return e3 != e3;
        }
        const z = function() {
          const e3 = "0123456789abcdef", t3 = new Array(256);
          for (let n3 = 0; n3 < 16; ++n3) {
            const r3 = 16 * n3;
            for (let i2 = 0; i2 < 16; ++i2) t3[r3 + i2] = e3[n3] + e3[i2];
          }
          return t3;
        }();
        function Q(e3) {
          return "undefined" == typeof BigInt ? Z : e3;
        }
        function Z() {
          throw new Error("BigInt not supported");
        }
      }, 2589: (e2, t2, n2) => {
        "use strict";
        var r2 = n2(4155);
        const i = n2(3150), s = n2(6434), a = n2(8555).stdout, o = n2(6864), l = "win32" === r2.platform && !(r2.env.TERM || "").toLowerCase().startsWith("xterm"), c = ["ansi", "ansi", "ansi256", "ansi16m"], u = /* @__PURE__ */ new Set(["gray"]), p = /* @__PURE__ */ Object.create(null);
        function h(e3, t3) {
          t3 = t3 || {};
          const n3 = a ? a.level : 0;
          e3.level = void 0 === t3.level ? n3 : t3.level, e3.enabled = "enabled" in t3 ? t3.enabled : e3.level > 0;
        }
        function d(e3) {
          if (!this || !(this instanceof d) || this.template) {
            const t3 = {};
            return h(t3, e3), t3.template = function() {
              const e4 = [].slice.call(arguments);
              return T.apply(null, [t3.template].concat(e4));
            }, Object.setPrototypeOf(t3, d.prototype), Object.setPrototypeOf(t3.template, t3), t3.template.constructor = d, t3.template;
          }
          h(this, e3);
        }
        l && (s.blue.open = "\x1B[94m");
        for (const e3 of Object.keys(s)) s[e3].closeRe = new RegExp(i(s[e3].close), "g"), p[e3] = { get() {
          const t3 = s[e3];
          return y.call(this, this._styles ? this._styles.concat(t3) : [t3], this._empty, e3);
        } };
        p.visible = { get() {
          return y.call(this, this._styles || [], true, "visible");
        } }, s.color.closeRe = new RegExp(i(s.color.close), "g");
        for (const e3 of Object.keys(s.color.ansi)) u.has(e3) || (p[e3] = { get() {
          const t3 = this.level;
          return function() {
            const n3 = { open: s.color[c[t3]][e3].apply(null, arguments), close: s.color.close, closeRe: s.color.closeRe };
            return y.call(this, this._styles ? this._styles.concat(n3) : [n3], this._empty, e3);
          };
        } });
        s.bgColor.closeRe = new RegExp(i(s.bgColor.close), "g");
        for (const e3 of Object.keys(s.bgColor.ansi)) u.has(e3) || (p["bg" + e3[0].toUpperCase() + e3.slice(1)] = { get() {
          const t3 = this.level;
          return function() {
            const n3 = { open: s.bgColor[c[t3]][e3].apply(null, arguments), close: s.bgColor.close, closeRe: s.bgColor.closeRe };
            return y.call(this, this._styles ? this._styles.concat(n3) : [n3], this._empty, e3);
          };
        } });
        const f = Object.defineProperties(() => {
        }, p);
        function y(e3, t3, n3) {
          const r3 = function() {
            return m.apply(r3, arguments);
          };
          r3._styles = e3, r3._empty = t3;
          const i2 = this;
          return Object.defineProperty(r3, "level", { enumerable: true, get: () => i2.level, set(e4) {
            i2.level = e4;
          } }), Object.defineProperty(r3, "enabled", { enumerable: true, get: () => i2.enabled, set(e4) {
            i2.enabled = e4;
          } }), r3.hasGrey = this.hasGrey || "gray" === n3 || "grey" === n3, r3.__proto__ = f, r3;
        }
        function m() {
          const e3 = arguments, t3 = e3.length;
          let n3 = String(arguments[0]);
          if (0 === t3) return "";
          if (t3 > 1) for (let r4 = 1; r4 < t3; r4++) n3 += " " + e3[r4];
          if (!this.enabled || this.level <= 0 || !n3) return this._empty ? "" : n3;
          const r3 = s.dim.open;
          l && this.hasGrey && (s.dim.open = "");
          for (const e4 of this._styles.slice().reverse()) n3 = e4.open + n3.replace(e4.closeRe, e4.open) + e4.close, n3 = n3.replace(/\r?\n/g, `${e4.close}$&${e4.open}`);
          return s.dim.open = r3, n3;
        }
        function T(e3, t3) {
          if (!Array.isArray(t3)) return [].slice.call(arguments, 1).join(" ");
          const n3 = [].slice.call(arguments, 2), r3 = [t3.raw[0]];
          for (let e4 = 1; e4 < t3.length; e4++) r3.push(String(n3[e4 - 1]).replace(/[{}\\]/g, "\\$&")), r3.push(String(t3.raw[e4]));
          return o(e3, r3.join(""));
        }
        Object.defineProperties(d.prototype, p), e2.exports = d(), e2.exports.supportsColor = a, e2.exports.default = e2.exports;
      }, 6864: (e2) => {
        "use strict";
        const t2 = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, n2 = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, r2 = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, i = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi, s = /* @__PURE__ */ new Map([["n", "\n"], ["r", "\r"], ["t", "	"], ["b", "\b"], ["f", "\f"], ["v", "\v"], ["0", "\0"], ["\\", "\\"], ["e", "\x1B"], ["a", "\x07"]]);
        function a(e3) {
          return "u" === e3[0] && 5 === e3.length || "x" === e3[0] && 3 === e3.length ? String.fromCharCode(parseInt(e3.slice(1), 16)) : s.get(e3) || e3;
        }
        function o(e3, t3) {
          const n3 = [], s2 = t3.trim().split(/\s*,\s*/g);
          let o2;
          for (const t4 of s2) if (isNaN(t4)) {
            if (!(o2 = t4.match(r2))) throw new Error(`Invalid Chalk template style argument: ${t4} (in style '${e3}')`);
            n3.push(o2[2].replace(i, (e4, t5, n4) => t5 ? a(t5) : n4));
          } else n3.push(Number(t4));
          return n3;
        }
        function l(e3) {
          n2.lastIndex = 0;
          const t3 = [];
          let r3;
          for (; null !== (r3 = n2.exec(e3)); ) {
            const e4 = r3[1];
            if (r3[2]) {
              const n3 = o(e4, r3[2]);
              t3.push([e4].concat(n3));
            } else t3.push([e4]);
          }
          return t3;
        }
        function c(e3, t3) {
          const n3 = {};
          for (const e4 of t3) for (const t4 of e4.styles) n3[t4[0]] = e4.inverse ? null : t4.slice(1);
          let r3 = e3;
          for (const e4 of Object.keys(n3)) if (Array.isArray(n3[e4])) {
            if (!(e4 in r3)) throw new Error(`Unknown Chalk style: ${e4}`);
            r3 = n3[e4].length > 0 ? r3[e4].apply(r3, n3[e4]) : r3[e4];
          }
          return r3;
        }
        e2.exports = (e3, n3) => {
          const r3 = [], i2 = [];
          let s2 = [];
          if (n3.replace(t2, (t3, n4, o2, u, p, h) => {
            if (n4) s2.push(a(n4));
            else if (u) {
              const t4 = s2.join("");
              s2 = [], i2.push(0 === r3.length ? t4 : c(e3, r3)(t4)), r3.push({ inverse: o2, styles: l(u) });
            } else if (p) {
              if (0 === r3.length) throw new Error("Found extraneous } in Chalk template literal");
              i2.push(c(e3, r3)(s2.join(""))), s2 = [], r3.pop();
            } else s2.push(h);
          }), i2.push(s2.join("")), r3.length > 0) {
            const e4 = `Chalk template literal is missing ${r3.length} closing bracket${1 === r3.length ? "" : "s"} (\`}\`)`;
            throw new Error(e4);
          }
          return i2.join("");
        };
      }, 8168: (e2, t2, n2) => {
        var r2 = n2(3515), i = {};
        for (var s in r2) r2.hasOwnProperty(s) && (i[r2[s]] = s);
        var a = e2.exports = { rgb: { channels: 3, labels: "rgb" }, hsl: { channels: 3, labels: "hsl" }, hsv: { channels: 3, labels: "hsv" }, hwb: { channels: 3, labels: "hwb" }, cmyk: { channels: 4, labels: "cmyk" }, xyz: { channels: 3, labels: "xyz" }, lab: { channels: 3, labels: "lab" }, lch: { channels: 3, labels: "lch" }, hex: { channels: 1, labels: ["hex"] }, keyword: { channels: 1, labels: ["keyword"] }, ansi16: { channels: 1, labels: ["ansi16"] }, ansi256: { channels: 1, labels: ["ansi256"] }, hcg: { channels: 3, labels: ["h", "c", "g"] }, apple: { channels: 3, labels: ["r16", "g16", "b16"] }, gray: { channels: 1, labels: ["gray"] } };
        for (var o in a) if (a.hasOwnProperty(o)) {
          if (!("channels" in a[o])) throw new Error("missing channels property: " + o);
          if (!("labels" in a[o])) throw new Error("missing channel labels property: " + o);
          if (a[o].labels.length !== a[o].channels) throw new Error("channel and label counts mismatch: " + o);
          var l = a[o].channels, c = a[o].labels;
          delete a[o].channels, delete a[o].labels, Object.defineProperty(a[o], "channels", { value: l }), Object.defineProperty(a[o], "labels", { value: c });
        }
        a.rgb.hsl = function(e3) {
          var t3, n3, r3 = e3[0] / 255, i2 = e3[1] / 255, s2 = e3[2] / 255, a2 = Math.min(r3, i2, s2), o2 = Math.max(r3, i2, s2), l2 = o2 - a2;
          return o2 === a2 ? t3 = 0 : r3 === o2 ? t3 = (i2 - s2) / l2 : i2 === o2 ? t3 = 2 + (s2 - r3) / l2 : s2 === o2 && (t3 = 4 + (r3 - i2) / l2), (t3 = Math.min(60 * t3, 360)) < 0 && (t3 += 360), n3 = (a2 + o2) / 2, [t3, 100 * (o2 === a2 ? 0 : n3 <= 0.5 ? l2 / (o2 + a2) : l2 / (2 - o2 - a2)), 100 * n3];
        }, a.rgb.hsv = function(e3) {
          var t3, n3, r3 = e3[0], i2 = e3[1], s2 = e3[2], a2 = Math.min(r3, i2, s2), o2 = Math.max(r3, i2, s2), l2 = o2 - a2;
          return n3 = 0 === o2 ? 0 : l2 / o2 * 1e3 / 10, o2 === a2 ? t3 = 0 : r3 === o2 ? t3 = (i2 - s2) / l2 : i2 === o2 ? t3 = 2 + (s2 - r3) / l2 : s2 === o2 && (t3 = 4 + (r3 - i2) / l2), (t3 = Math.min(60 * t3, 360)) < 0 && (t3 += 360), [t3, n3, o2 / 255 * 1e3 / 10];
        }, a.rgb.hwb = function(e3) {
          var t3 = e3[0], n3 = e3[1], r3 = e3[2];
          return [a.rgb.hsl(e3)[0], 1 / 255 * Math.min(t3, Math.min(n3, r3)) * 100, 100 * (r3 = 1 - 1 / 255 * Math.max(t3, Math.max(n3, r3)))];
        }, a.rgb.cmyk = function(e3) {
          var t3, n3 = e3[0] / 255, r3 = e3[1] / 255, i2 = e3[2] / 255;
          return [100 * ((1 - n3 - (t3 = Math.min(1 - n3, 1 - r3, 1 - i2))) / (1 - t3) || 0), 100 * ((1 - r3 - t3) / (1 - t3) || 0), 100 * ((1 - i2 - t3) / (1 - t3) || 0), 100 * t3];
        }, a.rgb.keyword = function(e3) {
          var t3 = i[e3];
          if (t3) return t3;
          var n3, s2, a2, o2 = 1 / 0;
          for (var l2 in r2) if (r2.hasOwnProperty(l2)) {
            var c2 = (s2 = e3, a2 = r2[l2], Math.pow(s2[0] - a2[0], 2) + Math.pow(s2[1] - a2[1], 2) + Math.pow(s2[2] - a2[2], 2));
            c2 < o2 && (o2 = c2, n3 = l2);
          }
          return n3;
        }, a.keyword.rgb = function(e3) {
          return r2[e3];
        }, a.rgb.xyz = function(e3) {
          var t3 = e3[0] / 255, n3 = e3[1] / 255, r3 = e3[2] / 255;
          return [100 * (0.4124 * (t3 = t3 > 0.04045 ? Math.pow((t3 + 0.055) / 1.055, 2.4) : t3 / 12.92) + 0.3576 * (n3 = n3 > 0.04045 ? Math.pow((n3 + 0.055) / 1.055, 2.4) : n3 / 12.92) + 0.1805 * (r3 = r3 > 0.04045 ? Math.pow((r3 + 0.055) / 1.055, 2.4) : r3 / 12.92)), 100 * (0.2126 * t3 + 0.7152 * n3 + 0.0722 * r3), 100 * (0.0193 * t3 + 0.1192 * n3 + 0.9505 * r3)];
        }, a.rgb.lab = function(e3) {
          var t3 = a.rgb.xyz(e3), n3 = t3[0], r3 = t3[1], i2 = t3[2];
          return r3 /= 100, i2 /= 108.883, n3 = (n3 /= 95.047) > 8856e-6 ? Math.pow(n3, 1 / 3) : 7.787 * n3 + 16 / 116, [116 * (r3 = r3 > 8856e-6 ? Math.pow(r3, 1 / 3) : 7.787 * r3 + 16 / 116) - 16, 500 * (n3 - r3), 200 * (r3 - (i2 = i2 > 8856e-6 ? Math.pow(i2, 1 / 3) : 7.787 * i2 + 16 / 116))];
        }, a.hsl.rgb = function(e3) {
          var t3, n3, r3, i2, s2, a2 = e3[0] / 360, o2 = e3[1] / 100, l2 = e3[2] / 100;
          if (0 === o2) return [s2 = 255 * l2, s2, s2];
          t3 = 2 * l2 - (n3 = l2 < 0.5 ? l2 * (1 + o2) : l2 + o2 - l2 * o2), i2 = [0, 0, 0];
          for (var c2 = 0; c2 < 3; c2++) (r3 = a2 + 1 / 3 * -(c2 - 1)) < 0 && r3++, r3 > 1 && r3--, s2 = 6 * r3 < 1 ? t3 + 6 * (n3 - t3) * r3 : 2 * r3 < 1 ? n3 : 3 * r3 < 2 ? t3 + (n3 - t3) * (2 / 3 - r3) * 6 : t3, i2[c2] = 255 * s2;
          return i2;
        }, a.hsl.hsv = function(e3) {
          var t3 = e3[0], n3 = e3[1] / 100, r3 = e3[2] / 100, i2 = n3, s2 = Math.max(r3, 0.01);
          return n3 *= (r3 *= 2) <= 1 ? r3 : 2 - r3, i2 *= s2 <= 1 ? s2 : 2 - s2, [t3, 100 * (0 === r3 ? 2 * i2 / (s2 + i2) : 2 * n3 / (r3 + n3)), (r3 + n3) / 2 * 100];
        }, a.hsv.rgb = function(e3) {
          var t3 = e3[0] / 60, n3 = e3[1] / 100, r3 = e3[2] / 100, i2 = Math.floor(t3) % 6, s2 = t3 - Math.floor(t3), a2 = 255 * r3 * (1 - n3), o2 = 255 * r3 * (1 - n3 * s2), l2 = 255 * r3 * (1 - n3 * (1 - s2));
          switch (r3 *= 255, i2) {
            case 0:
              return [r3, l2, a2];
            case 1:
              return [o2, r3, a2];
            case 2:
              return [a2, r3, l2];
            case 3:
              return [a2, o2, r3];
            case 4:
              return [l2, a2, r3];
            case 5:
              return [r3, a2, o2];
          }
        }, a.hsv.hsl = function(e3) {
          var t3, n3, r3, i2 = e3[0], s2 = e3[1] / 100, a2 = e3[2] / 100, o2 = Math.max(a2, 0.01);
          return r3 = (2 - s2) * a2, n3 = s2 * o2, [i2, 100 * (n3 = (n3 /= (t3 = (2 - s2) * o2) <= 1 ? t3 : 2 - t3) || 0), 100 * (r3 /= 2)];
        }, a.hwb.rgb = function(e3) {
          var t3, n3, r3, i2, s2, a2, o2, l2 = e3[0] / 360, c2 = e3[1] / 100, u = e3[2] / 100, p = c2 + u;
          switch (p > 1 && (c2 /= p, u /= p), r3 = 6 * l2 - (t3 = Math.floor(6 * l2)), 0 != (1 & t3) && (r3 = 1 - r3), i2 = c2 + r3 * ((n3 = 1 - u) - c2), t3) {
            default:
            case 6:
            case 0:
              s2 = n3, a2 = i2, o2 = c2;
              break;
            case 1:
              s2 = i2, a2 = n3, o2 = c2;
              break;
            case 2:
              s2 = c2, a2 = n3, o2 = i2;
              break;
            case 3:
              s2 = c2, a2 = i2, o2 = n3;
              break;
            case 4:
              s2 = i2, a2 = c2, o2 = n3;
              break;
            case 5:
              s2 = n3, a2 = c2, o2 = i2;
          }
          return [255 * s2, 255 * a2, 255 * o2];
        }, a.cmyk.rgb = function(e3) {
          var t3 = e3[0] / 100, n3 = e3[1] / 100, r3 = e3[2] / 100, i2 = e3[3] / 100;
          return [255 * (1 - Math.min(1, t3 * (1 - i2) + i2)), 255 * (1 - Math.min(1, n3 * (1 - i2) + i2)), 255 * (1 - Math.min(1, r3 * (1 - i2) + i2))];
        }, a.xyz.rgb = function(e3) {
          var t3, n3, r3, i2 = e3[0] / 100, s2 = e3[1] / 100, a2 = e3[2] / 100;
          return n3 = -0.9689 * i2 + 1.8758 * s2 + 0.0415 * a2, r3 = 0.0557 * i2 + -0.204 * s2 + 1.057 * a2, t3 = (t3 = 3.2406 * i2 + -1.5372 * s2 + -0.4986 * a2) > 31308e-7 ? 1.055 * Math.pow(t3, 1 / 2.4) - 0.055 : 12.92 * t3, n3 = n3 > 31308e-7 ? 1.055 * Math.pow(n3, 1 / 2.4) - 0.055 : 12.92 * n3, r3 = r3 > 31308e-7 ? 1.055 * Math.pow(r3, 1 / 2.4) - 0.055 : 12.92 * r3, [255 * (t3 = Math.min(Math.max(0, t3), 1)), 255 * (n3 = Math.min(Math.max(0, n3), 1)), 255 * (r3 = Math.min(Math.max(0, r3), 1))];
        }, a.xyz.lab = function(e3) {
          var t3 = e3[0], n3 = e3[1], r3 = e3[2];
          return n3 /= 100, r3 /= 108.883, t3 = (t3 /= 95.047) > 8856e-6 ? Math.pow(t3, 1 / 3) : 7.787 * t3 + 16 / 116, [116 * (n3 = n3 > 8856e-6 ? Math.pow(n3, 1 / 3) : 7.787 * n3 + 16 / 116) - 16, 500 * (t3 - n3), 200 * (n3 - (r3 = r3 > 8856e-6 ? Math.pow(r3, 1 / 3) : 7.787 * r3 + 16 / 116))];
        }, a.lab.xyz = function(e3) {
          var t3, n3, r3, i2 = e3[0];
          t3 = e3[1] / 500 + (n3 = (i2 + 16) / 116), r3 = n3 - e3[2] / 200;
          var s2 = Math.pow(n3, 3), a2 = Math.pow(t3, 3), o2 = Math.pow(r3, 3);
          return n3 = s2 > 8856e-6 ? s2 : (n3 - 16 / 116) / 7.787, t3 = a2 > 8856e-6 ? a2 : (t3 - 16 / 116) / 7.787, r3 = o2 > 8856e-6 ? o2 : (r3 - 16 / 116) / 7.787, [t3 *= 95.047, n3 *= 100, r3 *= 108.883];
        }, a.lab.lch = function(e3) {
          var t3, n3 = e3[0], r3 = e3[1], i2 = e3[2];
          return (t3 = 360 * Math.atan2(i2, r3) / 2 / Math.PI) < 0 && (t3 += 360), [n3, Math.sqrt(r3 * r3 + i2 * i2), t3];
        }, a.lch.lab = function(e3) {
          var t3, n3 = e3[0], r3 = e3[1];
          return t3 = e3[2] / 360 * 2 * Math.PI, [n3, r3 * Math.cos(t3), r3 * Math.sin(t3)];
        }, a.rgb.ansi16 = function(e3) {
          var t3 = e3[0], n3 = e3[1], r3 = e3[2], i2 = 1 in arguments ? arguments[1] : a.rgb.hsv(e3)[2];
          if (0 === (i2 = Math.round(i2 / 50))) return 30;
          var s2 = 30 + (Math.round(r3 / 255) << 2 | Math.round(n3 / 255) << 1 | Math.round(t3 / 255));
          return 2 === i2 && (s2 += 60), s2;
        }, a.hsv.ansi16 = function(e3) {
          return a.rgb.ansi16(a.hsv.rgb(e3), e3[2]);
        }, a.rgb.ansi256 = function(e3) {
          var t3 = e3[0], n3 = e3[1], r3 = e3[2];
          return t3 === n3 && n3 === r3 ? t3 < 8 ? 16 : t3 > 248 ? 231 : Math.round((t3 - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(t3 / 255 * 5) + 6 * Math.round(n3 / 255 * 5) + Math.round(r3 / 255 * 5);
        }, a.ansi16.rgb = function(e3) {
          var t3 = e3 % 10;
          if (0 === t3 || 7 === t3) return e3 > 50 && (t3 += 3.5), [t3 = t3 / 10.5 * 255, t3, t3];
          var n3 = 0.5 * (1 + ~~(e3 > 50));
          return [(1 & t3) * n3 * 255, (t3 >> 1 & 1) * n3 * 255, (t3 >> 2 & 1) * n3 * 255];
        }, a.ansi256.rgb = function(e3) {
          if (e3 >= 232) {
            var t3 = 10 * (e3 - 232) + 8;
            return [t3, t3, t3];
          }
          var n3;
          return e3 -= 16, [Math.floor(e3 / 36) / 5 * 255, Math.floor((n3 = e3 % 36) / 6) / 5 * 255, n3 % 6 / 5 * 255];
        }, a.rgb.hex = function(e3) {
          var t3 = (((255 & Math.round(e3[0])) << 16) + ((255 & Math.round(e3[1])) << 8) + (255 & Math.round(e3[2]))).toString(16).toUpperCase();
          return "000000".substring(t3.length) + t3;
        }, a.hex.rgb = function(e3) {
          var t3 = e3.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
          if (!t3) return [0, 0, 0];
          var n3 = t3[0];
          3 === t3[0].length && (n3 = n3.split("").map(function(e4) {
            return e4 + e4;
          }).join(""));
          var r3 = parseInt(n3, 16);
          return [r3 >> 16 & 255, r3 >> 8 & 255, 255 & r3];
        }, a.rgb.hcg = function(e3) {
          var t3, n3 = e3[0] / 255, r3 = e3[1] / 255, i2 = e3[2] / 255, s2 = Math.max(Math.max(n3, r3), i2), a2 = Math.min(Math.min(n3, r3), i2), o2 = s2 - a2;
          return t3 = o2 <= 0 ? 0 : s2 === n3 ? (r3 - i2) / o2 % 6 : s2 === r3 ? 2 + (i2 - n3) / o2 : 4 + (n3 - r3) / o2 + 4, t3 /= 6, [360 * (t3 %= 1), 100 * o2, 100 * (o2 < 1 ? a2 / (1 - o2) : 0)];
        }, a.hsl.hcg = function(e3) {
          var t3, n3 = e3[1] / 100, r3 = e3[2] / 100, i2 = 0;
          return (t3 = r3 < 0.5 ? 2 * n3 * r3 : 2 * n3 * (1 - r3)) < 1 && (i2 = (r3 - 0.5 * t3) / (1 - t3)), [e3[0], 100 * t3, 100 * i2];
        }, a.hsv.hcg = function(e3) {
          var t3 = e3[1] / 100, n3 = e3[2] / 100, r3 = t3 * n3, i2 = 0;
          return r3 < 1 && (i2 = (n3 - r3) / (1 - r3)), [e3[0], 100 * r3, 100 * i2];
        }, a.hcg.rgb = function(e3) {
          var t3 = e3[0] / 360, n3 = e3[1] / 100, r3 = e3[2] / 100;
          if (0 === n3) return [255 * r3, 255 * r3, 255 * r3];
          var i2, s2 = [0, 0, 0], a2 = t3 % 1 * 6, o2 = a2 % 1, l2 = 1 - o2;
          switch (Math.floor(a2)) {
            case 0:
              s2[0] = 1, s2[1] = o2, s2[2] = 0;
              break;
            case 1:
              s2[0] = l2, s2[1] = 1, s2[2] = 0;
              break;
            case 2:
              s2[0] = 0, s2[1] = 1, s2[2] = o2;
              break;
            case 3:
              s2[0] = 0, s2[1] = l2, s2[2] = 1;
              break;
            case 4:
              s2[0] = o2, s2[1] = 0, s2[2] = 1;
              break;
            default:
              s2[0] = 1, s2[1] = 0, s2[2] = l2;
          }
          return i2 = (1 - n3) * r3, [255 * (n3 * s2[0] + i2), 255 * (n3 * s2[1] + i2), 255 * (n3 * s2[2] + i2)];
        }, a.hcg.hsv = function(e3) {
          var t3 = e3[1] / 100, n3 = t3 + e3[2] / 100 * (1 - t3), r3 = 0;
          return n3 > 0 && (r3 = t3 / n3), [e3[0], 100 * r3, 100 * n3];
        }, a.hcg.hsl = function(e3) {
          var t3 = e3[1] / 100, n3 = e3[2] / 100 * (1 - t3) + 0.5 * t3, r3 = 0;
          return n3 > 0 && n3 < 0.5 ? r3 = t3 / (2 * n3) : n3 >= 0.5 && n3 < 1 && (r3 = t3 / (2 * (1 - n3))), [e3[0], 100 * r3, 100 * n3];
        }, a.hcg.hwb = function(e3) {
          var t3 = e3[1] / 100, n3 = t3 + e3[2] / 100 * (1 - t3);
          return [e3[0], 100 * (n3 - t3), 100 * (1 - n3)];
        }, a.hwb.hcg = function(e3) {
          var t3 = e3[1] / 100, n3 = 1 - e3[2] / 100, r3 = n3 - t3, i2 = 0;
          return r3 < 1 && (i2 = (n3 - r3) / (1 - r3)), [e3[0], 100 * r3, 100 * i2];
        }, a.apple.rgb = function(e3) {
          return [e3[0] / 65535 * 255, e3[1] / 65535 * 255, e3[2] / 65535 * 255];
        }, a.rgb.apple = function(e3) {
          return [e3[0] / 255 * 65535, e3[1] / 255 * 65535, e3[2] / 255 * 65535];
        }, a.gray.rgb = function(e3) {
          return [e3[0] / 100 * 255, e3[0] / 100 * 255, e3[0] / 100 * 255];
        }, a.gray.hsl = a.gray.hsv = function(e3) {
          return [0, 0, e3[0]];
        }, a.gray.hwb = function(e3) {
          return [0, 100, e3[0]];
        }, a.gray.cmyk = function(e3) {
          return [0, 0, 0, e3[0]];
        }, a.gray.lab = function(e3) {
          return [e3[0], 0, 0];
        }, a.gray.hex = function(e3) {
          var t3 = 255 & Math.round(e3[0] / 100 * 255), n3 = ((t3 << 16) + (t3 << 8) + t3).toString(16).toUpperCase();
          return "000000".substring(n3.length) + n3;
        }, a.rgb.gray = function(e3) {
          return [(e3[0] + e3[1] + e3[2]) / 3 / 255 * 100];
        };
      }, 2085: (e2, t2, n2) => {
        var r2 = n2(8168), i = n2(4111), s = {};
        Object.keys(r2).forEach(function(e3) {
          s[e3] = {}, Object.defineProperty(s[e3], "channels", { value: r2[e3].channels }), Object.defineProperty(s[e3], "labels", { value: r2[e3].labels });
          var t3 = i(e3);
          Object.keys(t3).forEach(function(n3) {
            var r3 = t3[n3];
            s[e3][n3] = function(e4) {
              var t4 = function(t5) {
                if (null == t5) return t5;
                arguments.length > 1 && (t5 = Array.prototype.slice.call(arguments));
                var n4 = e4(t5);
                if ("object" == typeof n4) for (var r4 = n4.length, i2 = 0; i2 < r4; i2++) n4[i2] = Math.round(n4[i2]);
                return n4;
              };
              return "conversion" in e4 && (t4.conversion = e4.conversion), t4;
            }(r3), s[e3][n3].raw = function(e4) {
              var t4 = function(t5) {
                return null == t5 ? t5 : (arguments.length > 1 && (t5 = Array.prototype.slice.call(arguments)), e4(t5));
              };
              return "conversion" in e4 && (t4.conversion = e4.conversion), t4;
            }(r3);
          });
        }), e2.exports = s;
      }, 4111: (e2, t2, n2) => {
        var r2 = n2(8168);
        function i(e3, t3) {
          return function(n3) {
            return t3(e3(n3));
          };
        }
        function s(e3, t3) {
          for (var n3 = [t3[e3].parent, e3], s2 = r2[t3[e3].parent][e3], a = t3[e3].parent; t3[a].parent; ) n3.unshift(t3[a].parent), s2 = i(r2[t3[a].parent][a], s2), a = t3[a].parent;
          return s2.conversion = n3, s2;
        }
        e2.exports = function(e3) {
          for (var t3 = function(e4) {
            var t4 = function() {
              for (var e5 = {}, t5 = Object.keys(r2), n5 = t5.length, i4 = 0; i4 < n5; i4++) e5[t5[i4]] = { distance: -1, parent: null };
              return e5;
            }(), n4 = [e4];
            for (t4[e4].distance = 0; n4.length; ) for (var i3 = n4.pop(), s2 = Object.keys(r2[i3]), a2 = s2.length, o2 = 0; o2 < a2; o2++) {
              var l2 = s2[o2], c = t4[l2];
              -1 === c.distance && (c.distance = t4[i3].distance + 1, c.parent = i3, n4.unshift(l2));
            }
            return t4;
          }(e3), n3 = {}, i2 = Object.keys(t3), a = i2.length, o = 0; o < a; o++) {
            var l = i2[o];
            null !== t3[l].parent && (n3[l] = s(l, t3));
          }
          return n3;
        };
      }, 3515: (e2) => {
        "use strict";
        e2.exports = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
      }, 1227: (e2, t2, n2) => {
        var r2 = n2(4155);
        t2.log = function(...e3) {
          return "object" == typeof console && console.log && console.log(...e3);
        }, t2.formatArgs = function(t3) {
          if (t3[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + t3[0] + (this.useColors ? "%c " : " ") + "+" + e2.exports.humanize(this.diff), !this.useColors) return;
          const n3 = "color: " + this.color;
          t3.splice(1, 0, n3, "color: inherit");
          let r3 = 0, i2 = 0;
          t3[0].replace(/%[a-zA-Z%]/g, (e3) => {
            "%%" !== e3 && (r3++, "%c" === e3 && (i2 = r3));
          }), t3.splice(i2, 0, n3);
        }, t2.save = function(e3) {
          try {
            e3 ? t2.storage.setItem("debug", e3) : t2.storage.removeItem("debug");
          } catch (e4) {
          }
        }, t2.load = function() {
          let e3;
          try {
            e3 = t2.storage.getItem("debug");
          } catch (e4) {
          }
          return !e3 && void 0 !== r2 && "env" in r2 && (e3 = r2.env.DEBUG), e3;
        }, t2.useColors = function() {
          return !("undefined" == typeof window || !window.process || "renderer" !== window.process.type && !window.process.__nwjs) || ("undefined" == typeof navigator || !navigator.userAgent || !navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) && ("undefined" != typeof document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "undefined" != typeof window && window.console && (window.console.firebug || window.console.exception && window.console.table) || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
        }, t2.storage = function() {
          try {
            return localStorage;
          } catch (e3) {
          }
        }(), t2.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"], e2.exports = n2(2447)(t2);
        const { formatters: i } = e2.exports;
        i.j = function(e3) {
          try {
            return JSON.stringify(e3);
          } catch (e4) {
            return "[UnexpectedJSONParseError]: " + e4.message;
          }
        };
      }, 2447: (e2, t2, n2) => {
        e2.exports = function(e3) {
          function t3(e4) {
            let t4 = 0;
            for (let n3 = 0; n3 < e4.length; n3++) t4 = (t4 << 5) - t4 + e4.charCodeAt(n3), t4 |= 0;
            return r2.colors[Math.abs(t4) % r2.colors.length];
          }
          function r2(e4) {
            let n3;
            function a2(...e5) {
              if (!a2.enabled) return;
              const t4 = a2, i2 = Number(/* @__PURE__ */ new Date()), s2 = i2 - (n3 || i2);
              t4.diff = s2, t4.prev = n3, t4.curr = i2, n3 = i2, e5[0] = r2.coerce(e5[0]), "string" != typeof e5[0] && e5.unshift("%O");
              let o = 0;
              e5[0] = e5[0].replace(/%([a-zA-Z%])/g, (n4, i3) => {
                if ("%%" === n4) return n4;
                o++;
                const s3 = r2.formatters[i3];
                if ("function" == typeof s3) {
                  const r3 = e5[o];
                  n4 = s3.call(t4, r3), e5.splice(o, 1), o--;
                }
                return n4;
              }), r2.formatArgs.call(t4, e5), (t4.log || r2.log).apply(t4, e5);
            }
            return a2.namespace = e4, a2.enabled = r2.enabled(e4), a2.useColors = r2.useColors(), a2.color = t3(e4), a2.destroy = i, a2.extend = s, "function" == typeof r2.init && r2.init(a2), r2.instances.push(a2), a2;
          }
          function i() {
            const e4 = r2.instances.indexOf(this);
            return -1 !== e4 && (r2.instances.splice(e4, 1), true);
          }
          function s(e4, t4) {
            const n3 = r2(this.namespace + (void 0 === t4 ? ":" : t4) + e4);
            return n3.log = this.log, n3;
          }
          function a(e4) {
            return e4.toString().substring(2, e4.toString().length - 2).replace(/\.\*\?$/, "*");
          }
          return r2.debug = r2, r2.default = r2, r2.coerce = function(e4) {
            return e4 instanceof Error ? e4.stack || e4.message : e4;
          }, r2.disable = function() {
            const e4 = [...r2.names.map(a), ...r2.skips.map(a).map((e5) => "-" + e5)].join(",");
            return r2.enable(""), e4;
          }, r2.enable = function(e4) {
            let t4;
            r2.save(e4), r2.names = [], r2.skips = [];
            const n3 = ("string" == typeof e4 ? e4 : "").split(/[\s,]+/), i2 = n3.length;
            for (t4 = 0; t4 < i2; t4++) n3[t4] && ("-" === (e4 = n3[t4].replace(/\*/g, ".*?"))[0] ? r2.skips.push(new RegExp("^" + e4.substr(1) + "$")) : r2.names.push(new RegExp("^" + e4 + "$")));
            for (t4 = 0; t4 < r2.instances.length; t4++) {
              const e5 = r2.instances[t4];
              e5.enabled = r2.enabled(e5.namespace);
            }
          }, r2.enabled = function(e4) {
            if ("*" === e4[e4.length - 1]) return true;
            let t4, n3;
            for (t4 = 0, n3 = r2.skips.length; t4 < n3; t4++) if (r2.skips[t4].test(e4)) return false;
            for (t4 = 0, n3 = r2.names.length; t4 < n3; t4++) if (r2.names[t4].test(e4)) return true;
            return false;
          }, r2.humanize = n2(7824), Object.keys(e3).forEach((t4) => {
            r2[t4] = e3[t4];
          }), r2.instances = [], r2.names = [], r2.skips = [], r2.formatters = {}, r2.selectColor = t3, r2.enable(r2.load()), r2;
        };
      }, 9996: (e2) => {
        "use strict";
        var t2 = function(e3) {
          return /* @__PURE__ */ function(e4) {
            return !!e4 && "object" == typeof e4;
          }(e3) && !function(e4) {
            var t3 = Object.prototype.toString.call(e4);
            return "[object RegExp]" === t3 || "[object Date]" === t3 || function(e5) {
              return e5.$$typeof === n2;
            }(e4);
          }(e3);
        }, n2 = "function" == typeof Symbol && Symbol.for ? Symbol.for("react.element") : 60103;
        function r2(e3, t3) {
          return false !== t3.clone && t3.isMergeableObject(e3) ? o((n3 = e3, Array.isArray(n3) ? [] : {}), e3, t3) : e3;
          var n3;
        }
        function i(e3, t3, n3) {
          return e3.concat(t3).map(function(e4) {
            return r2(e4, n3);
          });
        }
        function s(e3) {
          return Object.keys(e3).concat(function(e4) {
            return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(e4).filter(function(t3) {
              return Object.propertyIsEnumerable.call(e4, t3);
            }) : [];
          }(e3));
        }
        function a(e3, t3) {
          try {
            return t3 in e3;
          } catch (e4) {
            return false;
          }
        }
        function o(e3, n3, l2) {
          (l2 = l2 || {}).arrayMerge = l2.arrayMerge || i, l2.isMergeableObject = l2.isMergeableObject || t2, l2.cloneUnlessOtherwiseSpecified = r2;
          var c = Array.isArray(n3);
          return c === Array.isArray(e3) ? c ? l2.arrayMerge(e3, n3, l2) : function(e4, t3, n4) {
            var i2 = {};
            return n4.isMergeableObject(e4) && s(e4).forEach(function(t4) {
              i2[t4] = r2(e4[t4], n4);
            }), s(t3).forEach(function(s2) {
              (function(e5, t4) {
                return a(e5, t4) && !(Object.hasOwnProperty.call(e5, t4) && Object.propertyIsEnumerable.call(e5, t4));
              })(e4, s2) || (a(e4, s2) && n4.isMergeableObject(t3[s2]) ? i2[s2] = function(e5, t4) {
                if (!t4.customMerge) return o;
                var n5 = t4.customMerge(e5);
                return "function" == typeof n5 ? n5 : o;
              }(s2, n4)(e4[s2], t3[s2], n4) : i2[s2] = r2(t3[s2], n4));
            }), i2;
          }(e3, n3, l2) : r2(n3, l2);
        }
        o.all = function(e3, t3) {
          if (!Array.isArray(e3)) throw new Error("first argument should be an array");
          return e3.reduce(function(e4, n3) {
            return o(e4, n3, t3);
          }, {});
        };
        var l = o;
        e2.exports = l;
      }, 4021: (e2) => {
        var t2 = {};
        function n2(e3) {
          return e3.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]|[^\uD800-\uDFFF]/g) || [];
        }
        e2.exports = t2, t2.eastAsianWidth = function(e3) {
          var t3 = e3.charCodeAt(0), n3 = 2 == e3.length ? e3.charCodeAt(1) : 0, r2 = t3;
          return 55296 <= t3 && t3 <= 56319 && 56320 <= n3 && n3 <= 57343 && (r2 = (t3 &= 1023) << 10 | (n3 &= 1023), r2 += 65536), 12288 == r2 || 65281 <= r2 && r2 <= 65376 || 65504 <= r2 && r2 <= 65510 ? "F" : 8361 == r2 || 65377 <= r2 && r2 <= 65470 || 65474 <= r2 && r2 <= 65479 || 65482 <= r2 && r2 <= 65487 || 65490 <= r2 && r2 <= 65495 || 65498 <= r2 && r2 <= 65500 || 65512 <= r2 && r2 <= 65518 ? "H" : 4352 <= r2 && r2 <= 4447 || 4515 <= r2 && r2 <= 4519 || 4602 <= r2 && r2 <= 4607 || 9001 <= r2 && r2 <= 9002 || 11904 <= r2 && r2 <= 11929 || 11931 <= r2 && r2 <= 12019 || 12032 <= r2 && r2 <= 12245 || 12272 <= r2 && r2 <= 12283 || 12289 <= r2 && r2 <= 12350 || 12353 <= r2 && r2 <= 12438 || 12441 <= r2 && r2 <= 12543 || 12549 <= r2 && r2 <= 12589 || 12593 <= r2 && r2 <= 12686 || 12688 <= r2 && r2 <= 12730 || 12736 <= r2 && r2 <= 12771 || 12784 <= r2 && r2 <= 12830 || 12832 <= r2 && r2 <= 12871 || 12880 <= r2 && r2 <= 13054 || 13056 <= r2 && r2 <= 19903 || 19968 <= r2 && r2 <= 42124 || 42128 <= r2 && r2 <= 42182 || 43360 <= r2 && r2 <= 43388 || 44032 <= r2 && r2 <= 55203 || 55216 <= r2 && r2 <= 55238 || 55243 <= r2 && r2 <= 55291 || 63744 <= r2 && r2 <= 64255 || 65040 <= r2 && r2 <= 65049 || 65072 <= r2 && r2 <= 65106 || 65108 <= r2 && r2 <= 65126 || 65128 <= r2 && r2 <= 65131 || 110592 <= r2 && r2 <= 110593 || 127488 <= r2 && r2 <= 127490 || 127504 <= r2 && r2 <= 127546 || 127552 <= r2 && r2 <= 127560 || 127568 <= r2 && r2 <= 127569 || 131072 <= r2 && r2 <= 194367 || 177984 <= r2 && r2 <= 196605 || 196608 <= r2 && r2 <= 262141 ? "W" : 32 <= r2 && r2 <= 126 || 162 <= r2 && r2 <= 163 || 165 <= r2 && r2 <= 166 || 172 == r2 || 175 == r2 || 10214 <= r2 && r2 <= 10221 || 10629 <= r2 && r2 <= 10630 ? "Na" : 161 == r2 || 164 == r2 || 167 <= r2 && r2 <= 168 || 170 == r2 || 173 <= r2 && r2 <= 174 || 176 <= r2 && r2 <= 180 || 182 <= r2 && r2 <= 186 || 188 <= r2 && r2 <= 191 || 198 == r2 || 208 == r2 || 215 <= r2 && r2 <= 216 || 222 <= r2 && r2 <= 225 || 230 == r2 || 232 <= r2 && r2 <= 234 || 236 <= r2 && r2 <= 237 || 240 == r2 || 242 <= r2 && r2 <= 243 || 247 <= r2 && r2 <= 250 || 252 == r2 || 254 == r2 || 257 == r2 || 273 == r2 || 275 == r2 || 283 == r2 || 294 <= r2 && r2 <= 295 || 299 == r2 || 305 <= r2 && r2 <= 307 || 312 == r2 || 319 <= r2 && r2 <= 322 || 324 == r2 || 328 <= r2 && r2 <= 331 || 333 == r2 || 338 <= r2 && r2 <= 339 || 358 <= r2 && r2 <= 359 || 363 == r2 || 462 == r2 || 464 == r2 || 466 == r2 || 468 == r2 || 470 == r2 || 472 == r2 || 474 == r2 || 476 == r2 || 593 == r2 || 609 == r2 || 708 == r2 || 711 == r2 || 713 <= r2 && r2 <= 715 || 717 == r2 || 720 == r2 || 728 <= r2 && r2 <= 731 || 733 == r2 || 735 == r2 || 768 <= r2 && r2 <= 879 || 913 <= r2 && r2 <= 929 || 931 <= r2 && r2 <= 937 || 945 <= r2 && r2 <= 961 || 963 <= r2 && r2 <= 969 || 1025 == r2 || 1040 <= r2 && r2 <= 1103 || 1105 == r2 || 8208 == r2 || 8211 <= r2 && r2 <= 8214 || 8216 <= r2 && r2 <= 8217 || 8220 <= r2 && r2 <= 8221 || 8224 <= r2 && r2 <= 8226 || 8228 <= r2 && r2 <= 8231 || 8240 == r2 || 8242 <= r2 && r2 <= 8243 || 8245 == r2 || 8251 == r2 || 8254 == r2 || 8308 == r2 || 8319 == r2 || 8321 <= r2 && r2 <= 8324 || 8364 == r2 || 8451 == r2 || 8453 == r2 || 8457 == r2 || 8467 == r2 || 8470 == r2 || 8481 <= r2 && r2 <= 8482 || 8486 == r2 || 8491 == r2 || 8531 <= r2 && r2 <= 8532 || 8539 <= r2 && r2 <= 8542 || 8544 <= r2 && r2 <= 8555 || 8560 <= r2 && r2 <= 8569 || 8585 == r2 || 8592 <= r2 && r2 <= 8601 || 8632 <= r2 && r2 <= 8633 || 8658 == r2 || 8660 == r2 || 8679 == r2 || 8704 == r2 || 8706 <= r2 && r2 <= 8707 || 8711 <= r2 && r2 <= 8712 || 8715 == r2 || 8719 == r2 || 8721 == r2 || 8725 == r2 || 8730 == r2 || 8733 <= r2 && r2 <= 8736 || 8739 == r2 || 8741 == r2 || 8743 <= r2 && r2 <= 8748 || 8750 == r2 || 8756 <= r2 && r2 <= 8759 || 8764 <= r2 && r2 <= 8765 || 8776 == r2 || 8780 == r2 || 8786 == r2 || 8800 <= r2 && r2 <= 8801 || 8804 <= r2 && r2 <= 8807 || 8810 <= r2 && r2 <= 8811 || 8814 <= r2 && r2 <= 8815 || 8834 <= r2 && r2 <= 8835 || 8838 <= r2 && r2 <= 8839 || 8853 == r2 || 8857 == r2 || 8869 == r2 || 8895 == r2 || 8978 == r2 || 9312 <= r2 && r2 <= 9449 || 9451 <= r2 && r2 <= 9547 || 9552 <= r2 && r2 <= 9587 || 9600 <= r2 && r2 <= 9615 || 9618 <= r2 && r2 <= 9621 || 9632 <= r2 && r2 <= 9633 || 9635 <= r2 && r2 <= 9641 || 9650 <= r2 && r2 <= 9651 || 9654 <= r2 && r2 <= 9655 || 9660 <= r2 && r2 <= 9661 || 9664 <= r2 && r2 <= 9665 || 9670 <= r2 && r2 <= 9672 || 9675 == r2 || 9678 <= r2 && r2 <= 9681 || 9698 <= r2 && r2 <= 9701 || 9711 == r2 || 9733 <= r2 && r2 <= 9734 || 9737 == r2 || 9742 <= r2 && r2 <= 9743 || 9748 <= r2 && r2 <= 9749 || 9756 == r2 || 9758 == r2 || 9792 == r2 || 9794 == r2 || 9824 <= r2 && r2 <= 9825 || 9827 <= r2 && r2 <= 9829 || 9831 <= r2 && r2 <= 9834 || 9836 <= r2 && r2 <= 9837 || 9839 == r2 || 9886 <= r2 && r2 <= 9887 || 9918 <= r2 && r2 <= 9919 || 9924 <= r2 && r2 <= 9933 || 9935 <= r2 && r2 <= 9953 || 9955 == r2 || 9960 <= r2 && r2 <= 9983 || 10045 == r2 || 10071 == r2 || 10102 <= r2 && r2 <= 10111 || 11093 <= r2 && r2 <= 11097 || 12872 <= r2 && r2 <= 12879 || 57344 <= r2 && r2 <= 63743 || 65024 <= r2 && r2 <= 65039 || 65533 == r2 || 127232 <= r2 && r2 <= 127242 || 127248 <= r2 && r2 <= 127277 || 127280 <= r2 && r2 <= 127337 || 127344 <= r2 && r2 <= 127386 || 917760 <= r2 && r2 <= 917999 || 983040 <= r2 && r2 <= 1048573 || 1048576 <= r2 && r2 <= 1114109 ? "A" : "N";
        }, t2.characterLength = function(e3) {
          var t3 = this.eastAsianWidth(e3);
          return "F" == t3 || "W" == t3 || "A" == t3 ? 2 : 1;
        }, t2.length = function(e3) {
          for (var t3 = n2(e3), r2 = 0, i = 0; i < t3.length; i++) r2 += this.characterLength(t3[i]);
          return r2;
        }, t2.slice = function(e3, r2, i) {
          textLen = t2.length(e3), i = i || 1, (r2 = r2 || 0) < 0 && (r2 = textLen + r2), i < 0 && (i = textLen + i);
          for (var s = "", a = 0, o = n2(e3), l = 0; l < o.length; l++) {
            var c = o[l], u = t2.length(c);
            if (a >= r2 - (2 == u ? 1 : 0)) {
              if (!(a + u <= i)) break;
              s += c;
            }
            a += u;
          }
          return s;
        };
      }, 3150: (e2) => {
        "use strict";
        var t2 = /[|\\{}()[\]^$+*?.]/g;
        e2.exports = function(e3) {
          if ("string" != typeof e3) throw new TypeError("Expected a string");
          return e3.replace(t2, "\\$&");
        };
      }, 1272: (e2, t2, n2) => {
        "use strict";
        e2.exports = n2(8487);
      }, 645: (e2, t2) => {
        t2.read = function(e3, t3, n2, r2, i) {
          var s, a, o = 8 * i - r2 - 1, l = (1 << o) - 1, c = l >> 1, u = -7, p = n2 ? i - 1 : 0, h = n2 ? -1 : 1, d = e3[t3 + p];
          for (p += h, s = d & (1 << -u) - 1, d >>= -u, u += o; u > 0; s = 256 * s + e3[t3 + p], p += h, u -= 8) ;
          for (a = s & (1 << -u) - 1, s >>= -u, u += r2; u > 0; a = 256 * a + e3[t3 + p], p += h, u -= 8) ;
          if (0 === s) s = 1 - c;
          else {
            if (s === l) return a ? NaN : 1 / 0 * (d ? -1 : 1);
            a += Math.pow(2, r2), s -= c;
          }
          return (d ? -1 : 1) * a * Math.pow(2, s - r2);
        }, t2.write = function(e3, t3, n2, r2, i, s) {
          var a, o, l, c = 8 * s - i - 1, u = (1 << c) - 1, p = u >> 1, h = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d = r2 ? 0 : s - 1, f = r2 ? 1 : -1, y = t3 < 0 || 0 === t3 && 1 / t3 < 0 ? 1 : 0;
          for (t3 = Math.abs(t3), isNaN(t3) || t3 === 1 / 0 ? (o = isNaN(t3) ? 1 : 0, a = u) : (a = Math.floor(Math.log(t3) / Math.LN2), t3 * (l = Math.pow(2, -a)) < 1 && (a--, l *= 2), (t3 += a + p >= 1 ? h / l : h * Math.pow(2, 1 - p)) * l >= 2 && (a++, l /= 2), a + p >= u ? (o = 0, a = u) : a + p >= 1 ? (o = (t3 * l - 1) * Math.pow(2, i), a += p) : (o = t3 * Math.pow(2, p - 1) * Math.pow(2, i), a = 0)); i >= 8; e3[n2 + d] = 255 & o, d += f, o /= 256, i -= 8) ;
          for (a = a << i | o, c += i; c > 0; e3[n2 + d] = 255 & a, d += f, a /= 256, c -= 8) ;
          e3[n2 + d - f] |= 128 * y;
        };
      }, 6188: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g, t2.matchToToken = function(e3) {
          var t3 = { type: "invalid", value: e3[0], closed: void 0 };
          return e3[1] ? (t3.type = "string", t3.closed = !(!e3[3] && !e3[4])) : e3[5] ? t3.type = "comment" : e3[6] ? (t3.type = "comment", t3.closed = !!e3[7]) : e3[8] ? t3.type = "regex" : e3[9] ? t3.type = "number" : e3[10] ? t3.type = "name" : e3[11] ? t3.type = "punctuator" : e3[12] && (t3.type = "whitespace"), t3;
        };
      }, 3312: (e2, t2, n2) => {
        "use strict";
        var r2 = n2(8764).lW;
        const i = {}, s = i.hasOwnProperty, a = (e3, t3) => {
          for (const n3 in e3) s.call(e3, n3) && t3(n3, e3[n3]);
        }, o = i.toString, l = Array.isArray, c = r2.isBuffer, u = { '"': '\\"', "'": "\\'", "\\": "\\\\", "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "	": "\\t" }, p = /["'\\\b\f\n\r\t]/, h = /[0-9]/, d = /[ !#-&\(-\[\]-~]/, f = (e3, t3) => {
          const n3 = () => {
            E = b, ++t3.indentLevel, b = t3.indent.repeat(t3.indentLevel);
          }, r3 = { escapeEverything: false, minimal: false, isScriptContext: false, quotes: "single", wrap: false, es6: false, json: false, compact: true, lowercaseHex: false, numbers: "decimal", indent: "	", indentLevel: 0, __inline1__: false, __inline2__: false }, i2 = t3 && t3.json;
          var s2, y;
          i2 && (r3.quotes = "double", r3.wrap = true), s2 = r3, t3 = (y = t3) ? (a(y, (e4, t4) => {
            s2[e4] = t4;
          }), s2) : s2, "single" != t3.quotes && "double" != t3.quotes && "backtick" != t3.quotes && (t3.quotes = "single");
          const m = "double" == t3.quotes ? '"' : "backtick" == t3.quotes ? "`" : "'", T = t3.compact, g = t3.lowercaseHex;
          let b = t3.indent.repeat(t3.indentLevel), E = "";
          const S = t3.__inline1__, P = t3.__inline2__, x = T ? "" : "\n";
          let D, A = true;
          const v = "binary" == t3.numbers, C = "octal" == t3.numbers, w = "decimal" == t3.numbers, O = "hexadecimal" == t3.numbers;
          if (i2 && e3 && "function" == typeof e3.toJSON && (e3 = e3.toJSON()), "string" != typeof (I = e3) && "[object String]" != o.call(I)) {
            if (((e4) => "[object Map]" == o.call(e4))(e3)) return 0 == e3.size ? "new Map()" : (T || (t3.__inline1__ = true, t3.__inline2__ = false), "new Map(" + f(Array.from(e3), t3) + ")");
            if (((e4) => "[object Set]" == o.call(e4))(e3)) return 0 == e3.size ? "new Set()" : "new Set(" + f(Array.from(e3), t3) + ")";
            if (c(e3)) return 0 == e3.length ? "Buffer.from([])" : "Buffer.from(" + f(Array.from(e3), t3) + ")";
            if (l(e3)) return D = [], t3.wrap = true, S && (t3.__inline1__ = false, t3.__inline2__ = true), P || n3(), ((e4, t4) => {
              const n4 = e4.length;
              let r4 = -1;
              for (; ++r4 < n4; ) t4(e4[r4]);
            })(e3, (e4) => {
              A = false, P && (t3.__inline2__ = false), D.push((T || P ? "" : b) + f(e4, t3));
            }), A ? "[]" : P ? "[" + D.join(", ") + "]" : "[" + x + D.join("," + x) + x + (T ? "" : E) + "]";
            if (!((e4) => "number" == typeof e4 || "[object Number]" == o.call(e4))(e3)) return ((e4) => "[object Object]" == o.call(e4))(e3) ? (D = [], t3.wrap = true, n3(), a(e3, (e4, n4) => {
              A = false, D.push((T ? "" : b) + f(e4, t3) + ":" + (T ? "" : " ") + f(n4, t3));
            }), A ? "{}" : "{" + x + D.join("," + x) + x + (T ? "" : E) + "}") : i2 ? JSON.stringify(e3) || "null" : String(e3);
            if (i2) return JSON.stringify(e3);
            if (w) return String(e3);
            if (O) {
              let t4 = e3.toString(16);
              return g || (t4 = t4.toUpperCase()), "0x" + t4;
            }
            if (v) return "0b" + e3.toString(2);
            if (C) return "0o" + e3.toString(8);
          }
          var I;
          const N = e3;
          let F = -1;
          const k = N.length;
          for (D = ""; ++F < k; ) {
            const e4 = N.charAt(F);
            if (t3.es6) {
              const e5 = N.charCodeAt(F);
              if (e5 >= 55296 && e5 <= 56319 && k > F + 1) {
                const t4 = N.charCodeAt(F + 1);
                if (t4 >= 56320 && t4 <= 57343) {
                  let n5 = (1024 * (e5 - 55296) + t4 - 56320 + 65536).toString(16);
                  g || (n5 = n5.toUpperCase()), D += "\\u{" + n5 + "}", ++F;
                  continue;
                }
              }
            }
            if (!t3.escapeEverything) {
              if (d.test(e4)) {
                D += e4;
                continue;
              }
              if ('"' == e4) {
                D += m == e4 ? '\\"' : e4;
                continue;
              }
              if ("`" == e4) {
                D += m == e4 ? "\\`" : e4;
                continue;
              }
              if ("'" == e4) {
                D += m == e4 ? "\\'" : e4;
                continue;
              }
            }
            if ("\0" == e4 && !i2 && !h.test(N.charAt(F + 1))) {
              D += "\\0";
              continue;
            }
            if (p.test(e4)) {
              D += u[e4];
              continue;
            }
            const n4 = e4.charCodeAt(0);
            if (t3.minimal && 8232 != n4 && 8233 != n4) {
              D += e4;
              continue;
            }
            let r4 = n4.toString(16);
            g || (r4 = r4.toUpperCase());
            const s3 = r4.length > 2 || i2, a2 = "\\" + (s3 ? "u" : "x") + ("0000" + r4).slice(s3 ? -4 : -2);
            D += a2;
          }
          return t3.wrap && (D = m + D + m), "`" == m && (D = D.replace(/\$\{/g, "\\${")), t3.isScriptContext ? D.replace(/<\/(script|style)/gi, "<\\/$1").replace(/<!--/g, i2 ? "\\u003C!--" : "\\x3C!--") : D;
        };
        f.version = "2.5.1", e2.exports = f;
      }, 7824: (e2) => {
        var t2 = 1e3, n2 = 60 * t2, r2 = 60 * n2, i = 24 * r2;
        function s(e3, t3, n3, r3) {
          var i2 = t3 >= 1.5 * n3;
          return Math.round(e3 / n3) + " " + r3 + (i2 ? "s" : "");
        }
        e2.exports = function(e3, a) {
          a = a || {};
          var o, l, c = typeof e3;
          if ("string" === c && e3.length > 0) return function(e4) {
            if (!((e4 = String(e4)).length > 100)) {
              var s2 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e4);
              if (s2) {
                var a2 = parseFloat(s2[1]);
                switch ((s2[2] || "ms").toLowerCase()) {
                  case "years":
                  case "year":
                  case "yrs":
                  case "yr":
                  case "y":
                    return 315576e5 * a2;
                  case "weeks":
                  case "week":
                  case "w":
                    return 6048e5 * a2;
                  case "days":
                  case "day":
                  case "d":
                    return a2 * i;
                  case "hours":
                  case "hour":
                  case "hrs":
                  case "hr":
                  case "h":
                    return a2 * r2;
                  case "minutes":
                  case "minute":
                  case "mins":
                  case "min":
                  case "m":
                    return a2 * n2;
                  case "seconds":
                  case "second":
                  case "secs":
                  case "sec":
                  case "s":
                    return a2 * t2;
                  case "milliseconds":
                  case "millisecond":
                  case "msecs":
                  case "msec":
                  case "ms":
                    return a2;
                  default:
                    return;
                }
              }
            }
          }(e3);
          if ("number" === c && isFinite(e3)) return a.long ? (o = e3, (l = Math.abs(o)) >= i ? s(o, l, i, "day") : l >= r2 ? s(o, l, r2, "hour") : l >= n2 ? s(o, l, n2, "minute") : l >= t2 ? s(o, l, t2, "second") : o + " ms") : function(e4) {
            var s2 = Math.abs(e4);
            return s2 >= i ? Math.round(e4 / i) + "d" : s2 >= r2 ? Math.round(e4 / r2) + "h" : s2 >= n2 ? Math.round(e4 / n2) + "m" : s2 >= t2 ? Math.round(e4 / t2) + "s" : e4 + "ms";
          }(e3);
          throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(e3));
        };
      }, 4155: (e2) => {
        var t2, n2, r2 = e2.exports = {};
        function i() {
          throw new Error("setTimeout has not been defined");
        }
        function s() {
          throw new Error("clearTimeout has not been defined");
        }
        function a(e3) {
          if (t2 === setTimeout) return setTimeout(e3, 0);
          if ((t2 === i || !t2) && setTimeout) return t2 = setTimeout, setTimeout(e3, 0);
          try {
            return t2(e3, 0);
          } catch (n3) {
            try {
              return t2.call(null, e3, 0);
            } catch (n4) {
              return t2.call(this, e3, 0);
            }
          }
        }
        !function() {
          try {
            t2 = "function" == typeof setTimeout ? setTimeout : i;
          } catch (e3) {
            t2 = i;
          }
          try {
            n2 = "function" == typeof clearTimeout ? clearTimeout : s;
          } catch (e3) {
            n2 = s;
          }
        }();
        var o, l = [], c = false, u = -1;
        function p() {
          c && o && (c = false, o.length ? l = o.concat(l) : u = -1, l.length && h());
        }
        function h() {
          if (!c) {
            var e3 = a(p);
            c = true;
            for (var t3 = l.length; t3; ) {
              for (o = l, l = []; ++u < t3; ) o && o[u].run();
              u = -1, t3 = l.length;
            }
            o = null, c = false, function(e4) {
              if (n2 === clearTimeout) return clearTimeout(e4);
              if ((n2 === s || !n2) && clearTimeout) return n2 = clearTimeout, clearTimeout(e4);
              try {
                return n2(e4);
              } catch (t4) {
                try {
                  return n2.call(null, e4);
                } catch (t5) {
                  return n2.call(this, e4);
                }
              }
            }(e3);
          }
        }
        function d(e3, t3) {
          this.fun = e3, this.array = t3;
        }
        function f() {
        }
        r2.nextTick = function(e3) {
          var t3 = new Array(arguments.length - 1);
          if (arguments.length > 1) for (var n3 = 1; n3 < arguments.length; n3++) t3[n3 - 1] = arguments[n3];
          l.push(new d(e3, t3)), 1 !== l.length || c || a(h);
        }, d.prototype.run = function() {
          this.fun.apply(null, this.array);
        }, r2.title = "browser", r2.browser = true, r2.env = {}, r2.argv = [], r2.version = "", r2.versions = {}, r2.on = f, r2.addListener = f, r2.once = f, r2.off = f, r2.removeListener = f, r2.removeAllListeners = f, r2.emit = f, r2.prependListener = f, r2.prependOnceListener = f, r2.listeners = function(e3) {
          return [];
        }, r2.binding = function(e3) {
          throw new Error("process.binding is not supported");
        }, r2.cwd = function() {
          return "/";
        }, r2.chdir = function(e3) {
          throw new Error("process.chdir is not supported");
        }, r2.umask = function() {
          return 0;
        };
      }, 8555: (e2) => {
        "use strict";
        e2.exports = { stdout: false, stderr: false };
      }, 3164: (e2) => {
        "use strict";
        let t2 = null;
        function n2(e3) {
          if (null !== t2 && (t2.property, 1)) {
            const e4 = t2;
            return t2 = n2.prototype = null, e4;
          }
          return t2 = n2.prototype = null == e3 ? /* @__PURE__ */ Object.create(null) : e3, new n2();
        }
        n2(), e2.exports = function(e3) {
          return n2(e3);
        };
      }, 737: (e2) => {
        (e2.exports = function e3(t2, n2) {
          var r2;
          if (null != t2) return n2 = (n2 || "").replace(/[^&"<>\']/g, ""), r2 = `([&"<>'])`.replace(new RegExp("[" + n2 + "]", "g"), ""), t2.replace(new RegExp(r2, "g"), function(t3, n3) {
            return e3.map[n3];
          });
        }).map = { ">": "&gt;", "<": "&lt;", "'": "&apos;", '"': "&quot;", "&": "&amp;" };
      }, 4704: (e2, t2, n2) => {
        "use strict";
        var r2 = n2(4155);
        Object.defineProperty(t2, "__esModule", { value: true }), t2.codeFrameColumns = u, t2.default = function(e3, t3, n3, i2 = {}) {
          if (!l) {
            l = true;
            const e4 = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
            r2.emitWarning ? r2.emitWarning(e4, "DeprecationWarning") : (new Error(e4).name = "DeprecationWarning", console.warn(new Error(e4)));
          }
          return u(e3, { start: { column: n3 = Math.max(n3, 0), line: t3 } }, i2);
        };
        var i = n2(8530), s = function(e3, t3) {
          if (null === e3 || "object" != typeof e3 && "function" != typeof e3) return { default: e3 };
          var n3 = a(true);
          if (n3 && n3.has(e3)) return n3.get(e3);
          var r3 = {}, i2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var s2 in e3) if ("default" !== s2 && Object.prototype.hasOwnProperty.call(e3, s2)) {
            var o2 = i2 ? Object.getOwnPropertyDescriptor(e3, s2) : null;
            o2 && (o2.get || o2.set) ? Object.defineProperty(r3, s2, o2) : r3[s2] = e3[s2];
          }
          return r3.default = e3, n3 && n3.set(e3, r3), r3;
        }(n2(2589));
        function a(e3) {
          if ("function" != typeof WeakMap) return null;
          var t3 = /* @__PURE__ */ new WeakMap(), n3 = /* @__PURE__ */ new WeakMap();
          return (a = function(e4) {
            return e4 ? n3 : t3;
          })(e3);
        }
        let o, l = false;
        const c = /\r\n|[\n\r\u2028\u2029]/;
        function u(e3, t3, n3 = {}) {
          const r3 = (n3.highlightCode || n3.forceColor) && (0, i.shouldHighlight)(n3), a2 = n3.forceColor ? (null != o || (o = new s.default.constructor({ enabled: true, level: 1 })), o) : s.default, l2 = function(e4) {
            return { gutter: e4.grey, marker: e4.red.bold, message: e4.red.bold };
          }(a2), u2 = (e4, t4) => r3 ? e4(t4) : t4, p = e3.split(c), { start: h, end: d, markerLines: f } = function(e4, t4, n4) {
            const r4 = Object.assign({ column: 0, line: -1 }, e4.start), i2 = Object.assign({}, r4, e4.end), { linesAbove: s2 = 2, linesBelow: a3 = 3 } = n4 || {}, o2 = r4.line, l3 = r4.column, c2 = i2.line, u3 = i2.column;
            let p2 = Math.max(o2 - (s2 + 1), 0), h2 = Math.min(t4.length, c2 + a3);
            -1 === o2 && (p2 = 0), -1 === c2 && (h2 = t4.length);
            const d2 = c2 - o2, f2 = {};
            if (d2) for (let e5 = 0; e5 <= d2; e5++) {
              const n5 = e5 + o2;
              if (l3) if (0 === e5) {
                const e6 = t4[n5 - 1].length;
                f2[n5] = [l3, e6 - l3 + 1];
              } else if (e5 === d2) f2[n5] = [0, u3];
              else {
                const r5 = t4[n5 - e5].length;
                f2[n5] = [0, r5];
              }
              else f2[n5] = true;
            }
            else f2[o2] = l3 === u3 ? !l3 || [l3, 0] : [l3, u3 - l3];
            return { start: p2, end: h2, markerLines: f2 };
          }(t3, p, n3), y = t3.start && "number" == typeof t3.start.column, m = String(d).length;
          let T = (r3 ? (0, i.default)(e3, n3) : e3).split(c, d).slice(h, d).map((e4, t4) => {
            const r4 = h + 1 + t4, i2 = ` ${` ${r4}`.slice(-m)} |`, s2 = f[r4], a3 = !f[r4 + 1];
            if (s2) {
              let t5 = "";
              if (Array.isArray(s2)) {
                const r5 = e4.slice(0, Math.max(s2[0] - 1, 0)).replace(/[^\t]/g, " "), o2 = s2[1] || 1;
                t5 = ["\n ", u2(l2.gutter, i2.replace(/\d/g, " ")), " ", r5, u2(l2.marker, "^").repeat(o2)].join(""), a3 && n3.message && (t5 += " " + u2(l2.message, n3.message));
              }
              return [u2(l2.marker, ">"), u2(l2.gutter, i2), e4.length > 0 ? ` ${e4}` : "", t5].join("");
            }
            return ` ${u2(l2.gutter, i2)}${e4.length > 0 ? ` ${e4}` : ""}`;
          }).join("\n");
          return n3.message && !y && (T = `${" ".repeat(m + 1)}${n3.message}
${T}`), r3 ? a2.reset(T) : T;
        }
      }, 8726: (e2, t2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0, t2.default = class {
          constructor(e3) {
            this._map = null, this._buf = "", this._str = "", this._appendCount = 0, this._last = 0, this._queue = [], this._queueCursor = 0, this._canMarkIdName = true, this._position = { line: 1, column: 0 }, this._sourcePosition = { identifierName: void 0, identifierNamePos: void 0, line: void 0, column: void 0, filename: void 0 }, this._map = e3, this._allocQueue();
          }
          _allocQueue() {
            const e3 = this._queue;
            for (let t3 = 0; t3 < 16; t3++) e3.push({ char: 0, repeat: 1, line: void 0, column: void 0, identifierName: void 0, identifierNamePos: void 0, filename: "" });
          }
          _pushQueue(e3, t3, n2, r2, i) {
            const s = this._queueCursor;
            s === this._queue.length && this._allocQueue();
            const a = this._queue[s];
            a.char = e3, a.repeat = t3, a.line = n2, a.column = r2, a.filename = i, this._queueCursor++;
          }
          _popQueue() {
            if (0 === this._queueCursor) throw new Error("Cannot pop from empty queue");
            return this._queue[--this._queueCursor];
          }
          get() {
            this._flush();
            const e3 = this._map, t3 = { code: (this._buf + this._str).trimRight(), decodedMap: null == e3 ? void 0 : e3.getDecoded(), get __mergedMap() {
              return this.map;
            }, get map() {
              const n2 = e3 ? e3.get() : null;
              return t3.map = n2, n2;
            }, set map(e4) {
              Object.defineProperty(t3, "map", { value: e4, writable: true });
            }, get rawMappings() {
              const n2 = null == e3 ? void 0 : e3.getRawMappings();
              return t3.rawMappings = n2, n2;
            }, set rawMappings(e4) {
              Object.defineProperty(t3, "rawMappings", { value: e4, writable: true });
            } };
            return t3;
          }
          append(e3, t3) {
            this._flush(), this._append(e3, this._sourcePosition, t3);
          }
          appendChar(e3) {
            this._flush(), this._appendChar(e3, 1, this._sourcePosition);
          }
          queue(e3) {
            if (10 === e3) for (; 0 !== this._queueCursor; ) {
              const e4 = this._queue[this._queueCursor - 1].char;
              if (32 !== e4 && 9 !== e4) break;
              this._queueCursor--;
            }
            const t3 = this._sourcePosition;
            this._pushQueue(e3, 1, t3.line, t3.column, t3.filename);
          }
          queueIndentation(e3, t3) {
            this._pushQueue(e3, t3, void 0, void 0, void 0);
          }
          _flush() {
            const e3 = this._queueCursor, t3 = this._queue;
            for (let n2 = 0; n2 < e3; n2++) {
              const e4 = t3[n2];
              this._appendChar(e4.char, e4.repeat, e4);
            }
            this._queueCursor = 0;
          }
          _appendChar(e3, t3, n2) {
            this._last = e3, this._str += t3 > 1 ? String.fromCharCode(e3).repeat(t3) : String.fromCharCode(e3), 10 !== e3 ? (this._mark(n2.line, n2.column, n2.identifierName, n2.identifierNamePos, n2.filename), this._position.column += t3) : (this._position.line++, this._position.column = 0), this._canMarkIdName && (n2.identifierName = void 0, n2.identifierNamePos = void 0);
          }
          _append(e3, t3, n2) {
            const r2 = e3.length, i = this._position;
            if (this._last = e3.charCodeAt(r2 - 1), ++this._appendCount > 4096 ? (this._str, this._buf += this._str, this._str = e3, this._appendCount = 0) : this._str += e3, !n2 && !this._map) return void (i.column += r2);
            const { column: s, identifierName: a, identifierNamePos: o, filename: l } = t3;
            let c = t3.line;
            null == a && null == o || !this._canMarkIdName || (t3.identifierName = void 0, t3.identifierNamePos = void 0);
            let u = e3.indexOf("\n"), p = 0;
            for (0 !== u && this._mark(c, s, a, o, l); -1 !== u; ) i.line++, i.column = 0, p = u + 1, p < r2 && void 0 !== c && this._mark(++c, 0, null, null, l), u = e3.indexOf("\n", p);
            i.column += r2 - p;
          }
          _mark(e3, t3, n2, r2, i) {
            var s;
            null == (s = this._map) || s.mark(this._position, e3, t3, n2, r2, i);
          }
          removeTrailingNewline() {
            const e3 = this._queueCursor;
            0 !== e3 && 10 === this._queue[e3 - 1].char && this._queueCursor--;
          }
          removeLastSemicolon() {
            const e3 = this._queueCursor;
            0 !== e3 && 59 === this._queue[e3 - 1].char && this._queueCursor--;
          }
          getLastChar() {
            const e3 = this._queueCursor;
            return 0 !== e3 ? this._queue[e3 - 1].char : this._last;
          }
          getNewlineCount() {
            const e3 = this._queueCursor;
            let t3 = 0;
            if (0 === e3) return 10 === this._last ? 1 : 0;
            for (let n2 = e3 - 1; n2 >= 0 && 10 === this._queue[n2].char; n2--) t3++;
            return t3 === e3 && 10 === this._last ? t3 + 1 : t3;
          }
          endsWithCharAndNewline() {
            const e3 = this._queue, t3 = this._queueCursor;
            if (0 !== t3) {
              if (10 !== e3[t3 - 1].char) return;
              return t3 > 1 ? e3[t3 - 2].char : this._last;
            }
          }
          hasContent() {
            return 0 !== this._queueCursor || !!this._last;
          }
          exactSource(e3, t3) {
            if (!this._map) return void t3();
            this.source("start", e3);
            const n2 = e3.identifierName, r2 = this._sourcePosition;
            n2 && (this._canMarkIdName = false, r2.identifierName = n2), t3(), n2 && (this._canMarkIdName = true, r2.identifierName = void 0, r2.identifierNamePos = void 0), this.source("end", e3);
          }
          source(e3, t3) {
            this._map && this._normalizePosition(e3, t3, 0);
          }
          sourceWithOffset(e3, t3, n2) {
            this._map && this._normalizePosition(e3, t3, n2);
          }
          withSource(e3, t3, n2) {
            this._map && this.source(e3, t3), n2();
          }
          _normalizePosition(e3, t3, n2) {
            const r2 = t3[e3], i = this._sourcePosition;
            r2 && (i.line = r2.line, i.column = Math.max(r2.column + n2, 0), i.filename = t3.filename);
          }
          getCurrentColumn() {
            const e3 = this._queue, t3 = this._queueCursor;
            let n2 = -1, r2 = 0;
            for (let i = 0; i < t3; i++) {
              const t4 = e3[i];
              10 === t4.char && (n2 = r2), r2 += t4.repeat;
            }
            return -1 === n2 ? this._position.column + r2 : r2 - 1 - n2;
          }
          getCurrentLine() {
            let e3 = 0;
            const t3 = this._queue;
            for (let n2 = 0; n2 < this._queueCursor; n2++) 10 === t3[n2].char && e3++;
            return this._position.line + e3;
          }
        };
      }, 9230: (e2, t2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.BlockStatement = function(e3) {
          var t3;
          this.tokenChar(123);
          const n3 = null == (t3 = e3.directives) ? void 0 : t3.length;
          if (n3) {
            var r3;
            const t4 = e3.body.length ? 2 : 1;
            this.printSequence(e3.directives, e3, { indent: true, trailingCommentsLineOffset: t4 }), null != (r3 = e3.directives[n3 - 1].trailingComments) && r3.length || this.newline(t4);
          }
          this.printSequence(e3.body, e3, { indent: true }), this.rightBrace(e3);
        }, t2.Directive = function(e3) {
          this.print(e3.value, e3), this.semicolon();
        }, t2.DirectiveLiteral = function(e3) {
          const t3 = this.getPossibleRaw(e3);
          if (!this.format.minified && void 0 !== t3) return void this.token(t3);
          const { value: i } = e3;
          if (r2.test(i)) {
            if (n2.test(i)) throw new Error("Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.");
            this.token(`'${i}'`);
          } else this.token(`"${i}"`);
        }, t2.File = function(e3) {
          e3.program && this.print(e3.program.interpreter, e3), this.print(e3.program, e3);
        }, t2.InterpreterDirective = function(e3) {
          this.token(`#!${e3.value}`), this.newline(1, true);
        }, t2.Placeholder = function(e3) {
          this.token("%%"), this.print(e3.name), this.token("%%"), "Statement" === e3.expectedNode && this.semicolon();
        }, t2.Program = function(e3) {
          var t3;
          this.noIndentInnerCommentsHere(), this.printInnerComments();
          const n3 = null == (t3 = e3.directives) ? void 0 : t3.length;
          if (n3) {
            var r3;
            const t4 = e3.body.length ? 2 : 1;
            this.printSequence(e3.directives, e3, { trailingCommentsLineOffset: t4 }), null != (r3 = e3.directives[n3 - 1].trailingComments) && r3.length || this.newline(t4);
          }
          this.printSequence(e3.body, e3);
        };
        const n2 = /(?:^|[^\\])(?:\\\\)*'/, r2 = /(?:^|[^\\])(?:\\\\)*"/;
      }, 695: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.ClassAccessorProperty = function(e3) {
          var t3;
          this.printJoin(e3.decorators, e3);
          const n3 = null == (t3 = e3.key.loc) || null == (t3 = t3.end) ? void 0 : t3.line;
          n3 && this.catchUp(n3), this.tsPrintClassMemberModifiers(e3), this.word("accessor", true), this.space(), e3.computed ? (this.tokenChar(91), this.print(e3.key, e3), this.tokenChar(93)) : (this._variance(e3), this.print(e3.key, e3)), e3.optional && this.tokenChar(63), e3.definite && this.tokenChar(33), this.print(e3.typeAnnotation, e3), e3.value && (this.space(), this.tokenChar(61), this.space(), this.print(e3.value, e3)), this.semicolon();
        }, t2.ClassBody = function(e3) {
          this.tokenChar(123), 0 === e3.body.length ? this.tokenChar(125) : (this.newline(), this.printSequence(e3.body, e3, { indent: true }), this.endsWith(10) || this.newline(), this.rightBrace(e3));
        }, t2.ClassExpression = t2.ClassDeclaration = function(e3, t3) {
          (i(t3) || s(t3)) && this._shouldPrintDecoratorsBeforeExport(t3) || this.printJoin(e3.decorators, e3), e3.declare && (this.word("declare"), this.space()), e3.abstract && (this.word("abstract"), this.space()), this.word("class"), e3.id && (this.space(), this.print(e3.id, e3)), this.print(e3.typeParameters, e3), e3.superClass && (this.space(), this.word("extends"), this.space(), this.print(e3.superClass, e3), this.print(e3.superTypeParameters, e3)), e3.implements && (this.space(), this.word("implements"), this.space(), this.printList(e3.implements, e3)), this.space(), this.print(e3.body, e3);
        }, t2.ClassMethod = function(e3) {
          this._classMethodHead(e3), this.space(), this.print(e3.body, e3);
        }, t2.ClassPrivateMethod = function(e3) {
          this._classMethodHead(e3), this.space(), this.print(e3.body, e3);
        }, t2.ClassPrivateProperty = function(e3) {
          this.printJoin(e3.decorators, e3), e3.static && (this.word("static"), this.space()), this.print(e3.key, e3), this.print(e3.typeAnnotation, e3), e3.value && (this.space(), this.tokenChar(61), this.space(), this.print(e3.value, e3)), this.semicolon();
        }, t2.ClassProperty = function(e3) {
          var t3;
          this.printJoin(e3.decorators, e3);
          const n3 = null == (t3 = e3.key.loc) || null == (t3 = t3.end) ? void 0 : t3.line;
          n3 && this.catchUp(n3), this.tsPrintClassMemberModifiers(e3), e3.computed ? (this.tokenChar(91), this.print(e3.key, e3), this.tokenChar(93)) : (this._variance(e3), this.print(e3.key, e3)), e3.optional && this.tokenChar(63), e3.definite && this.tokenChar(33), this.print(e3.typeAnnotation, e3), e3.value && (this.space(), this.tokenChar(61), this.space(), this.print(e3.value, e3)), this.semicolon();
        }, t2.StaticBlock = function(e3) {
          this.word("static"), this.space(), this.tokenChar(123), 0 === e3.body.length ? this.tokenChar(125) : (this.newline(), this.printSequence(e3.body, e3, { indent: true }), this.rightBrace(e3));
        }, t2._classMethodHead = function(e3) {
          var t3;
          this.printJoin(e3.decorators, e3);
          const n3 = null == (t3 = e3.key.loc) || null == (t3 = t3.end) ? void 0 : t3.line;
          n3 && this.catchUp(n3), this.tsPrintClassMemberModifiers(e3), this._methodHead(e3);
        };
        var r2 = n2(6067);
        const { isExportDefaultDeclaration: i, isExportNamedDeclaration: s } = r2;
      }, 7240: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.LogicalExpression = t2.BinaryExpression = t2.AssignmentExpression = function(e3, t3) {
          const n3 = this.inForStatementInitCounter && "in" === e3.operator && !i.needsParens(e3, t3);
          n3 && this.tokenChar(40), this.print(e3.left, e3), this.space(), "in" === e3.operator || "instanceof" === e3.operator ? this.word(e3.operator) : this.token(e3.operator), this.space(), this.print(e3.right, e3), n3 && this.tokenChar(41);
        }, t2.AssignmentPattern = function(e3) {
          this.print(e3.left, e3), e3.left.optional && this.tokenChar(63), this.print(e3.left.typeAnnotation, e3), this.space(), this.tokenChar(61), this.space(), this.print(e3.right, e3);
        }, t2.AwaitExpression = function(e3) {
          this.word("await"), e3.argument && (this.space(), this.printTerminatorless(e3.argument, e3, false));
        }, t2.BindExpression = function(e3) {
          this.print(e3.object, e3), this.token("::"), this.print(e3.callee, e3);
        }, t2.CallExpression = function(e3) {
          this.print(e3.callee, e3), this.print(e3.typeArguments, e3), this.print(e3.typeParameters, e3), this.tokenChar(40), this.printList(e3.arguments, e3), this.rightParens(e3);
        }, t2.ConditionalExpression = function(e3) {
          this.print(e3.test, e3), this.space(), this.tokenChar(63), this.space(), this.print(e3.consequent, e3), this.space(), this.tokenChar(58), this.space(), this.print(e3.alternate, e3);
        }, t2.Decorator = function(e3) {
          this.tokenChar(64);
          const { expression: t3 } = e3;
          !function(e4) {
            return "ParenthesizedExpression" !== e4.type && !c("CallExpression" === e4.type ? e4.callee : e4);
          }(t3) ? this.print(t3, e3) : (this.tokenChar(40), this.print(t3, e3), this.tokenChar(41)), this.newline();
        }, t2.DoExpression = function(e3) {
          e3.async && (this.word("async", true), this.space()), this.word("do"), this.space(), this.print(e3.body, e3);
        }, t2.EmptyStatement = function() {
          this.semicolon(true);
        }, t2.ExpressionStatement = function(e3) {
          this.print(e3.expression, e3), this.semicolon();
        }, t2.Import = function() {
          this.word("import");
        }, t2.MemberExpression = function(e3) {
          if (this.print(e3.object, e3), !e3.computed && o(e3.property)) throw new TypeError("Got a MemberExpression for MemberExpression property");
          let t3 = e3.computed;
          a(e3.property) && "number" == typeof e3.property.value && (t3 = true), t3 ? (this.tokenChar(91), this.print(e3.property, e3), this.tokenChar(93)) : (this.tokenChar(46), this.print(e3.property, e3));
        }, t2.MetaProperty = function(e3) {
          this.print(e3.meta, e3), this.tokenChar(46), this.print(e3.property, e3);
        }, t2.ModuleExpression = function(e3) {
          this.word("module", true), this.space(), this.tokenChar(123), this.indent();
          const { body: t3 } = e3;
          (t3.body.length || t3.directives.length) && this.newline(), this.print(t3, e3), this.dedent(), this.rightBrace(e3);
        }, t2.NewExpression = function(e3, t3) {
          this.word("new"), this.space(), this.print(e3.callee, e3), (!this.format.minified || 0 !== e3.arguments.length || e3.optional || s(t3, { callee: e3 }) || o(t3) || l(t3)) && (this.print(e3.typeArguments, e3), this.print(e3.typeParameters, e3), e3.optional && this.token("?."), this.tokenChar(40), this.printList(e3.arguments, e3), this.rightParens(e3));
        }, t2.OptionalCallExpression = function(e3) {
          this.print(e3.callee, e3), this.print(e3.typeParameters, e3), e3.optional && this.token("?."), this.print(e3.typeArguments, e3), this.tokenChar(40), this.printList(e3.arguments, e3), this.rightParens(e3);
        }, t2.OptionalMemberExpression = function(e3) {
          let { computed: t3 } = e3;
          const { optional: n3, property: r3 } = e3;
          if (this.print(e3.object, e3), !t3 && o(r3)) throw new TypeError("Got a MemberExpression for MemberExpression property");
          a(r3) && "number" == typeof r3.value && (t3 = true), n3 && this.token("?."), t3 ? (this.tokenChar(91), this.print(r3, e3), this.tokenChar(93)) : (n3 || this.tokenChar(46), this.print(r3, e3));
        }, t2.ParenthesizedExpression = function(e3) {
          this.tokenChar(40), this.print(e3.expression, e3), this.rightParens(e3);
        }, t2.PrivateName = function(e3) {
          this.tokenChar(35), this.print(e3.id, e3);
        }, t2.SequenceExpression = function(e3) {
          this.printList(e3.expressions, e3);
        }, t2.Super = function() {
          this.word("super");
        }, t2.ThisExpression = function() {
          this.word("this");
        }, t2.UnaryExpression = function(e3) {
          const { operator: t3 } = e3;
          "void" === t3 || "delete" === t3 || "typeof" === t3 || "throw" === t3 ? (this.word(t3), this.space()) : this.token(t3), this.print(e3.argument, e3);
        }, t2.UpdateExpression = function(e3) {
          e3.prefix ? (this.token(e3.operator), this.print(e3.argument, e3)) : (this.printTerminatorless(e3.argument, e3, true), this.token(e3.operator));
        }, t2.V8IntrinsicIdentifier = function(e3) {
          this.tokenChar(37), this.word(e3.name);
        }, t2.YieldExpression = function(e3) {
          this.word("yield", true), e3.delegate ? (this.tokenChar(42), e3.argument && (this.space(), this.print(e3.argument, e3))) : e3.argument && (this.space(), this.printTerminatorless(e3.argument, e3, false));
        }, t2._shouldPrintDecoratorsBeforeExport = function(e3) {
          return "boolean" == typeof this.format.decoratorsBeforeExport ? this.format.decoratorsBeforeExport : "number" == typeof e3.start && e3.start === e3.declaration.start;
        };
        var r2 = n2(6067), i = n2(7533);
        const { isCallExpression: s, isLiteral: a, isMemberExpression: o, isNewExpression: l } = r2;
        function c(e3) {
          switch (e3.type) {
            case "Identifier":
              return true;
            case "MemberExpression":
              return !e3.computed && "Identifier" === e3.property.type && c(e3.object);
            default:
              return false;
          }
        }
      }, 4735: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.AnyTypeAnnotation = function() {
          this.word("any");
        }, t2.ArrayTypeAnnotation = function(e3) {
          this.print(e3.elementType, e3, true), this.tokenChar(91), this.tokenChar(93);
        }, t2.BooleanLiteralTypeAnnotation = function(e3) {
          this.word(e3.value ? "true" : "false");
        }, t2.BooleanTypeAnnotation = function() {
          this.word("boolean");
        }, t2.DeclareClass = function(e3, t3) {
          a(t3) || (this.word("declare"), this.space()), this.word("class"), this.space(), this._interfaceish(e3);
        }, t2.DeclareExportAllDeclaration = function(e3) {
          this.word("declare"), this.space(), i.ExportAllDeclaration.call(this, e3);
        }, t2.DeclareExportDeclaration = function(e3) {
          this.word("declare"), this.space(), this.word("export"), this.space(), e3.default && (this.word("default"), this.space()), p.call(this, e3);
        }, t2.DeclareFunction = function(e3, t3) {
          a(t3) || (this.word("declare"), this.space()), this.word("function"), this.space(), this.print(e3.id, e3), this.print(e3.id.typeAnnotation.typeAnnotation, e3), e3.predicate && (this.space(), this.print(e3.predicate, e3)), this.semicolon();
        }, t2.DeclareInterface = function(e3) {
          this.word("declare"), this.space(), this.InterfaceDeclaration(e3);
        }, t2.DeclareModule = function(e3) {
          this.word("declare"), this.space(), this.word("module"), this.space(), this.print(e3.id, e3), this.space(), this.print(e3.body, e3);
        }, t2.DeclareModuleExports = function(e3) {
          this.word("declare"), this.space(), this.word("module"), this.tokenChar(46), this.word("exports"), this.print(e3.typeAnnotation, e3);
        }, t2.DeclareOpaqueType = function(e3, t3) {
          a(t3) || (this.word("declare"), this.space()), this.OpaqueType(e3);
        }, t2.DeclareTypeAlias = function(e3) {
          this.word("declare"), this.space(), this.TypeAlias(e3);
        }, t2.DeclareVariable = function(e3, t3) {
          a(t3) || (this.word("declare"), this.space()), this.word("var"), this.space(), this.print(e3.id, e3), this.print(e3.id.typeAnnotation, e3), this.semicolon();
        }, t2.DeclaredPredicate = function(e3) {
          this.tokenChar(37), this.word("checks"), this.tokenChar(40), this.print(e3.value, e3), this.tokenChar(41);
        }, t2.EmptyTypeAnnotation = function() {
          this.word("empty");
        }, t2.EnumBooleanBody = function(e3) {
          const { explicitType: t3 } = e3;
          l(this, "boolean", t3), c(this, e3);
        }, t2.EnumBooleanMember = function(e3) {
          u(this, e3);
        }, t2.EnumDeclaration = function(e3) {
          const { id: t3, body: n3 } = e3;
          this.word("enum"), this.space(), this.print(t3, e3), this.print(n3, e3);
        }, t2.EnumDefaultedMember = function(e3) {
          const { id: t3 } = e3;
          this.print(t3, e3), this.tokenChar(44);
        }, t2.EnumNumberBody = function(e3) {
          const { explicitType: t3 } = e3;
          l(this, "number", t3), c(this, e3);
        }, t2.EnumNumberMember = function(e3) {
          u(this, e3);
        }, t2.EnumStringBody = function(e3) {
          const { explicitType: t3 } = e3;
          l(this, "string", t3), c(this, e3);
        }, t2.EnumStringMember = function(e3) {
          u(this, e3);
        }, t2.EnumSymbolBody = function(e3) {
          l(this, "symbol", true), c(this, e3);
        }, t2.ExistsTypeAnnotation = function() {
          this.tokenChar(42);
        }, t2.FunctionTypeAnnotation = function(e3, t3) {
          this.print(e3.typeParameters, e3), this.tokenChar(40), e3.this && (this.word("this"), this.tokenChar(58), this.space(), this.print(e3.this.typeAnnotation, e3), (e3.params.length || e3.rest) && (this.tokenChar(44), this.space())), this.printList(e3.params, e3), e3.rest && (e3.params.length && (this.tokenChar(44), this.space()), this.token("..."), this.print(e3.rest, e3)), this.tokenChar(41);
          const n3 = null == t3 ? void 0 : t3.type;
          null != n3 && ("ObjectTypeCallProperty" === n3 || "ObjectTypeInternalSlot" === n3 || "DeclareFunction" === n3 || "ObjectTypeProperty" === n3 && t3.method) ? this.tokenChar(58) : (this.space(), this.token("=>")), this.space(), this.print(e3.returnType, e3);
        }, t2.FunctionTypeParam = function(e3) {
          this.print(e3.name, e3), e3.optional && this.tokenChar(63), e3.name && (this.tokenChar(58), this.space()), this.print(e3.typeAnnotation, e3);
        }, t2.IndexedAccessType = function(e3) {
          this.print(e3.objectType, e3, true), this.tokenChar(91), this.print(e3.indexType, e3), this.tokenChar(93);
        }, t2.InferredPredicate = function() {
          this.tokenChar(37), this.word("checks");
        }, t2.InterfaceDeclaration = function(e3) {
          this.word("interface"), this.space(), this._interfaceish(e3);
        }, t2.GenericTypeAnnotation = t2.ClassImplements = t2.InterfaceExtends = function(e3) {
          this.print(e3.id, e3), this.print(e3.typeParameters, e3, true);
        }, t2.InterfaceTypeAnnotation = function(e3) {
          var t3;
          this.word("interface"), null != (t3 = e3.extends) && t3.length && (this.space(), this.word("extends"), this.space(), this.printList(e3.extends, e3)), this.space(), this.print(e3.body, e3);
        }, t2.IntersectionTypeAnnotation = function(e3) {
          this.printJoin(e3.types, e3, { separator: h });
        }, t2.MixedTypeAnnotation = function() {
          this.word("mixed");
        }, t2.NullLiteralTypeAnnotation = function() {
          this.word("null");
        }, t2.NullableTypeAnnotation = function(e3) {
          this.tokenChar(63), this.print(e3.typeAnnotation, e3);
        }, Object.defineProperty(t2, "NumberLiteralTypeAnnotation", { enumerable: true, get: function() {
          return s.NumericLiteral;
        } }), t2.NumberTypeAnnotation = function() {
          this.word("number");
        }, t2.ObjectTypeAnnotation = function(e3) {
          e3.exact ? this.token("{|") : this.tokenChar(123);
          const t3 = [...e3.properties, ...e3.callProperties || [], ...e3.indexers || [], ...e3.internalSlots || []];
          t3.length && (this.newline(), this.space(), this.printJoin(t3, e3, { addNewlines(e4) {
            if (e4 && !t3[0]) return 1;
          }, indent: true, statement: true, iterator: () => {
            (1 !== t3.length || e3.inexact) && (this.tokenChar(44), this.space());
          } }), this.space()), e3.inexact && (this.indent(), this.token("..."), t3.length && this.newline(), this.dedent()), e3.exact ? this.token("|}") : this.tokenChar(125);
        }, t2.ObjectTypeCallProperty = function(e3) {
          e3.static && (this.word("static"), this.space()), this.print(e3.value, e3);
        }, t2.ObjectTypeIndexer = function(e3) {
          e3.static && (this.word("static"), this.space()), this._variance(e3), this.tokenChar(91), e3.id && (this.print(e3.id, e3), this.tokenChar(58), this.space()), this.print(e3.key, e3), this.tokenChar(93), this.tokenChar(58), this.space(), this.print(e3.value, e3);
        }, t2.ObjectTypeInternalSlot = function(e3) {
          e3.static && (this.word("static"), this.space()), this.tokenChar(91), this.tokenChar(91), this.print(e3.id, e3), this.tokenChar(93), this.tokenChar(93), e3.optional && this.tokenChar(63), e3.method || (this.tokenChar(58), this.space()), this.print(e3.value, e3);
        }, t2.ObjectTypeProperty = function(e3) {
          e3.proto && (this.word("proto"), this.space()), e3.static && (this.word("static"), this.space()), "get" !== e3.kind && "set" !== e3.kind || (this.word(e3.kind), this.space()), this._variance(e3), this.print(e3.key, e3), e3.optional && this.tokenChar(63), e3.method || (this.tokenChar(58), this.space()), this.print(e3.value, e3);
        }, t2.ObjectTypeSpreadProperty = function(e3) {
          this.token("..."), this.print(e3.argument, e3);
        }, t2.OpaqueType = function(e3) {
          this.word("opaque"), this.space(), this.word("type"), this.space(), this.print(e3.id, e3), this.print(e3.typeParameters, e3), e3.supertype && (this.tokenChar(58), this.space(), this.print(e3.supertype, e3)), e3.impltype && (this.space(), this.tokenChar(61), this.space(), this.print(e3.impltype, e3)), this.semicolon();
        }, t2.OptionalIndexedAccessType = function(e3) {
          this.print(e3.objectType, e3), e3.optional && this.token("?."), this.tokenChar(91), this.print(e3.indexType, e3), this.tokenChar(93);
        }, t2.QualifiedTypeIdentifier = function(e3) {
          this.print(e3.qualification, e3), this.tokenChar(46), this.print(e3.id, e3);
        }, Object.defineProperty(t2, "StringLiteralTypeAnnotation", { enumerable: true, get: function() {
          return s.StringLiteral;
        } }), t2.StringTypeAnnotation = function() {
          this.word("string");
        }, t2.SymbolTypeAnnotation = function() {
          this.word("symbol");
        }, t2.ThisTypeAnnotation = function() {
          this.word("this");
        }, t2.TupleTypeAnnotation = function(e3) {
          this.tokenChar(91), this.printList(e3.types, e3), this.tokenChar(93);
        }, t2.TypeAlias = function(e3) {
          this.word("type"), this.space(), this.print(e3.id, e3), this.print(e3.typeParameters, e3), this.space(), this.tokenChar(61), this.space(), this.print(e3.right, e3), this.semicolon();
        }, t2.TypeAnnotation = function(e3) {
          this.tokenChar(58), this.space(), e3.optional && this.tokenChar(63), this.print(e3.typeAnnotation, e3);
        }, t2.TypeCastExpression = function(e3) {
          this.tokenChar(40), this.print(e3.expression, e3), this.print(e3.typeAnnotation, e3), this.tokenChar(41);
        }, t2.TypeParameter = function(e3) {
          this._variance(e3), this.word(e3.name), e3.bound && this.print(e3.bound, e3), e3.default && (this.space(), this.tokenChar(61), this.space(), this.print(e3.default, e3));
        }, t2.TypeParameterDeclaration = t2.TypeParameterInstantiation = function(e3) {
          this.tokenChar(60), this.printList(e3.params, e3, {}), this.tokenChar(62);
        }, t2.TypeofTypeAnnotation = function(e3) {
          this.word("typeof"), this.space(), this.print(e3.argument, e3);
        }, t2.UnionTypeAnnotation = function(e3) {
          this.printJoin(e3.types, e3, { separator: d });
        }, t2.Variance = function(e3) {
          "plus" === e3.kind ? this.tokenChar(43) : this.tokenChar(45);
        }, t2.VoidTypeAnnotation = function() {
          this.word("void");
        }, t2._interfaceish = function(e3) {
          var t3, n3, r3;
          (this.print(e3.id, e3), this.print(e3.typeParameters, e3), null != (t3 = e3.extends) && t3.length && (this.space(), this.word("extends"), this.space(), this.printList(e3.extends, e3)), "DeclareClass" === e3.type) && (null != (n3 = e3.mixins) && n3.length && (this.space(), this.word("mixins"), this.space(), this.printList(e3.mixins, e3)), null != (r3 = e3.implements) && r3.length && (this.space(), this.word("implements"), this.space(), this.printList(e3.implements, e3)));
          this.space(), this.print(e3.body, e3);
        }, t2._variance = function(e3) {
          var t3;
          const n3 = null == (t3 = e3.variance) ? void 0 : t3.kind;
          null != n3 && ("plus" === n3 ? this.tokenChar(43) : "minus" === n3 && this.tokenChar(45));
        };
        var r2 = n2(6067), i = n2(4272), s = n2(7585);
        const { isDeclareExportDeclaration: a, isStatement: o } = r2;
        function l(e3, t3, n3) {
          n3 && (e3.space(), e3.word("of"), e3.space(), e3.word(t3)), e3.space();
        }
        function c(e3, t3) {
          const { members: n3 } = t3;
          e3.token("{"), e3.indent(), e3.newline();
          for (const r3 of n3) e3.print(r3, t3), e3.newline();
          t3.hasUnknownMembers && (e3.token("..."), e3.newline()), e3.dedent(), e3.token("}");
        }
        function u(e3, t3) {
          const { id: n3, init: r3 } = t3;
          e3.print(n3, t3), e3.space(), e3.token("="), e3.space(), e3.print(r3, t3), e3.token(",");
        }
        function p(e3) {
          if (e3.declaration) {
            const t3 = e3.declaration;
            this.print(t3, e3), o(t3) || this.semicolon();
          } else this.tokenChar(123), e3.specifiers.length && (this.space(), this.printList(e3.specifiers, e3), this.space()), this.tokenChar(125), e3.source && (this.space(), this.word("from"), this.space(), this.print(e3.source, e3)), this.semicolon();
        }
        function h() {
          this.space(), this.tokenChar(38), this.space();
        }
        function d() {
          this.space(), this.tokenChar(124), this.space();
        }
      }, 4236: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true });
        var r2 = n2(9716);
        Object.keys(r2).forEach(function(e3) {
          "default" !== e3 && "__esModule" !== e3 && (e3 in t2 && t2[e3] === r2[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
            return r2[e3];
          } }));
        });
        var i = n2(7240);
        Object.keys(i).forEach(function(e3) {
          "default" !== e3 && "__esModule" !== e3 && (e3 in t2 && t2[e3] === i[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
            return i[e3];
          } }));
        });
        var s = n2(5448);
        Object.keys(s).forEach(function(e3) {
          "default" !== e3 && "__esModule" !== e3 && (e3 in t2 && t2[e3] === s[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
            return s[e3];
          } }));
        });
        var a = n2(695);
        Object.keys(a).forEach(function(e3) {
          "default" !== e3 && "__esModule" !== e3 && (e3 in t2 && t2[e3] === a[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
            return a[e3];
          } }));
        });
        var o = n2(7011);
        Object.keys(o).forEach(function(e3) {
          "default" !== e3 && "__esModule" !== e3 && (e3 in t2 && t2[e3] === o[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
            return o[e3];
          } }));
        });
        var l = n2(4272);
        Object.keys(l).forEach(function(e3) {
          "default" !== e3 && "__esModule" !== e3 && (e3 in t2 && t2[e3] === l[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
            return l[e3];
          } }));
        });
        var c = n2(7585);
        Object.keys(c).forEach(function(e3) {
          "default" !== e3 && "__esModule" !== e3 && (e3 in t2 && t2[e3] === c[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
            return c[e3];
          } }));
        });
        var u = n2(4735);
        Object.keys(u).forEach(function(e3) {
          "default" !== e3 && "__esModule" !== e3 && (e3 in t2 && t2[e3] === u[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
            return u[e3];
          } }));
        });
        var p = n2(9230);
        Object.keys(p).forEach(function(e3) {
          "default" !== e3 && "__esModule" !== e3 && (e3 in t2 && t2[e3] === p[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
            return p[e3];
          } }));
        });
        var h = n2(7878);
        Object.keys(h).forEach(function(e3) {
          "default" !== e3 && "__esModule" !== e3 && (e3 in t2 && t2[e3] === h[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
            return h[e3];
          } }));
        });
        var d = n2(5447);
        Object.keys(d).forEach(function(e3) {
          "default" !== e3 && "__esModule" !== e3 && (e3 in t2 && t2[e3] === d[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
            return d[e3];
          } }));
        });
      }, 7878: (e2, t2) => {
        "use strict";
        function n2() {
          this.space();
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.JSXAttribute = function(e3) {
          this.print(e3.name, e3), e3.value && (this.tokenChar(61), this.print(e3.value, e3));
        }, t2.JSXClosingElement = function(e3) {
          this.token("</"), this.print(e3.name, e3), this.tokenChar(62);
        }, t2.JSXClosingFragment = function() {
          this.token("</"), this.tokenChar(62);
        }, t2.JSXElement = function(e3) {
          const t3 = e3.openingElement;
          if (this.print(t3, e3), !t3.selfClosing) {
            this.indent();
            for (const t4 of e3.children) this.print(t4, e3);
            this.dedent(), this.print(e3.closingElement, e3);
          }
        }, t2.JSXEmptyExpression = function() {
          this.printInnerComments();
        }, t2.JSXExpressionContainer = function(e3) {
          this.tokenChar(123), this.print(e3.expression, e3), this.tokenChar(125);
        }, t2.JSXFragment = function(e3) {
          this.print(e3.openingFragment, e3), this.indent();
          for (const t3 of e3.children) this.print(t3, e3);
          this.dedent(), this.print(e3.closingFragment, e3);
        }, t2.JSXIdentifier = function(e3) {
          this.word(e3.name);
        }, t2.JSXMemberExpression = function(e3) {
          this.print(e3.object, e3), this.tokenChar(46), this.print(e3.property, e3);
        }, t2.JSXNamespacedName = function(e3) {
          this.print(e3.namespace, e3), this.tokenChar(58), this.print(e3.name, e3);
        }, t2.JSXOpeningElement = function(e3) {
          this.tokenChar(60), this.print(e3.name, e3), this.print(e3.typeParameters, e3), e3.attributes.length > 0 && (this.space(), this.printJoin(e3.attributes, e3, { separator: n2 })), e3.selfClosing ? (this.space(), this.token("/>")) : this.tokenChar(62);
        }, t2.JSXOpeningFragment = function() {
          this.tokenChar(60), this.tokenChar(62);
        }, t2.JSXSpreadAttribute = function(e3) {
          this.tokenChar(123), this.token("..."), this.print(e3.argument, e3), this.tokenChar(125);
        }, t2.JSXSpreadChild = function(e3) {
          this.tokenChar(123), this.token("..."), this.print(e3.expression, e3), this.tokenChar(125);
        }, t2.JSXText = function(e3) {
          const t3 = this.getPossibleRaw(e3);
          void 0 !== t3 ? this.token(t3, true) : this.token(e3.value, true);
        };
      }, 7011: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.ArrowFunctionExpression = function(e3, t3) {
          let n3;
          e3.async && (this.word("async", true), this.space()), this.format.retainLines || 1 !== e3.params.length || !i(n3 = e3.params[0]) || function(e4, t4) {
            var n4, r3;
            return !!(e4.typeParameters || e4.returnType || e4.predicate || t4.typeAnnotation || t4.optional || null != (n4 = t4.leadingComments) && n4.length || null != (r3 = t4.trailingComments) && r3.length);
          }(e3, n3) ? this._params(e3, void 0, t3) : this.print(n3, e3, true), this._predicate(e3, true), this.space(), this.printInnerComments(), this.token("=>"), this.space(), this.print(e3.body, e3);
        }, t2.FunctionDeclaration = t2.FunctionExpression = function(e3, t3) {
          this._functionHead(e3, t3), this.space(), this.print(e3.body, e3);
        }, t2._functionHead = function(e3, t3) {
          e3.async && (this.word("async"), this._endsWithInnerRaw = false, this.space()), this.word("function"), e3.generator && (this._endsWithInnerRaw = false, this.tokenChar(42)), this.space(), e3.id && this.print(e3.id, e3), this._params(e3, e3.id, t3), "TSDeclareFunction" !== e3.type && this._predicate(e3);
        }, t2._methodHead = function(e3) {
          const t3 = e3.kind, n3 = e3.key;
          "get" !== t3 && "set" !== t3 || (this.word(t3), this.space()), e3.async && (this.word("async", true), this.space()), "method" !== t3 && "init" !== t3 || e3.generator && this.tokenChar(42), e3.computed ? (this.tokenChar(91), this.print(n3, e3), this.tokenChar(93)) : this.print(n3, e3), e3.optional && this.tokenChar(63), this._params(e3, e3.computed && "StringLiteral" !== e3.key.type ? void 0 : e3.key, void 0);
        }, t2._param = function(e3, t3) {
          this.printJoin(e3.decorators, e3), this.print(e3, t3), e3.optional && this.tokenChar(63), this.print(e3.typeAnnotation, e3);
        }, t2._parameters = function(e3, t3) {
          const n3 = e3.length;
          for (let r3 = 0; r3 < n3; r3++) this._param(e3[r3], t3), r3 < e3.length - 1 && (this.tokenChar(44), this.space());
        }, t2._params = function(e3, t3, n3) {
          this.print(e3.typeParameters, e3);
          const r3 = s.call(this, t3, n3);
          r3 && this.sourceIdentifierName(r3.name, r3.pos), this.tokenChar(40), this._parameters(e3.params, e3), this.tokenChar(41);
          const i2 = "ArrowFunctionExpression" === e3.type;
          this.print(e3.returnType, e3, i2), this._noLineTerminator = i2;
        }, t2._predicate = function(e3, t3) {
          e3.predicate && (e3.returnType || this.tokenChar(58), this.space(), this.print(e3.predicate, e3, t3));
        };
        var r2 = n2(6067);
        const { isIdentifier: i } = r2;
        function s(e3, t3) {
          let n3, r3 = e3;
          if (!r3 && t3) {
            const e4 = t3.type;
            "VariableDeclarator" === e4 ? r3 = t3.id : "AssignmentExpression" === e4 || "AssignmentPattern" === e4 ? r3 = t3.left : "ObjectProperty" === e4 || "ClassProperty" === e4 ? t3.computed && "StringLiteral" !== t3.key.type || (r3 = t3.key) : "ClassPrivateProperty" !== e4 && "ClassAccessorProperty" !== e4 || (r3 = t3.key);
          }
          if (r3) {
            var i2, s2;
            if ("Identifier" === r3.type) n3 = { pos: null == (i2 = r3.loc) ? void 0 : i2.start, name: (null == (s2 = r3.loc) ? void 0 : s2.identifierName) || r3.name };
            else if ("PrivateName" === r3.type) {
              var a;
              n3 = { pos: null == (a = r3.loc) ? void 0 : a.start, name: "#" + r3.id.name };
            } else if ("StringLiteral" === r3.type) {
              var o;
              n3 = { pos: null == (o = r3.loc) ? void 0 : o.start, name: r3.value };
            }
            return n3;
          }
        }
      }, 4272: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.ExportAllDeclaration = function(e3) {
          var t3, n3;
          this.word("export"), this.space(), "type" === e3.exportKind && (this.word("type"), this.space()), this.tokenChar(42), this.space(), this.word("from"), this.space(), null != (t3 = e3.attributes) && t3.length || null != (n3 = e3.assertions) && n3.length ? (this.print(e3.source, e3, true), this.space(), this._printAttributes(e3)) : this.print(e3.source, e3), this.semicolon();
        }, t2.ExportDefaultDeclaration = function(e3) {
          p(this, e3), this.word("export"), this.noIndentInnerCommentsHere(), this.space(), this.word("default"), this.space();
          const t3 = e3.declaration;
          this.print(t3, e3), c(t3) || this.semicolon();
        }, t2.ExportDefaultSpecifier = function(e3) {
          this.print(e3.exported, e3);
        }, t2.ExportNamedDeclaration = function(e3) {
          if (p(this, e3), this.word("export"), this.space(), e3.declaration) {
            const t4 = e3.declaration;
            this.print(t4, e3), c(t4) || this.semicolon();
          } else {
            "type" === e3.exportKind && (this.word("type"), this.space());
            const r3 = e3.specifiers.slice(0);
            let i2 = false;
            for (; ; ) {
              const t4 = r3[0];
              if (!s(t4) && !a(t4)) break;
              i2 = true, this.print(r3.shift(), e3), r3.length && (this.tokenChar(44), this.space());
            }
            var t3, n3;
            (r3.length || !r3.length && !i2) && (this.tokenChar(123), r3.length && (this.space(), this.printList(r3, e3), this.space()), this.tokenChar(125)), e3.source && (this.space(), this.word("from"), this.space(), null != (t3 = e3.attributes) && t3.length || null != (n3 = e3.assertions) && n3.length ? (this.print(e3.source, e3, true), this.space(), this._printAttributes(e3)) : this.print(e3.source, e3)), this.semicolon();
          }
        }, t2.ExportNamespaceSpecifier = function(e3) {
          this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(e3.exported, e3);
        }, t2.ExportSpecifier = function(e3) {
          "type" === e3.exportKind && (this.word("type"), this.space()), this.print(e3.local, e3), e3.exported && e3.local.name !== e3.exported.name && (this.space(), this.word("as"), this.space(), this.print(e3.exported, e3));
        }, t2.ImportAttribute = function(e3) {
          this.print(e3.key), this.tokenChar(58), this.space(), this.print(e3.value);
        }, t2.ImportDeclaration = function(e3) {
          var t3, n3;
          this.word("import"), this.space();
          const r3 = "type" === e3.importKind || "typeof" === e3.importKind;
          r3 ? (this.noIndentInnerCommentsHere(), this.word(e3.importKind), this.space()) : e3.module && (this.noIndentInnerCommentsHere(), this.word("module"), this.space());
          const i2 = e3.specifiers.slice(0), s2 = !!i2.length;
          for (; s2; ) {
            const t4 = i2[0];
            if (!o(t4) && !l(t4)) break;
            this.print(i2.shift(), e3), i2.length && (this.tokenChar(44), this.space());
          }
          i2.length ? (this.tokenChar(123), this.space(), this.printList(i2, e3), this.space(), this.tokenChar(125)) : r3 && !s2 && (this.tokenChar(123), this.tokenChar(125)), (s2 || r3) && (this.space(), this.word("from"), this.space()), null != (t3 = e3.attributes) && t3.length || null != (n3 = e3.assertions) && n3.length ? (this.print(e3.source, e3, true), this.space(), this._printAttributes(e3)) : this.print(e3.source, e3), this.semicolon();
        }, t2.ImportDefaultSpecifier = function(e3) {
          this.print(e3.local, e3);
        }, t2.ImportNamespaceSpecifier = function(e3) {
          this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(e3.local, e3);
        }, t2.ImportSpecifier = function(e3) {
          "type" !== e3.importKind && "typeof" !== e3.importKind || (this.word(e3.importKind), this.space()), this.print(e3.imported, e3), e3.local && e3.local.name !== e3.imported.name && (this.space(), this.word("as"), this.space(), this.print(e3.local, e3));
        }, t2._printAttributes = function(e3) {
          const { importAttributesKeyword: t3 } = this.format, { attributes: n3, assertions: r3 } = e3;
          !n3 || t3 || u || (u = true, console.warn('You are using import attributes, without specifying the desired output syntax.\nPlease specify the "importAttributesKeyword" generator option, whose value can be one of:\n - "with"        : `import { a } from "b" with { type: "json" };`\n - "assert"      : `import { a } from "b" assert { type: "json" };`\n - "with-legacy" : `import { a } from "b" with type: "json";`\n'));
          const i2 = "assert" === t3 || !t3 && r3;
          this.word(i2 ? "assert" : "with"), this.space(), i2 || "with" === t3 ? (this.tokenChar(123), this.space(), this.printList(n3 || r3, e3), this.space(), this.tokenChar(125)) : this.printList(n3 || r3, e3);
        };
        var r2 = n2(6067);
        const { isClassDeclaration: i, isExportDefaultSpecifier: s, isExportNamespaceSpecifier: a, isImportDefaultSpecifier: o, isImportNamespaceSpecifier: l, isStatement: c } = r2;
        let u = false;
        function p(e3, t3) {
          i(t3.declaration) && e3._shouldPrintDecoratorsBeforeExport(t3) && e3.printJoin(t3.declaration.decorators, t3);
        }
      }, 5448: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.BreakStatement = function(e3) {
          this.word("break"), h(this, e3.label, e3, true);
        }, t2.CatchClause = function(e3) {
          this.word("catch"), this.space(), e3.param && (this.tokenChar(40), this.print(e3.param, e3), this.print(e3.param.typeAnnotation, e3), this.tokenChar(41), this.space()), this.print(e3.body, e3);
        }, t2.ContinueStatement = function(e3) {
          this.word("continue"), h(this, e3.label, e3, true);
        }, t2.DebuggerStatement = function() {
          this.word("debugger"), this.semicolon();
        }, t2.DoWhileStatement = function(e3) {
          this.word("do"), this.space(), this.print(e3.body, e3), this.space(), this.word("while"), this.space(), this.tokenChar(40), this.print(e3.test, e3), this.tokenChar(41), this.semicolon();
        }, t2.ForOfStatement = t2.ForInStatement = void 0, t2.ForStatement = function(e3) {
          this.word("for"), this.space(), this.tokenChar(40), this.inForStatementInitCounter++, this.print(e3.init, e3), this.inForStatementInitCounter--, this.tokenChar(59), e3.test && (this.space(), this.print(e3.test, e3)), this.tokenChar(59), e3.update && (this.space(), this.print(e3.update, e3)), this.tokenChar(41), this.printBlock(e3);
        }, t2.IfStatement = function(e3) {
          this.word("if"), this.space(), this.tokenChar(40), this.print(e3.test, e3), this.tokenChar(41), this.space();
          const t3 = e3.alternate && a(l(e3.consequent));
          t3 && (this.tokenChar(123), this.newline(), this.indent()), this.printAndIndentOnComments(e3.consequent, e3), t3 && (this.dedent(), this.newline(), this.tokenChar(125)), e3.alternate && (this.endsWith(125) && this.space(), this.word("else"), this.space(), this.printAndIndentOnComments(e3.alternate, e3));
        }, t2.LabeledStatement = function(e3) {
          this.print(e3.label, e3), this.tokenChar(58), this.space(), this.print(e3.body, e3);
        }, t2.ReturnStatement = function(e3) {
          this.word("return"), h(this, e3.argument, e3, false);
        }, t2.SwitchCase = function(e3) {
          e3.test ? (this.word("case"), this.space(), this.print(e3.test, e3), this.tokenChar(58)) : (this.word("default"), this.tokenChar(58)), e3.consequent.length && (this.newline(), this.printSequence(e3.consequent, e3, { indent: true }));
        }, t2.SwitchStatement = function(e3) {
          this.word("switch"), this.space(), this.tokenChar(40), this.print(e3.discriminant, e3), this.tokenChar(41), this.space(), this.tokenChar(123), this.printSequence(e3.cases, e3, { indent: true, addNewlines(t3, n3) {
            if (!t3 && e3.cases[e3.cases.length - 1] === n3) return -1;
          } }), this.rightBrace(e3);
        }, t2.ThrowStatement = function(e3) {
          this.word("throw"), h(this, e3.argument, e3, false);
        }, t2.TryStatement = function(e3) {
          this.word("try"), this.space(), this.print(e3.block, e3), this.space(), e3.handlers ? this.print(e3.handlers[0], e3) : this.print(e3.handler, e3), e3.finalizer && (this.space(), this.word("finally"), this.space(), this.print(e3.finalizer, e3));
        }, t2.VariableDeclaration = function(e3, t3) {
          e3.declare && (this.word("declare"), this.space());
          const { kind: n3 } = e3;
          this.word(n3, "using" === n3 || "await using" === n3), this.space();
          let r3 = false;
          if (!i(t3)) for (const t4 of e3.declarations) t4.init && (r3 = true);
          if (this.printList(e3.declarations, e3, { separator: r3 ? function() {
            this.tokenChar(44), this.newline();
          } : void 0, indent: e3.declarations.length > 1 }), i(t3)) {
            if (s(t3)) {
              if (t3.init === e3) return;
            } else if (t3.left === e3) return;
          }
          this.semicolon();
        }, t2.VariableDeclarator = function(e3) {
          this.print(e3.id, e3), e3.definite && this.tokenChar(33), this.print(e3.id.typeAnnotation, e3), e3.init && (this.space(), this.tokenChar(61), this.space(), this.print(e3.init, e3));
        }, t2.WhileStatement = function(e3) {
          this.word("while"), this.space(), this.tokenChar(40), this.print(e3.test, e3), this.tokenChar(41), this.printBlock(e3);
        }, t2.WithStatement = function(e3) {
          this.word("with"), this.space(), this.tokenChar(40), this.print(e3.object, e3), this.tokenChar(41), this.printBlock(e3);
        };
        var r2 = n2(6067);
        const { isFor: i, isForStatement: s, isIfStatement: a, isStatement: o } = r2;
        function l(e3) {
          const { body: t3 } = e3;
          return false === o(t3) ? e3 : l(t3);
        }
        function c(e3) {
          this.word("for"), this.space();
          const t3 = "ForOfStatement" === e3.type;
          t3 && e3.await && (this.word("await"), this.space()), this.noIndentInnerCommentsHere(), this.tokenChar(40), this.print(e3.left, e3), this.space(), this.word(t3 ? "of" : "in"), this.space(), this.print(e3.right, e3), this.tokenChar(41), this.printBlock(e3);
        }
        const u = c;
        t2.ForInStatement = u;
        const p = c;
        function h(e3, t3, n3, r3) {
          t3 && (e3.space(), e3.printTerminatorless(t3, n3, r3)), e3.semicolon();
        }
        t2.ForOfStatement = p;
      }, 9716: (e2, t2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.TaggedTemplateExpression = function(e3) {
          this.print(e3.tag, e3), this.print(e3.typeParameters, e3), this.print(e3.quasi, e3);
        }, t2.TemplateElement = function(e3, t3) {
          const n2 = t3.quasis[0] === e3, r2 = t3.quasis[t3.quasis.length - 1] === e3, i = (n2 ? "`" : "}") + e3.value.raw + (r2 ? "`" : "${");
          this.token(i, true);
        }, t2.TemplateLiteral = function(e3) {
          const t3 = e3.quasis;
          for (let n2 = 0; n2 < t3.length; n2++) this.print(t3[n2], e3), n2 + 1 < t3.length && this.print(e3.expressions[n2], e3);
        };
      }, 7585: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.ArgumentPlaceholder = function() {
          this.tokenChar(63);
        }, t2.ArrayPattern = t2.ArrayExpression = function(e3) {
          const t3 = e3.elements, n3 = t3.length;
          this.tokenChar(91);
          for (let r3 = 0; r3 < t3.length; r3++) {
            const i2 = t3[r3];
            i2 ? (r3 > 0 && this.space(), this.print(i2, e3), r3 < n3 - 1 && this.tokenChar(44)) : this.tokenChar(44);
          }
          this.tokenChar(93);
        }, t2.BigIntLiteral = function(e3) {
          const t3 = this.getPossibleRaw(e3);
          this.format.minified || void 0 === t3 ? this.word(e3.value + "n") : this.word(t3);
        }, t2.BooleanLiteral = function(e3) {
          this.word(e3.value ? "true" : "false");
        }, t2.DecimalLiteral = function(e3) {
          const t3 = this.getPossibleRaw(e3);
          this.format.minified || void 0 === t3 ? this.word(e3.value + "m") : this.word(t3);
        }, t2.Identifier = function(e3) {
          var t3;
          this.sourceIdentifierName((null == (t3 = e3.loc) ? void 0 : t3.identifierName) || e3.name), this.word(e3.name);
        }, t2.NullLiteral = function() {
          this.word("null");
        }, t2.NumericLiteral = function(e3) {
          const t3 = this.getPossibleRaw(e3), n3 = this.format.jsescOption, r3 = e3.value + "";
          n3.numbers ? this.number(i(e3.value, n3)) : null == t3 ? this.number(r3) : this.format.minified ? this.number(t3.length < r3.length ? t3 : r3) : this.number(t3);
        }, t2.ObjectPattern = t2.ObjectExpression = function(e3) {
          const t3 = e3.properties;
          this.tokenChar(123), t3.length && (this.space(), this.printList(t3, e3, { indent: true, statement: true }), this.space()), this.sourceWithOffset("end", e3.loc, -1), this.tokenChar(125);
        }, t2.ObjectMethod = function(e3) {
          this.printJoin(e3.decorators, e3), this._methodHead(e3), this.space(), this.print(e3.body, e3);
        }, t2.ObjectProperty = function(e3) {
          if (this.printJoin(e3.decorators, e3), e3.computed) this.tokenChar(91), this.print(e3.key, e3), this.tokenChar(93);
          else {
            if (s(e3.value) && a(e3.key) && e3.key.name === e3.value.left.name) return void this.print(e3.value, e3);
            if (this.print(e3.key, e3), e3.shorthand && a(e3.key) && a(e3.value) && e3.key.name === e3.value.name) return;
          }
          this.tokenChar(58), this.space(), this.print(e3.value, e3);
        }, t2.PipelineBareFunction = function(e3) {
          this.print(e3.callee, e3);
        }, t2.PipelinePrimaryTopicReference = function() {
          this.tokenChar(35);
        }, t2.PipelineTopicExpression = function(e3) {
          this.print(e3.expression, e3);
        }, t2.RecordExpression = function(e3) {
          const t3 = e3.properties;
          let n3, r3;
          if ("bar" === this.format.recordAndTupleSyntaxType) n3 = "{|", r3 = "|}";
          else {
            if ("hash" !== this.format.recordAndTupleSyntaxType && null != this.format.recordAndTupleSyntaxType) throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)} received).`);
            n3 = "#{", r3 = "}";
          }
          this.token(n3), t3.length && (this.space(), this.printList(t3, e3, { indent: true, statement: true }), this.space()), this.token(r3);
        }, t2.RegExpLiteral = function(e3) {
          this.word(`/${e3.pattern}/${e3.flags}`);
        }, t2.SpreadElement = t2.RestElement = function(e3) {
          this.token("..."), this.print(e3.argument, e3);
        }, t2.StringLiteral = function(e3) {
          const t3 = this.getPossibleRaw(e3);
          if (!this.format.minified && void 0 !== t3) return void this.token(t3);
          const n3 = i(e3.value, this.format.jsescOption);
          this.token(n3);
        }, t2.TopicReference = function() {
          const { topicToken: e3 } = this.format;
          if (!o.has(e3)) {
            const t3 = JSON.stringify(e3), n3 = Array.from(o, (e4) => JSON.stringify(e4));
            throw new Error(`The "topicToken" generator option must be one of ${n3.join(", ")} (${t3} received instead).`);
          }
          this.token(e3);
        }, t2.TupleExpression = function(e3) {
          const t3 = e3.elements, n3 = t3.length;
          let r3, i2;
          if ("bar" === this.format.recordAndTupleSyntaxType) r3 = "[|", i2 = "|]";
          else {
            if ("hash" !== this.format.recordAndTupleSyntaxType) throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);
            r3 = "#[", i2 = "]";
          }
          this.token(r3);
          for (let r4 = 0; r4 < t3.length; r4++) {
            const i3 = t3[r4];
            i3 && (r4 > 0 && this.space(), this.print(i3, e3), r4 < n3 - 1 && this.tokenChar(44));
          }
          this.token(i2);
        };
        var r2 = n2(6067), i = n2(3312);
        const { isAssignmentPattern: s, isIdentifier: a } = r2, o = /* @__PURE__ */ new Set(["^^", "@@", "^", "%", "#"]);
      }, 5447: (e2, t2) => {
        "use strict";
        function n2(e3, t3, n3) {
          if (e3.token("{"), t3.length) {
            e3.indent(), e3.newline();
            for (const r3 of t3) e3.print(r3, n3), e3.newline();
            e3.dedent();
          }
          e3.rightBrace(n3);
        }
        function r2(e3, t3, n3) {
          e3.printJoin(t3.types, t3, { separator() {
            this.space(), this.token(n3), this.space();
          } });
        }
        function i(e3, t3) {
          true !== t3 && e3.token(t3);
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.TSAnyKeyword = function() {
          this.word("any");
        }, t2.TSArrayType = function(e3) {
          this.print(e3.elementType, e3, true), this.token("[]");
        }, t2.TSSatisfiesExpression = t2.TSAsExpression = function(e3) {
          var t3;
          const { type: n3, expression: r3, typeAnnotation: i2 } = e3, s = !(null == (t3 = r3.trailingComments) || !t3.length);
          this.print(r3, e3, true, void 0, s), this.space(), this.word("TSAsExpression" === n3 ? "as" : "satisfies"), this.space(), this.print(i2, e3);
        }, t2.TSBigIntKeyword = function() {
          this.word("bigint");
        }, t2.TSBooleanKeyword = function() {
          this.word("boolean");
        }, t2.TSCallSignatureDeclaration = function(e3) {
          this.tsPrintSignatureDeclarationBase(e3), this.tokenChar(59);
        }, t2.TSConditionalType = function(e3) {
          this.print(e3.checkType), this.space(), this.word("extends"), this.space(), this.print(e3.extendsType), this.space(), this.tokenChar(63), this.space(), this.print(e3.trueType), this.space(), this.tokenChar(58), this.space(), this.print(e3.falseType);
        }, t2.TSConstructSignatureDeclaration = function(e3) {
          this.word("new"), this.space(), this.tsPrintSignatureDeclarationBase(e3), this.tokenChar(59);
        }, t2.TSConstructorType = function(e3) {
          e3.abstract && (this.word("abstract"), this.space()), this.word("new"), this.space(), this.tsPrintFunctionOrConstructorType(e3);
        }, t2.TSDeclareFunction = function(e3, t3) {
          e3.declare && (this.word("declare"), this.space()), this._functionHead(e3, t3), this.tokenChar(59);
        }, t2.TSDeclareMethod = function(e3) {
          this._classMethodHead(e3), this.tokenChar(59);
        }, t2.TSEnumDeclaration = function(e3) {
          const { declare: t3, const: r3, id: i2, members: s } = e3;
          t3 && (this.word("declare"), this.space()), r3 && (this.word("const"), this.space()), this.word("enum"), this.space(), this.print(i2, e3), this.space(), n2(this, s, e3);
        }, t2.TSEnumMember = function(e3) {
          const { id: t3, initializer: n3 } = e3;
          this.print(t3, e3), n3 && (this.space(), this.tokenChar(61), this.space(), this.print(n3, e3)), this.tokenChar(44);
        }, t2.TSExportAssignment = function(e3) {
          this.word("export"), this.space(), this.tokenChar(61), this.space(), this.print(e3.expression, e3), this.tokenChar(59);
        }, t2.TSExpressionWithTypeArguments = function(e3) {
          this.print(e3.expression, e3), this.print(e3.typeParameters, e3);
        }, t2.TSExternalModuleReference = function(e3) {
          this.token("require("), this.print(e3.expression, e3), this.tokenChar(41);
        }, t2.TSFunctionType = function(e3) {
          this.tsPrintFunctionOrConstructorType(e3);
        }, t2.TSImportEqualsDeclaration = function(e3) {
          const { isExport: t3, id: n3, moduleReference: r3 } = e3;
          t3 && (this.word("export"), this.space()), this.word("import"), this.space(), this.print(n3, e3), this.space(), this.tokenChar(61), this.space(), this.print(r3, e3), this.tokenChar(59);
        }, t2.TSImportType = function(e3) {
          const { argument: t3, qualifier: n3, typeParameters: r3 } = e3;
          this.word("import"), this.tokenChar(40), this.print(t3, e3), this.tokenChar(41), n3 && (this.tokenChar(46), this.print(n3, e3)), r3 && this.print(r3, e3);
        }, t2.TSIndexSignature = function(e3) {
          const { readonly: t3, static: n3 } = e3;
          n3 && (this.word("static"), this.space()), t3 && (this.word("readonly"), this.space()), this.tokenChar(91), this._parameters(e3.parameters, e3), this.tokenChar(93), this.print(e3.typeAnnotation, e3), this.tokenChar(59);
        }, t2.TSIndexedAccessType = function(e3) {
          this.print(e3.objectType, e3, true), this.tokenChar(91), this.print(e3.indexType, e3), this.tokenChar(93);
        }, t2.TSInferType = function(e3) {
          this.token("infer"), this.space(), this.print(e3.typeParameter);
        }, t2.TSInstantiationExpression = function(e3) {
          this.print(e3.expression, e3), this.print(e3.typeParameters, e3);
        }, t2.TSInterfaceBody = function(e3) {
          this.tsPrintTypeLiteralOrInterfaceBody(e3.body, e3);
        }, t2.TSInterfaceDeclaration = function(e3) {
          const { declare: t3, id: n3, typeParameters: r3, extends: i2, body: s } = e3;
          t3 && (this.word("declare"), this.space()), this.word("interface"), this.space(), this.print(n3, e3), this.print(r3, e3), null != i2 && i2.length && (this.space(), this.word("extends"), this.space(), this.printList(i2, e3)), this.space(), this.print(s, e3);
        }, t2.TSIntersectionType = function(e3) {
          r2(this, e3, "&");
        }, t2.TSIntrinsicKeyword = function() {
          this.word("intrinsic");
        }, t2.TSLiteralType = function(e3) {
          this.print(e3.literal, e3);
        }, t2.TSMappedType = function(e3) {
          const { nameType: t3, optional: n3, readonly: r3, typeParameter: s } = e3;
          this.tokenChar(123), this.space(), r3 && (i(this, r3), this.word("readonly"), this.space()), this.tokenChar(91), this.word(s.name), this.space(), this.word("in"), this.space(), this.print(s.constraint, s), t3 && (this.space(), this.word("as"), this.space(), this.print(t3, e3)), this.tokenChar(93), n3 && (i(this, n3), this.tokenChar(63)), this.tokenChar(58), this.space(), this.print(e3.typeAnnotation, e3), this.space(), this.tokenChar(125);
        }, t2.TSMethodSignature = function(e3) {
          const { kind: t3 } = e3;
          "set" !== t3 && "get" !== t3 || (this.word(t3), this.space()), this.tsPrintPropertyOrMethodName(e3), this.tsPrintSignatureDeclarationBase(e3), this.tokenChar(59);
        }, t2.TSModuleBlock = function(e3) {
          n2(this, e3.body, e3);
        }, t2.TSModuleDeclaration = function(e3) {
          const { declare: t3, id: n3 } = e3;
          if (t3 && (this.word("declare"), this.space()), e3.global || (this.word("Identifier" === n3.type ? "namespace" : "module"), this.space()), this.print(n3, e3), !e3.body) return void this.tokenChar(59);
          let r3 = e3.body;
          for (; "TSModuleDeclaration" === r3.type; ) this.tokenChar(46), this.print(r3.id, r3), r3 = r3.body;
          this.space(), this.print(r3, e3);
        }, t2.TSNamedTupleMember = function(e3) {
          this.print(e3.label, e3), e3.optional && this.tokenChar(63), this.tokenChar(58), this.space(), this.print(e3.elementType, e3);
        }, t2.TSNamespaceExportDeclaration = function(e3) {
          this.word("export"), this.space(), this.word("as"), this.space(), this.word("namespace"), this.space(), this.print(e3.id, e3);
        }, t2.TSNeverKeyword = function() {
          this.word("never");
        }, t2.TSNonNullExpression = function(e3) {
          this.print(e3.expression, e3), this.tokenChar(33);
        }, t2.TSNullKeyword = function() {
          this.word("null");
        }, t2.TSNumberKeyword = function() {
          this.word("number");
        }, t2.TSObjectKeyword = function() {
          this.word("object");
        }, t2.TSOptionalType = function(e3) {
          this.print(e3.typeAnnotation, e3), this.tokenChar(63);
        }, t2.TSParameterProperty = function(e3) {
          e3.accessibility && (this.word(e3.accessibility), this.space()), e3.readonly && (this.word("readonly"), this.space()), this._param(e3.parameter);
        }, t2.TSParenthesizedType = function(e3) {
          this.tokenChar(40), this.print(e3.typeAnnotation, e3), this.tokenChar(41);
        }, t2.TSPropertySignature = function(e3) {
          const { readonly: t3, initializer: n3 } = e3;
          t3 && (this.word("readonly"), this.space()), this.tsPrintPropertyOrMethodName(e3), this.print(e3.typeAnnotation, e3), n3 && (this.space(), this.tokenChar(61), this.space(), this.print(n3, e3)), this.tokenChar(59);
        }, t2.TSQualifiedName = function(e3) {
          this.print(e3.left, e3), this.tokenChar(46), this.print(e3.right, e3);
        }, t2.TSRestType = function(e3) {
          this.token("..."), this.print(e3.typeAnnotation, e3);
        }, t2.TSStringKeyword = function() {
          this.word("string");
        }, t2.TSSymbolKeyword = function() {
          this.word("symbol");
        }, t2.TSThisType = function() {
          this.word("this");
        }, t2.TSTupleType = function(e3) {
          this.tokenChar(91), this.printList(e3.elementTypes, e3), this.tokenChar(93);
        }, t2.TSTypeAliasDeclaration = function(e3) {
          const { declare: t3, id: n3, typeParameters: r3, typeAnnotation: i2 } = e3;
          t3 && (this.word("declare"), this.space()), this.word("type"), this.space(), this.print(n3, e3), this.print(r3, e3), this.space(), this.tokenChar(61), this.space(), this.print(i2, e3), this.tokenChar(59);
        }, t2.TSTypeAnnotation = function(e3) {
          this.tokenChar(58), this.space(), e3.optional && this.tokenChar(63), this.print(e3.typeAnnotation, e3);
        }, t2.TSTypeAssertion = function(e3) {
          const { typeAnnotation: t3, expression: n3 } = e3;
          this.tokenChar(60), this.print(t3, e3), this.tokenChar(62), this.space(), this.print(n3, e3);
        }, t2.TSTypeLiteral = function(e3) {
          this.tsPrintTypeLiteralOrInterfaceBody(e3.members, e3);
        }, t2.TSTypeOperator = function(e3) {
          this.word(e3.operator), this.space(), this.print(e3.typeAnnotation, e3);
        }, t2.TSTypeParameter = function(e3) {
          e3.in && (this.word("in"), this.space()), e3.out && (this.word("out"), this.space()), this.word(e3.name), e3.constraint && (this.space(), this.word("extends"), this.space(), this.print(e3.constraint, e3)), e3.default && (this.space(), this.tokenChar(61), this.space(), this.print(e3.default, e3));
        }, t2.TSTypeParameterDeclaration = t2.TSTypeParameterInstantiation = function(e3, t3) {
          this.tokenChar(60), this.printList(e3.params, e3, {}), "ArrowFunctionExpression" === t3.type && 1 === e3.params.length && this.tokenChar(44), this.tokenChar(62);
        }, t2.TSTypePredicate = function(e3) {
          e3.asserts && (this.word("asserts"), this.space()), this.print(e3.parameterName), e3.typeAnnotation && (this.space(), this.word("is"), this.space(), this.print(e3.typeAnnotation.typeAnnotation));
        }, t2.TSTypeQuery = function(e3) {
          this.word("typeof"), this.space(), this.print(e3.exprName), e3.typeParameters && this.print(e3.typeParameters, e3);
        }, t2.TSTypeReference = function(e3) {
          this.print(e3.typeName, e3, true), this.print(e3.typeParameters, e3, true);
        }, t2.TSUndefinedKeyword = function() {
          this.word("undefined");
        }, t2.TSUnionType = function(e3) {
          r2(this, e3, "|");
        }, t2.TSUnknownKeyword = function() {
          this.word("unknown");
        }, t2.TSVoidKeyword = function() {
          this.word("void");
        }, t2.tsPrintClassMemberModifiers = function(e3) {
          const t3 = "ClassAccessorProperty" === e3.type || "ClassProperty" === e3.type;
          t3 && e3.declare && (this.word("declare"), this.space()), e3.accessibility && (this.word(e3.accessibility), this.space()), e3.static && (this.word("static"), this.space()), e3.override && (this.word("override"), this.space()), e3.abstract && (this.word("abstract"), this.space()), t3 && e3.readonly && (this.word("readonly"), this.space());
        }, t2.tsPrintFunctionOrConstructorType = function(e3) {
          const { typeParameters: t3 } = e3, n3 = e3.parameters;
          this.print(t3, e3), this.tokenChar(40), this._parameters(n3, e3), this.tokenChar(41), this.space(), this.token("=>"), this.space();
          const r3 = e3.typeAnnotation;
          this.print(r3.typeAnnotation, e3);
        }, t2.tsPrintPropertyOrMethodName = function(e3) {
          e3.computed && this.tokenChar(91), this.print(e3.key, e3), e3.computed && this.tokenChar(93), e3.optional && this.tokenChar(63);
        }, t2.tsPrintSignatureDeclarationBase = function(e3) {
          const { typeParameters: t3 } = e3, n3 = e3.parameters;
          this.print(t3, e3), this.tokenChar(40), this._parameters(n3, e3), this.tokenChar(41);
          const r3 = e3.typeAnnotation;
          this.print(r3, e3);
        }, t2.tsPrintTypeLiteralOrInterfaceBody = function(e3, t3) {
          n2(this, e3, t3);
        };
      }, 7848: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.CodeGenerator = void 0, t2.default = function(e3, t3, n3) {
          return new s(e3, t3, n3).generate();
        };
        var r2 = n2(2564), i = n2(516);
        class s extends i.default {
          constructor(e3, t3 = {}, n3) {
            const i2 = function(e4, t4) {
              var n4;
              const r3 = { auxiliaryCommentBefore: t4.auxiliaryCommentBefore, auxiliaryCommentAfter: t4.auxiliaryCommentAfter, shouldPrintComment: t4.shouldPrintComment, retainLines: t4.retainLines, retainFunctionParens: t4.retainFunctionParens, comments: null == t4.comments || t4.comments, compact: t4.compact, minified: t4.minified, concise: t4.concise, indent: { adjustMultilineComment: true, style: "  " }, jsescOption: Object.assign({ quotes: "double", wrap: true, minimal: false }, t4.jsescOption), recordAndTupleSyntaxType: null != (n4 = t4.recordAndTupleSyntaxType) ? n4 : "hash", topicToken: t4.topicToken, importAttributesKeyword: t4.importAttributesKeyword };
              r3.decoratorsBeforeExport = t4.decoratorsBeforeExport, r3.jsescOption.json = t4.jsonCompatibleStrings, r3.minified ? (r3.compact = true, r3.shouldPrintComment = r3.shouldPrintComment || (() => r3.comments)) : r3.shouldPrintComment = r3.shouldPrintComment || ((e5) => r3.comments || e5.includes("@license") || e5.includes("@preserve")), "auto" === r3.compact && (r3.compact = "string" == typeof e4 && e4.length > 5e5, r3.compact && console.error(`[BABEL] Note: The code generator has deoptimised the styling of ${t4.filename} as it exceeds the max of 500KB.`)), r3.compact && (r3.indent.adjustMultilineComment = false);
              const { auxiliaryCommentBefore: i3, auxiliaryCommentAfter: s2, shouldPrintComment: a } = r3;
              return i3 && !a(i3) && (r3.auxiliaryCommentBefore = void 0), s2 && !a(s2) && (r3.auxiliaryCommentAfter = void 0), r3;
            }(n3, t3);
            super(i2, t3.sourceMaps ? new r2.default(t3, n3) : null), this.ast = void 0, this.ast = e3;
          }
          generate() {
            return super.generate(this.ast);
          }
        }
        t2.CodeGenerator = class {
          constructor(e3, t3, n3) {
            this._generator = void 0, this._generator = new s(e3, t3, n3);
          }
          generate() {
            return this._generator.generate();
          }
        };
      }, 7533: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.needsParens = function(e3, t3, n3) {
          return !!t3 && (!(!u(t3) || t3.callee !== e3 || !y(e3)) || f(h, e3, t3, n3));
        }, t2.needsWhitespace = m, t2.needsWhitespaceAfter = function(e3, t3) {
          return m(e3, t3, 2);
        }, t2.needsWhitespaceBefore = function(e3, t3) {
          return m(e3, t3, 1);
        };
        var r2 = n2(9750), i = n2(7363), s = n2(6067);
        const { FLIPPED_ALIAS_KEYS: a, isCallExpression: o, isExpressionStatement: l, isMemberExpression: c, isNewExpression: u } = s;
        function p(e3) {
          const t3 = {};
          function n3(e4, n4) {
            const r3 = t3[e4];
            t3[e4] = r3 ? function(e5, t4, i2) {
              const s2 = r3(e5, t4, i2);
              return null == s2 ? n4(e5, t4, i2) : s2;
            } : n4;
          }
          for (const t4 of Object.keys(e3)) {
            const r3 = a[t4];
            if (r3) for (const i2 of r3) n3(i2, e3[t4]);
            else n3(t4, e3[t4]);
          }
          return t3;
        }
        const h = p(i), d = p(r2.nodes);
        function f(e3, t3, n3, r3) {
          const i2 = e3[t3.type];
          return i2 ? i2(t3, n3, r3) : null;
        }
        function y(e3) {
          return !!o(e3) || c(e3) && y(e3.object);
        }
        function m(e3, t3, n3) {
          if (!e3) return false;
          l(e3) && (e3 = e3.expression);
          const r3 = f(d, e3, t3);
          return "number" == typeof r3 && 0 != (r3 & n3);
        }
      }, 7363: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.ArrowFunctionExpression = function(e3, t3) {
          return m(t3) || ae(e3, t3);
        }, t2.AssignmentExpression = function(e3, t3) {
          return !!N(e3.left) || ae(e3, t3);
        }, t2.Binary = function(e3, t3) {
          if ("**" === e3.operator && c(t3, { operator: "**" })) return t3.left === e3;
          if (re(e3, t3)) return true;
          if (ie(e3, t3) || $(t3) || o(t3)) return true;
          if (l(t3)) {
            const n3 = t3.operator, r3 = te[n3], i2 = e3.operator, s2 = te[i2];
            if (r3 === s2 && t3.right === e3 && !C(t3) || r3 > s2) return true;
          }
        }, t2.BinaryExpression = function(e3, t3) {
          return "in" === e3.operator && (z(t3) || b(t3));
        }, t2.ClassExpression = function(e3, t3, n3) {
          return oe(n3, 5);
        }, t2.ConditionalExpression = ae, t2.DoExpression = function(e3, t3, n3) {
          return !e3.async && oe(n3, 1);
        }, t2.FunctionExpression = function(e3, t3, n3) {
          return oe(n3, 5);
        }, t2.FunctionTypeAnnotation = function(e3, t3, n3) {
          if (!(n3.length < 3)) return G(t3) || v(t3) || i(t3) || J(t3) && s(n3[n3.length - 3]);
        }, t2.Identifier = function(e3, t3, n3) {
          var r3;
          return !(null == (r3 = e3.extra) || !r3.parenthesized || !a(t3, { left: e3 }) || !x(t3.right) && !d(t3.right) || null != t3.right.id) || ("let" === e3.name ? oe(n3, w(t3, { object: e3, computed: true }) || k(t3, { object: e3, computed: true, optional: false }) ? 57 : 32) : "async" === e3.name && S(t3) && e3 === t3.left);
        }, t2.LogicalExpression = function(e3, t3) {
          if (ne(t3)) return true;
          switch (e3.operator) {
            case "||":
              return !!C(t3) && ("??" === t3.operator || "&&" === t3.operator);
            case "&&":
              return C(t3, { operator: "??" });
            case "??":
              return C(t3) && "??" !== t3.operator;
          }
        }, t2.NullableTypeAnnotation = function(e3, t3) {
          return i(t3);
        }, t2.ObjectExpression = function(e3, t3, n3) {
          return oe(n3, 3);
        }, t2.OptionalIndexedAccessType = function(e3, t3) {
          return A(t3, { objectType: e3 });
        }, t2.OptionalCallExpression = t2.OptionalMemberExpression = function(e3, t3) {
          return p(t3, { callee: e3 }) || w(t3, { object: e3 });
        }, t2.SequenceExpression = function(e3, t3) {
          return !(P(t3) || H(t3) || L(t3) || D(t3) && t3.test === e3 || Q(t3) && t3.test === e3 || E(t3) && t3.right === e3 || M(t3) && t3.discriminant === e3 || g(t3) && t3.expression === e3);
        }, t2.TSTypeAssertion = t2.TSSatisfiesExpression = t2.TSAsExpression = function() {
          return true;
        }, t2.TSInferType = function(e3, t3) {
          return B(t3) || K(t3);
        }, t2.TSInstantiationExpression = function(e3, t3) {
          return (p(t3) || F(t3) || O(t3) || R(t3)) && !!t3.typeParameters;
        }, t2.TSIntersectionType = t2.TSUnionType = function(e3, t3) {
          return B(t3) || K(t3) || U(t3) || Y(t3) || W(t3);
        }, t2.UnaryLike = se, t2.IntersectionTypeAnnotation = t2.UnionTypeAnnotation = function(e3, t3) {
          return i(t3) || I(t3) || v(t3) || G(t3);
        }, t2.UpdateExpression = function(e3, t3) {
          return ie(e3, t3) || re(e3, t3);
        }, t2.AwaitExpression = t2.YieldExpression = function(e3, t3) {
          return l(t3) || $(t3) || ie(e3, t3) || o(t3) && Z(e3) || y(t3) && e3 === t3.test || re(e3, t3);
        };
        var r2 = n2(6067);
        const { isArrayTypeAnnotation: i, isArrowFunctionExpression: s, isAssignmentExpression: a, isAwaitExpression: o, isBinary: l, isBinaryExpression: c, isUpdateExpression: u, isCallExpression: p, isClass: h, isClassExpression: d, isConditional: f, isConditionalExpression: y, isExportDeclaration: m, isExportDefaultDeclaration: T, isExpressionStatement: g, isFor: b, isForInStatement: E, isForOfStatement: S, isForStatement: P, isFunctionExpression: x, isIfStatement: D, isIndexedAccessType: A, isIntersectionTypeAnnotation: v, isLogicalExpression: C, isMemberExpression: w, isNewExpression: O, isNullableTypeAnnotation: I, isObjectPattern: N, isOptionalCallExpression: F, isOptionalMemberExpression: k, isReturnStatement: L, isSequenceExpression: _, isSwitchStatement: M, isTSArrayType: B, isTSAsExpression: j, isTSInstantiationExpression: R, isTSIntersectionType: U, isTSNonNullExpression: V, isTSOptionalType: K, isTSRestType: W, isTSTypeAssertion: X, isTSUnionType: Y, isTaggedTemplateExpression: q, isThrowStatement: H, isTypeAnnotation: J, isUnaryLike: $, isUnionTypeAnnotation: G, isVariableDeclarator: z, isWhileStatement: Q, isYieldExpression: Z, isTSSatisfiesExpression: ee } = r2, te = { "||": 0, "??": 0, "|>": 0, "&&": 1, "|": 2, "^": 3, "&": 4, "==": 5, "===": 5, "!=": 5, "!==": 5, "<": 6, ">": 6, "<=": 6, ">=": 6, in: 6, instanceof: 6, ">>": 7, "<<": 7, ">>>": 7, "+": 8, "-": 8, "*": 9, "/": 9, "%": 9, "**": 10 };
        function ne(e3) {
          return j(e3) || ee(e3) || X(e3);
        }
        const re = (e3, t3) => h(t3, { superClass: e3 }), ie = (e3, t3) => (w(t3) || k(t3)) && t3.object === e3 || (p(t3) || F(t3) || O(t3)) && t3.callee === e3 || q(t3) && t3.tag === e3 || V(t3);
        function se(e3, t3) {
          return ie(e3, t3) || c(t3, { operator: "**", left: e3 }) || re(e3, t3);
        }
        function ae(e3, t3) {
          return !!($(t3) || l(t3) || y(t3, { test: e3 }) || o(t3) || ne(t3)) || se(e3, t3);
        }
        function oe(e3, t3) {
          const n3 = 1 & t3, r3 = 2 & t3, i2 = 4 & t3, o2 = 8 & t3, c2 = 16 & t3, p2 = 32 & t3;
          let h2 = e3.length - 1;
          if (h2 <= 0) return;
          let d2 = e3[h2];
          h2--;
          let y2 = e3[h2];
          for (; h2 >= 0; ) {
            if (n3 && g(y2, { expression: d2 }) || i2 && T(y2, { declaration: d2 }) || r3 && s(y2, { body: d2 }) || o2 && P(y2, { init: d2 }) || c2 && E(y2, { left: d2 }) || p2 && S(y2, { left: d2 })) return true;
            if (!(h2 > 0 && (ie(d2, y2) && !O(y2) || _(y2) && y2.expressions[0] === d2 || u(y2) && !y2.prefix || f(y2, { test: d2 }) || l(y2, { left: d2 }) || a(y2, { left: d2 })))) return false;
            d2 = y2, h2--, y2 = e3[h2];
          }
          return false;
        }
      }, 9750: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.nodes = void 0;
        var r2 = n2(6067);
        const { FLIPPED_ALIAS_KEYS: i, isArrayExpression: s, isAssignmentExpression: a, isBinary: o, isBlockStatement: l, isCallExpression: c, isFunction: u, isIdentifier: p, isLiteral: h, isMemberExpression: d, isObjectExpression: f, isOptionalCallExpression: y, isOptionalMemberExpression: m, isStringLiteral: T } = r2;
        function g(e3, t3) {
          return e3 ? (d(e3) || m(e3) ? (g(e3.object, t3), e3.computed && g(e3.property, t3)) : o(e3) || a(e3) ? (g(e3.left, t3), g(e3.right, t3)) : c(e3) || y(e3) ? (t3.hasCall = true, g(e3.callee, t3)) : u(e3) ? t3.hasFunction = true : p(e3) && (t3.hasHelper = t3.hasHelper || e3.callee && E(e3.callee)), t3) : t3;
        }
        function b(e3) {
          return g(e3, { hasCall: false, hasFunction: false, hasHelper: false });
        }
        function E(e3) {
          return !!e3 && (d(e3) ? E(e3.object) || E(e3.property) : p(e3) ? "require" === e3.name || 95 === e3.name.charCodeAt(0) : c(e3) ? E(e3.callee) : !(!o(e3) && !a(e3)) && (p(e3.left) && E(e3.left) || E(e3.right)));
        }
        function S(e3) {
          return h(e3) || f(e3) || s(e3) || p(e3) || d(e3);
        }
        const P = { AssignmentExpression(e3) {
          const t3 = b(e3.right);
          if (t3.hasCall && t3.hasHelper || t3.hasFunction) return t3.hasFunction ? 3 : 2;
        }, SwitchCase: (e3, t3) => (e3.consequent.length || t3.cases[0] === e3 ? 1 : 0) | (e3.consequent.length || t3.cases[t3.cases.length - 1] !== e3 ? 0 : 2), LogicalExpression(e3) {
          if (u(e3.left) || u(e3.right)) return 2;
        }, Literal(e3) {
          if (T(e3) && "use strict" === e3.value) return 2;
        }, CallExpression(e3) {
          if (u(e3.callee) || E(e3)) return 3;
        }, OptionalCallExpression(e3) {
          if (u(e3.callee)) return 3;
        }, VariableDeclaration(e3) {
          for (let t3 = 0; t3 < e3.declarations.length; t3++) {
            const n3 = e3.declarations[t3];
            let r3 = E(n3.id) && !S(n3.init);
            if (!r3 && n3.init) {
              const e4 = b(n3.init);
              r3 = E(n3.init) && e4.hasCall || e4.hasFunction;
            }
            if (r3) return 3;
          }
        }, IfStatement(e3) {
          if (l(e3.consequent)) return 3;
        } };
        t2.nodes = P, P.ObjectProperty = P.ObjectTypeProperty = P.ObjectMethod = function(e3, t3) {
          if (t3.properties[0] === e3) return 1;
        }, P.ObjectTypeCallProperty = function(e3, t3) {
          var n3;
          if (t3.callProperties[0] === e3 && (null == (n3 = t3.properties) || !n3.length)) return 1;
        }, P.ObjectTypeIndexer = function(e3, t3) {
          var n3, r3;
          if (!(t3.indexers[0] !== e3 || null != (n3 = t3.properties) && n3.length || null != (r3 = t3.callProperties) && r3.length)) return 1;
        }, P.ObjectTypeInternalSlot = function(e3, t3) {
          var n3, r3, i2;
          if (!(t3.internalSlots[0] !== e3 || null != (n3 = t3.properties) && n3.length || null != (r3 = t3.callProperties) && r3.length || null != (i2 = t3.indexers) && i2.length)) return 1;
        }, [["Function", true], ["Class", true], ["Loop", true], ["LabeledStatement", true], ["SwitchStatement", true], ["TryStatement", true]].forEach(function([e3, t3]) {
          [e3].concat(i[e3] || []).forEach(function(e4) {
            const n3 = t3 ? 3 : 0;
            P[e4] = () => n3;
          });
        });
      }, 516: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var r2 = n2(8726), i = n2(7533), s = n2(6067), a = n2(4236);
        const { isFunction: o, isStatement: l, isClassBody: c, isTSInterfaceBody: u, isTSEnumDeclaration: p } = s, h = /e/i, d = /\.0+$/, f = /^0[box]/, y = /^\s*[@#]__PURE__\s*$/, m = /[\n\r\u2028\u2029]/, T = /\*\//, { needsParens: g } = i;
        class b {
          constructor(e3, t3) {
            this.inForStatementInitCounter = 0, this._printStack = [], this._indent = 0, this._indentChar = 0, this._indentRepeat = 0, this._insideAux = false, this._parenPushNewlineState = null, this._noLineTerminator = false, this._printAuxAfterOnNextUserNode = false, this._printedComments = /* @__PURE__ */ new Set(), this._endsWithInteger = false, this._endsWithWord = false, this._lastCommentLine = 0, this._endsWithInnerRaw = false, this._indentInnerComments = true, this.format = e3, this._buf = new r2.default(t3), this._indentChar = e3.indent.style.charCodeAt(0), this._indentRepeat = e3.indent.style.length, this._inputMap = null == t3 ? void 0 : t3._inputMap;
          }
          generate(e3) {
            return this.print(e3), this._maybeAddAuxComment(), this._buf.get();
          }
          indent() {
            this.format.compact || this.format.concise || this._indent++;
          }
          dedent() {
            this.format.compact || this.format.concise || this._indent--;
          }
          semicolon(e3 = false) {
            this._maybeAddAuxComment(), e3 ? this._appendChar(59) : this._queue(59), this._noLineTerminator = false;
          }
          rightBrace(e3) {
            this.format.minified && this._buf.removeLastSemicolon(), this.sourceWithOffset("end", e3.loc, -1), this.tokenChar(125);
          }
          rightParens(e3) {
            this.sourceWithOffset("end", e3.loc, -1), this.tokenChar(41);
          }
          space(e3 = false) {
            if (!this.format.compact) {
              if (e3) this._space();
              else if (this._buf.hasContent()) {
                const e4 = this.getLastChar();
                32 !== e4 && 10 !== e4 && this._space();
              }
            }
          }
          word(e3, t3 = false) {
            this._maybePrintInnerComments(), (this._endsWithWord || 47 === e3.charCodeAt(0) && this.endsWith(47)) && this._space(), this._maybeAddAuxComment(), this._append(e3, false), this._endsWithWord = true, this._noLineTerminator = t3;
          }
          number(e3) {
            this.word(e3), this._endsWithInteger = Number.isInteger(+e3) && !f.test(e3) && !h.test(e3) && !d.test(e3) && 46 !== e3.charCodeAt(e3.length - 1);
          }
          token(e3, t3 = false) {
            this._maybePrintInnerComments();
            const n3 = this.getLastChar(), r3 = e3.charCodeAt(0);
            (33 === n3 && ("--" === e3 || 61 === r3) || 43 === r3 && 43 === n3 || 45 === r3 && 45 === n3 || 46 === r3 && this._endsWithInteger) && this._space(), this._maybeAddAuxComment(), this._append(e3, t3), this._noLineTerminator = false;
          }
          tokenChar(e3) {
            this._maybePrintInnerComments();
            const t3 = this.getLastChar();
            (43 === e3 && 43 === t3 || 45 === e3 && 45 === t3 || 46 === e3 && this._endsWithInteger) && this._space(), this._maybeAddAuxComment(), this._appendChar(e3), this._noLineTerminator = false;
          }
          newline(e3 = 1, t3) {
            if (!(e3 <= 0)) {
              if (!t3) {
                if (this.format.retainLines || this.format.compact) return;
                if (this.format.concise) return void this.space();
              }
              e3 > 2 && (e3 = 2), e3 -= this._buf.getNewlineCount();
              for (let t4 = 0; t4 < e3; t4++) this._newline();
            }
          }
          endsWith(e3) {
            return this.getLastChar() === e3;
          }
          getLastChar() {
            return this._buf.getLastChar();
          }
          endsWithCharAndNewline() {
            return this._buf.endsWithCharAndNewline();
          }
          removeTrailingNewline() {
            this._buf.removeTrailingNewline();
          }
          exactSource(e3, t3) {
            e3 ? (this._catchUp("start", e3), this._buf.exactSource(e3, t3)) : t3();
          }
          source(e3, t3) {
            t3 && (this._catchUp(e3, t3), this._buf.source(e3, t3));
          }
          sourceWithOffset(e3, t3, n3) {
            t3 && (this._catchUp(e3, t3), this._buf.sourceWithOffset(e3, t3, n3));
          }
          withSource(e3, t3, n3) {
            t3 ? (this._catchUp(e3, t3), this._buf.withSource(e3, t3, n3)) : n3();
          }
          sourceIdentifierName(e3, t3) {
            if (!this._buf._canMarkIdName) return;
            const n3 = this._buf._sourcePosition;
            n3.identifierNamePos = t3, n3.identifierName = e3;
          }
          _space() {
            this._queue(32);
          }
          _newline() {
            this._queue(10);
          }
          _append(e3, t3) {
            this._maybeAddParen(e3), this._maybeIndent(e3.charCodeAt(0)), this._buf.append(e3, t3), this._endsWithWord = false, this._endsWithInteger = false;
          }
          _appendChar(e3) {
            this._maybeAddParenChar(e3), this._maybeIndent(e3), this._buf.appendChar(e3), this._endsWithWord = false, this._endsWithInteger = false;
          }
          _queue(e3) {
            this._maybeAddParenChar(e3), this._maybeIndent(e3), this._buf.queue(e3), this._endsWithWord = false, this._endsWithInteger = false;
          }
          _maybeIndent(e3) {
            this._indent && 10 !== e3 && this.endsWith(10) && this._buf.queueIndentation(this._indentChar, this._getIndent());
          }
          _shouldIndent(e3) {
            if (this._indent && 10 !== e3 && this.endsWith(10)) return true;
          }
          _maybeAddParenChar(e3) {
            const t3 = this._parenPushNewlineState;
            t3 && 32 !== e3 && (10 === e3 ? (this.tokenChar(40), this.indent(), t3.printed = true) : this._parenPushNewlineState = null);
          }
          _maybeAddParen(e3) {
            const t3 = this._parenPushNewlineState;
            if (!t3) return;
            const n3 = e3.length;
            let r3;
            for (r3 = 0; r3 < n3 && 32 === e3.charCodeAt(r3); r3++) continue;
            if (r3 === n3) return;
            const i2 = e3.charCodeAt(r3);
            if (10 !== i2) {
              if (47 !== i2 || r3 + 1 === n3) return void (this._parenPushNewlineState = null);
              const t4 = e3.charCodeAt(r3 + 1);
              if (42 === t4) {
                if (y.test(e3.slice(r3 + 2, n3 - 2))) return;
              } else if (47 !== t4) return void (this._parenPushNewlineState = null);
            }
            this.tokenChar(40), this.indent(), t3.printed = true;
          }
          catchUp(e3) {
            if (!this.format.retainLines) return;
            const t3 = e3 - this._buf.getCurrentLine();
            for (let e4 = 0; e4 < t3; e4++) this._newline();
          }
          _catchUp(e3, t3) {
            var n3;
            if (!this.format.retainLines) return;
            const r3 = null == t3 || null == (n3 = t3[e3]) ? void 0 : n3.line;
            if (null != r3) {
              const e4 = r3 - this._buf.getCurrentLine();
              for (let t4 = 0; t4 < e4; t4++) this._newline();
            }
          }
          _getIndent() {
            return this._indentRepeat * this._indent;
          }
          printTerminatorless(e3, t3, n3) {
            if (n3) this._noLineTerminator = true, this.print(e3, t3);
            else {
              const n4 = { printed: false };
              this._parenPushNewlineState = n4, this.print(e3, t3), n4.printed && (this.dedent(), this.newline(), this.tokenChar(41));
            }
          }
          print(e3, t3, n3, r3, i2) {
            var s2;
            if (!e3) return;
            this._endsWithInnerRaw = false;
            const a2 = e3.type, o2 = this.format, l2 = o2.concise;
            e3._compact && (o2.concise = true);
            const c2 = this[a2];
            if (void 0 === c2) throw new ReferenceError(`unknown node of type ${JSON.stringify(a2)} with constructor ${JSON.stringify(e3.constructor.name)}`);
            this._printStack.push(e3);
            const u2 = this._insideAux;
            this._insideAux = null == e3.loc, this._maybeAddAuxComment(this._insideAux && !u2);
            const p2 = i2 || o2.retainFunctionParens && "FunctionExpression" === a2 && (null == (s2 = e3.extra) ? void 0 : s2.parenthesized) || g(e3, t3, this._printStack);
            p2 && (this.tokenChar(40), this._endsWithInnerRaw = false), this._lastCommentLine = 0, this._printLeadingComments(e3, t3);
            const h2 = "Program" === a2 || "File" === a2 ? null : e3.loc;
            this.exactSource(h2, c2.bind(this, e3, t3)), p2 ? (this._printTrailingComments(e3, t3), this.tokenChar(41), this._noLineTerminator = n3) : n3 && !this._noLineTerminator ? (this._noLineTerminator = true, this._printTrailingComments(e3, t3)) : this._printTrailingComments(e3, t3, r3), this._printStack.pop(), o2.concise = l2, this._insideAux = u2, this._endsWithInnerRaw = false;
          }
          _maybeAddAuxComment(e3) {
            e3 && this._printAuxBeforeComment(), this._insideAux || this._printAuxAfterComment();
          }
          _printAuxBeforeComment() {
            if (this._printAuxAfterOnNextUserNode) return;
            this._printAuxAfterOnNextUserNode = true;
            const e3 = this.format.auxiliaryCommentBefore;
            e3 && this._printComment({ type: "CommentBlock", value: e3 }, 0);
          }
          _printAuxAfterComment() {
            if (!this._printAuxAfterOnNextUserNode) return;
            this._printAuxAfterOnNextUserNode = false;
            const e3 = this.format.auxiliaryCommentAfter;
            e3 && this._printComment({ type: "CommentBlock", value: e3 }, 0);
          }
          getPossibleRaw(e3) {
            const t3 = e3.extra;
            if (null != (null == t3 ? void 0 : t3.raw) && null != t3.rawValue && e3.value === t3.rawValue) return t3.raw;
          }
          printJoin(e3, t3, n3 = {}) {
            if (null == e3 || !e3.length) return;
            let { indent: r3 } = n3;
            if (null == r3 && this.format.retainLines) {
              var i2;
              const t4 = null == (i2 = e3[0].loc) ? void 0 : i2.start.line;
              null != t4 && t4 !== this._buf.getCurrentLine() && (r3 = true);
            }
            r3 && this.indent();
            const s2 = { addNewlines: n3.addNewlines, nextNodeStartLine: 0 }, a2 = n3.separator ? n3.separator.bind(this) : null, o2 = e3.length;
            for (let r4 = 0; r4 < o2; r4++) {
              const i3 = e3[r4];
              if (i3 && (n3.statement && this._printNewline(0 === r4, s2), this.print(i3, t3, void 0, n3.trailingCommentsLineOffset || 0), null == n3.iterator || n3.iterator(i3, r4), r4 < o2 - 1 && (null == a2 || a2()), n3.statement)) if (r4 + 1 === o2) this.newline(1);
              else {
                var l2;
                const t4 = e3[r4 + 1];
                s2.nextNodeStartLine = (null == (l2 = t4.loc) ? void 0 : l2.start.line) || 0, this._printNewline(true, s2);
              }
            }
            r3 && this.dedent();
          }
          printAndIndentOnComments(e3, t3) {
            const n3 = e3.leadingComments && e3.leadingComments.length > 0;
            n3 && this.indent(), this.print(e3, t3), n3 && this.dedent();
          }
          printBlock(e3) {
            const t3 = e3.body;
            "EmptyStatement" !== t3.type && this.space(), this.print(t3, e3);
          }
          _printTrailingComments(e3, t3, n3) {
            const { innerComments: r3, trailingComments: i2 } = e3;
            null != r3 && r3.length && this._printComments(2, r3, e3, t3, n3), null != i2 && i2.length && this._printComments(2, i2, e3, t3, n3);
          }
          _printLeadingComments(e3, t3) {
            const n3 = e3.leadingComments;
            null != n3 && n3.length && this._printComments(0, n3, e3, t3);
          }
          _maybePrintInnerComments() {
            this._endsWithInnerRaw && this.printInnerComments(), this._endsWithInnerRaw = true, this._indentInnerComments = true;
          }
          printInnerComments() {
            const e3 = this._printStack[this._printStack.length - 1], t3 = e3.innerComments;
            if (null == t3 || !t3.length) return;
            const n3 = this.endsWith(32), r3 = this._indentInnerComments, i2 = this._printedComments.size;
            r3 && this.indent(), this._printComments(1, t3, e3), n3 && i2 !== this._printedComments.size && this.space(), r3 && this.dedent();
          }
          noIndentInnerCommentsHere() {
            this._indentInnerComments = false;
          }
          printSequence(e3, t3, n3 = {}) {
            n3.statement = true, null != n3.indent || (n3.indent = false), this.printJoin(e3, t3, n3);
          }
          printList(e3, t3, n3 = {}) {
            null == n3.separator && (n3.separator = S), this.printJoin(e3, t3, n3);
          }
          _printNewline(e3, t3) {
            const n3 = this.format;
            if (n3.retainLines || n3.compact) return;
            if (n3.concise) return void this.space();
            if (!e3) return;
            const r3 = t3.nextNodeStartLine, i2 = this._lastCommentLine;
            if (r3 > 0 && i2 > 0) {
              const e4 = r3 - i2;
              if (e4 >= 0) return void this.newline(e4 || 1);
            }
            this._buf.hasContent() && this.newline(1);
          }
          _shouldPrintComment(e3) {
            return e3.ignore || this._printedComments.has(e3) ? 0 : this._noLineTerminator && (m.test(e3.value) || T.test(e3.value)) ? 2 : (this._printedComments.add(e3), this.format.shouldPrintComment(e3.value) ? 1 : 0);
          }
          _printComment(e3, t3) {
            const n3 = this._noLineTerminator, r3 = "CommentBlock" === e3.type, i2 = r3 && 1 !== t3 && !this._noLineTerminator;
            i2 && this._buf.hasContent() && 2 !== t3 && this.newline(1);
            const s2 = this.getLastChar();
            let a2;
            if (91 !== s2 && 123 !== s2 && this.space(), r3) {
              if (a2 = `/*${e3.value}*/`, this.format.indent.adjustMultilineComment) {
                var o2;
                const t4 = null == (o2 = e3.loc) ? void 0 : o2.start.column;
                if (t4) {
                  const e4 = new RegExp("\\n\\s{1," + t4 + "}", "g");
                  a2 = a2.replace(e4, "\n");
                }
                let n4 = this.format.retainLines ? 0 : this._buf.getCurrentColumn();
                (this._shouldIndent(47) || this.format.retainLines) && (n4 += this._getIndent()), a2 = a2.replace(/\n(?!$)/g, `
${" ".repeat(n4)}`);
              }
            } else a2 = n3 ? `/*${e3.value}*/` : `//${e3.value}`;
            this.endsWith(47) && this._space(), this.source("start", e3.loc), this._append(a2, r3), r3 || n3 || this.newline(1, true), i2 && 3 !== t3 && this.newline(1);
          }
          _printComments(e3, t3, n3, r3, i2 = 0) {
            const s2 = n3.loc, a2 = t3.length;
            let h2 = !!s2;
            const d2 = h2 ? s2.start.line : 0, f2 = h2 ? s2.end.line : 0;
            let y2 = 0, T2 = 0;
            const g2 = this._noLineTerminator ? function() {
            } : this.newline.bind(this);
            for (let s3 = 0; s3 < a2; s3++) {
              const b2 = t3[s3], E2 = this._shouldPrintComment(b2);
              if (2 === E2) {
                h2 = false;
                break;
              }
              if (h2 && b2.loc && 1 === E2) {
                const t4 = b2.loc.start.line, n4 = b2.loc.end.line;
                if (0 === e3) {
                  let e4 = 0;
                  0 === s3 ? !this._buf.hasContent() || "CommentLine" !== b2.type && t4 == n4 || (e4 = T2 = 1) : e4 = t4 - y2, y2 = n4, g2(e4), this._printComment(b2, 1), s3 + 1 === a2 && (g2(Math.max(d2 - y2, T2)), y2 = d2);
                } else if (1 === e3) {
                  const e4 = t4 - (0 === s3 ? d2 : y2);
                  y2 = n4, g2(e4), this._printComment(b2, 1), s3 + 1 === a2 && (g2(Math.min(1, f2 - y2)), y2 = f2);
                } else {
                  const e4 = t4 - (0 === s3 ? f2 - i2 : y2);
                  y2 = n4, g2(e4), this._printComment(b2, 1);
                }
              } else {
                if (h2 = false, 1 !== E2) continue;
                if (1 === a2) {
                  const t4 = b2.loc ? b2.loc.start.line === b2.loc.end.line : !m.test(b2.value), i3 = t4 && !l(n3) && !c(r3) && !u(r3) && !p(r3);
                  0 === e3 ? this._printComment(b2, i3 && "ObjectExpression" !== n3.type || t4 && o(r3, { body: n3 }) ? 1 : 0) : i3 && 2 === e3 ? this._printComment(b2, 1) : this._printComment(b2, 0);
                } else 1 !== e3 || "ObjectExpression" === n3.type && n3.properties.length > 1 || "ClassBody" === n3.type || "TSInterfaceBody" === n3.type ? this._printComment(b2, 0) : this._printComment(b2, 0 === s3 ? 2 : s3 === a2 - 1 ? 3 : 0);
              }
            }
            2 === e3 && h2 && y2 && (this._lastCommentLine = y2);
          }
        }
        Object.assign(b.prototype, a), b.prototype.Noop = function() {
        };
        var E = b;
        function S() {
          this.tokenChar(44), this.space();
        }
        t2.default = E;
      }, 2564: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var r2 = n2(2509), i = n2(3446);
        t2.default = class {
          constructor(e3, t3) {
            var n3;
            this._map = void 0, this._rawMappings = void 0, this._sourceFileName = void 0, this._lastGenLine = 0, this._lastSourceLine = 0, this._lastSourceColumn = 0, this._inputMap = void 0;
            const s = this._map = new r2.GenMapping({ sourceRoot: e3.sourceRoot });
            if (this._sourceFileName = null == (n3 = e3.sourceFileName) ? void 0 : n3.replace(/\\/g, "/"), this._rawMappings = void 0, e3.inputSourceMap) {
              this._inputMap = new i.TraceMap(e3.inputSourceMap);
              const t4 = this._inputMap.resolvedSources;
              if (t4.length) for (let e4 = 0; e4 < t4.length; e4++) {
                var a;
                (0, r2.setSourceContent)(s, t4[e4], null == (a = this._inputMap.sourcesContent) ? void 0 : a[e4]);
              }
            }
            if ("string" != typeof t3 || e3.inputSourceMap) {
              if ("object" == typeof t3) for (const e4 of Object.keys(t3)) (0, r2.setSourceContent)(s, e4.replace(/\\/g, "/"), t3[e4]);
            } else (0, r2.setSourceContent)(s, this._sourceFileName, t3);
          }
          get() {
            return (0, r2.toEncodedMap)(this._map);
          }
          getDecoded() {
            return (0, r2.toDecodedMap)(this._map);
          }
          getRawMappings() {
            return this._rawMappings || (this._rawMappings = (0, r2.allMappings)(this._map));
          }
          mark(e3, t3, n3, s, a, o) {
            var l;
            let c;
            if (this._rawMappings = void 0, null != t3) if (this._inputMap) {
              if (c = (0, i.originalPositionFor)(this._inputMap, { line: t3, column: n3 }), !c.name && a) {
                const e4 = (0, i.originalPositionFor)(this._inputMap, a);
                e4.name && (s = e4.name);
              }
            } else c = { source: (null == o ? void 0 : o.replace(/\\/g, "/")) || this._sourceFileName, line: t3, column: n3 };
            (0, r2.maybeAddMapping)(this._map, { name: s, generated: e3, source: null == (l = c) ? void 0 : l.source, original: c });
          }
        };
      }, 4705: (e2, t2) => {
        "use strict";
        function n2(e3) {
          const { context: t3, node: n3 } = e3;
          if (n3.computed && t3.maybeQueue(e3.get("key")), n3.decorators) for (const n4 of e3.get("decorators")) t3.maybeQueue(n4);
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0, t2.requeueComputedKeyAndDecorators = n2, t2.skipAllButComputedKey = function(e3) {
          e3.skip(), e3.node.computed && e3.context.maybeQueue(e3.get("key"));
        };
        var r2 = { FunctionParent(e3) {
          e3.isArrowFunctionExpression() || (e3.skip(), e3.isMethod() && n2(e3));
        }, Property(e3) {
          e3.isObjectProperty() || (e3.skip(), n2(e3));
        } };
        t2.default = r2;
      }, 2023: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function({ node: e3, parent: t3, scope: n3, id: r3 }, i2 = false, D = false) {
          if (e3.id) return;
          if (!y(t3) && !f(t3, { kind: "method" }) || t3.computed && !h(t3.key)) {
            if (b(t3)) {
              if (r3 = t3.id, p(r3) && !i2) {
                const t4 = n3.parent.getBinding(r3.name);
                if (t4 && t4.constant && n3.getBinding(r3.name) === t4) return e3.id = a(r3), void (e3.id[s] = true);
              }
            } else if (l(t3, { operator: "=" })) r3 = t3.left;
            else if (!r3) return;
          } else r3 = t3.key;
          let A;
          if (r3 && h(r3) ? A = function(e4) {
            return d(e4) ? "null" : m(e4) ? `_${e4.pattern}_${e4.flags}` : g(e4) ? e4.quasis.map((e5) => e5.value.raw).join("") : void 0 !== e4.value ? e4.value + "" : "";
          }(r3) : r3 && p(r3) && (A = r3.name), void 0 === A) return;
          if (!D && u(e3) && /[\uD800-\uDFFF]/.test(A)) return;
          A = E(A);
          const v = o(A);
          return v[s] = true, function(e4, t4, n4, r4) {
            if (e4.selfReference) {
              if (!r4.hasBinding(n4.name) || r4.hasGlobal(n4.name)) {
                if (!u(t4)) return;
                let e5 = S;
                t4.generator && (e5 = P);
                const i3 = e5({ FUNCTION: t4, FUNCTION_ID: n4, FUNCTION_KEY: r4.generateUidIdentifier(n4.name) }).expression, s2 = i3.callee.body.body[0].params;
                for (let e6 = 0, n5 = function(e7) {
                  const t5 = e7.params.findIndex((e8) => c(e8) || T(e8));
                  return -1 === t5 ? e7.params.length : t5;
                }(t4); e6 < n5; e6++) s2.push(r4.generateUidIdentifier("x"));
                return i3;
              }
              r4.rename(n4.name);
            }
            t4.id = n4, r4.getProgramParent().references[n4.name] = true;
          }(function(e4, t4, n4) {
            const r4 = { selfAssignment: false, selfReference: false, outerDeclar: n4.getBindingIdentifier(t4), name: t4 }, i3 = n4.getOwnBinding(t4);
            return i3 ? "param" === i3.kind && (r4.selfReference = true) : (r4.outerDeclar || n4.hasGlobal(t4)) && n4.traverse(e4, x, r4), r4;
          }(e3, A, n3), e3, v, n3) || e3;
        };
        var r2 = n2(6849), i = n2(6067);
        const { NOT_LOCAL_BINDING: s, cloneNode: a, identifier: o, isAssignmentExpression: l, isAssignmentPattern: c, isFunction: u, isIdentifier: p, isLiteral: h, isNullLiteral: d, isObjectMethod: f, isObjectProperty: y, isRegExpLiteral: m, isRestElement: T, isTemplateLiteral: g, isVariableDeclarator: b, toBindingIdentifierName: E } = i, S = r2.default.statement("\n  (function (FUNCTION_KEY) {\n    function FUNCTION_ID() {\n      return FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    }\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n"), P = r2.default.statement("\n  (function (FUNCTION_KEY) {\n    function* FUNCTION_ID() {\n      return yield* FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    };\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n"), x = { "ReferencedIdentifier|BindingIdentifier"(e3, t3) {
          e3.node.name === t3.name && e3.scope.getBindingIdentifier(t3.name) === t3.outerDeclar && (t3.selfReference = true, e3.stop());
        } };
      }, 7438: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, n3 = "var") {
          e3.traverse(o, { kind: n3, emit: t3 });
        };
        var r2 = n2(6067);
        const { assignmentExpression: i, expressionStatement: s, identifier: a } = r2, o = { Scope(e3, t3) {
          "let" === t3.kind && e3.skip();
        }, FunctionParent(e3) {
          e3.skip();
        }, VariableDeclaration(e3, t3) {
          if (t3.kind && e3.node.kind !== t3.kind) return;
          const n3 = [], r3 = e3.get("declarations");
          let o2;
          for (const e4 of r3) {
            o2 = e4.node.id, e4.node.init && n3.push(s(i("=", e4.node.id, e4.node.init)));
            for (const n4 of Object.keys(e4.getBindingIdentifiers())) t3.emit(a(n4), n4, null !== e4.node.init);
          }
          e3.parentPath.isFor({ left: e3.node }) ? e3.replaceWith(o2) : e3.replaceWithMultiple(n3);
        } };
      }, 3472: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
          if (!e3.isExportDeclaration() || e3.isExportAllDeclaration()) throw new Error("Only default and named export declarations can be split.");
          if (e3.isExportDefaultDeclaration()) {
            const t4 = e3.get("declaration"), n4 = t4.isFunctionDeclaration() || t4.isClassDeclaration(), r4 = t4.isFunctionExpression() || t4.isClassExpression(), u2 = t4.isScope() ? t4.scope.parent : t4.scope;
            let p = t4.node.id, h = false;
            p ? r4 && u2.hasBinding(p.name) && (h = true, p = u2.generateUidIdentifier(p.name)) : (h = true, p = u2.generateUidIdentifier("default"), (n4 || r4) && (t4.node.id = i(p)));
            const d = n4 ? t4.node : l("var", [c(i(p), t4.node)]), f = s(null, [a(i(p), o("default"))]);
            return e3.insertAfter(f), e3.replaceWith(d), h && u2.registerDeclaration(e3), e3;
          }
          if (e3.get("specifiers").length > 0) throw new Error("It doesn't make sense to split exported specifiers.");
          const t3 = e3.get("declaration"), n3 = t3.getOuterBindingIdentifiers(), r3 = Object.keys(n3).map((e4) => a(o(e4), o(e4))), u = s(null, r3);
          return e3.insertAfter(u), e3.replaceWith(t3.node), e3;
        };
        var r2 = n2(6067);
        const { cloneNode: i, exportNamedDeclaration: s, exportSpecifier: a, identifier: o, variableDeclaration: l, variableDeclarator: c } = r2;
      }, 7648: (e2, t2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.readCodePoint = c, t2.readInt = l, t2.readStringContents = function(e3, t3, n3, r3, i2, o2) {
          const l2 = n3, c2 = r3, u = i2;
          let p = "", h = null, d = n3;
          const { length: f } = t3;
          for (; ; ) {
            if (n3 >= f) {
              o2.unterminated(l2, c2, u), p += t3.slice(d, n3);
              break;
            }
            const y = t3.charCodeAt(n3);
            if (s(e3, y, t3, n3)) {
              p += t3.slice(d, n3);
              break;
            }
            if (92 === y) {
              p += t3.slice(d, n3);
              const s2 = a(t3, n3, r3, i2, "template" === e3, o2);
              null !== s2.ch || h ? p += s2.ch : h = { pos: n3, lineStart: r3, curLine: i2 }, { pos: n3, lineStart: r3, curLine: i2 } = s2, d = n3;
            } else 8232 === y || 8233 === y ? (++i2, r3 = ++n3) : 10 === y || 13 === y ? "template" === e3 ? (p += t3.slice(d, n3) + "\n", ++n3, 13 === y && 10 === t3.charCodeAt(n3) && ++n3, ++i2, d = r3 = n3) : o2.unterminated(l2, c2, u) : ++n3;
          }
          return { pos: n3, str: p, firstInvalidLoc: h, lineStart: r3, curLine: i2, containsInvalid: !!h };
        };
        var n2 = function(e3) {
          return e3 >= 48 && e3 <= 57;
        };
        const r2 = { decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]), hex: /* @__PURE__ */ new Set([46, 88, 95, 120]) }, i = { bin: (e3) => 48 === e3 || 49 === e3, oct: (e3) => e3 >= 48 && e3 <= 55, dec: (e3) => e3 >= 48 && e3 <= 57, hex: (e3) => e3 >= 48 && e3 <= 57 || e3 >= 65 && e3 <= 70 || e3 >= 97 && e3 <= 102 };
        function s(e3, t3, n3, r3) {
          return "template" === e3 ? 96 === t3 || 36 === t3 && 123 === n3.charCodeAt(r3 + 1) : t3 === ("double" === e3 ? 34 : 39);
        }
        function a(e3, t3, n3, r3, i2, s2) {
          const a2 = !i2;
          t3++;
          const l2 = (e4) => ({ pos: t3, ch: e4, lineStart: n3, curLine: r3 }), u = e3.charCodeAt(t3++);
          switch (u) {
            case 110:
              return l2("\n");
            case 114:
              return l2("\r");
            case 120: {
              let i3;
              return { code: i3, pos: t3 } = o(e3, t3, n3, r3, 2, false, a2, s2), l2(null === i3 ? null : String.fromCharCode(i3));
            }
            case 117: {
              let i3;
              return { code: i3, pos: t3 } = c(e3, t3, n3, r3, a2, s2), l2(null === i3 ? null : String.fromCodePoint(i3));
            }
            case 116:
              return l2("	");
            case 98:
              return l2("\b");
            case 118:
              return l2("\v");
            case 102:
              return l2("\f");
            case 13:
              10 === e3.charCodeAt(t3) && ++t3;
            case 10:
              n3 = t3, ++r3;
            case 8232:
            case 8233:
              return l2("");
            case 56:
            case 57:
              if (i2) return l2(null);
              s2.strictNumericEscape(t3 - 1, n3, r3);
            default:
              if (u >= 48 && u <= 55) {
                const a3 = t3 - 1;
                let o2 = e3.slice(a3, t3 + 2).match(/^[0-7]+/)[0], c2 = parseInt(o2, 8);
                c2 > 255 && (o2 = o2.slice(0, -1), c2 = parseInt(o2, 8)), t3 += o2.length - 1;
                const u2 = e3.charCodeAt(t3);
                if ("0" !== o2 || 56 === u2 || 57 === u2) {
                  if (i2) return l2(null);
                  s2.strictNumericEscape(a3, n3, r3);
                }
                return l2(String.fromCharCode(c2));
              }
              return l2(String.fromCharCode(u));
          }
        }
        function o(e3, t3, n3, r3, i2, s2, a2, o2) {
          const c2 = t3;
          let u;
          return { n: u, pos: t3 } = l(e3, t3, n3, r3, 16, i2, s2, false, o2, !a2), null === u && (a2 ? o2.invalidEscapeSequence(c2, n3, r3) : t3 = c2 - 1), { code: u, pos: t3 };
        }
        function l(e3, t3, s2, a2, o2, l2, c2, u, p, h) {
          const d = t3, f = 16 === o2 ? r2.hex : r2.decBinOct, y = 16 === o2 ? i.hex : 10 === o2 ? i.dec : 8 === o2 ? i.oct : i.bin;
          let m = false, T = 0;
          for (let r3 = 0, i2 = null == l2 ? 1 / 0 : l2; r3 < i2; ++r3) {
            const r4 = e3.charCodeAt(t3);
            let i3;
            if (95 !== r4 || "bail" === u) {
              if (i3 = r4 >= 97 ? r4 - 97 + 10 : r4 >= 65 ? r4 - 65 + 10 : n2(r4) ? r4 - 48 : 1 / 0, i3 >= o2) {
                if (i3 <= 9 && h) return { n: null, pos: t3 };
                if (i3 <= 9 && p.invalidDigit(t3, s2, a2, o2)) i3 = 0;
                else {
                  if (!c2) break;
                  i3 = 0, m = true;
                }
              }
              ++t3, T = T * o2 + i3;
            } else {
              const n3 = e3.charCodeAt(t3 - 1), r5 = e3.charCodeAt(t3 + 1);
              if (u) {
                if (Number.isNaN(r5) || !y(r5) || f.has(n3) || f.has(r5)) {
                  if (h) return { n: null, pos: t3 };
                  p.unexpectedNumericSeparator(t3, s2, a2);
                }
              } else {
                if (h) return { n: null, pos: t3 };
                p.numericSeparatorInEscapeSequence(t3, s2, a2);
              }
              ++t3;
            }
          }
          return t3 === d || null != l2 && t3 - d !== l2 || m ? { n: null, pos: t3 } : { n: T, pos: t3 };
        }
        function c(e3, t3, n3, r3, i2, s2) {
          let a2;
          if (123 === e3.charCodeAt(t3)) {
            if (++t3, { code: a2, pos: t3 } = o(e3, t3, n3, r3, e3.indexOf("}", t3) - t3, true, i2, s2), ++t3, null !== a2 && a2 > 1114111) {
              if (!i2) return { code: null, pos: t3 };
              s2.invalidCodePoint(t3, n3, r3);
            }
          } else ({ code: a2, pos: t3 } = o(e3, t3, n3, r3, 4, false, i2, s2));
          return { code: a2, pos: t3 };
        }
      }, 7749: (e2, t2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.isIdentifierChar = u, t2.isIdentifierName = function(e3) {
          let t3 = true;
          for (let n3 = 0; n3 < e3.length; n3++) {
            let r3 = e3.charCodeAt(n3);
            if (55296 == (64512 & r3) && n3 + 1 < e3.length) {
              const t4 = e3.charCodeAt(++n3);
              56320 == (64512 & t4) && (r3 = 65536 + ((1023 & r3) << 10) + (1023 & t4));
            }
            if (t3) {
              if (t3 = false, !c(r3)) return false;
            } else if (!u(r3)) return false;
          }
          return !t3;
        }, t2.isIdentifierStart = c;
        let n2 = "------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------", r2 = "-----------------------------------------------------------------------------------------------------------------------------------------------------";
        const i = new RegExp("[" + n2 + "]"), s = new RegExp("[" + n2 + r2 + "]");
        n2 = r2 = null;
        const a = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938, 6, 4191], o = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
        function l(e3, t3) {
          let n3 = 65536;
          for (let r3 = 0, i2 = t3.length; r3 < i2; r3 += 2) {
            if (n3 += t3[r3], n3 > e3) return false;
            if (n3 += t3[r3 + 1], n3 >= e3) return true;
          }
          return false;
        }
        function c(e3) {
          return e3 < 65 ? 36 === e3 : e3 <= 90 || (e3 < 97 ? 95 === e3 : e3 <= 122 || (e3 <= 65535 ? e3 >= 170 && i.test(String.fromCharCode(e3)) : l(e3, a)));
        }
        function u(e3) {
          return e3 < 48 ? 36 === e3 : e3 < 58 || !(e3 < 65) && (e3 <= 90 || (e3 < 97 ? 95 === e3 : e3 <= 122 || (e3 <= 65535 ? e3 >= 170 && s.test(String.fromCharCode(e3)) : l(e3, a) || l(e3, o))));
        }
      }, 9649: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), Object.defineProperty(t2, "isIdentifierChar", { enumerable: true, get: function() {
          return r2.isIdentifierChar;
        } }), Object.defineProperty(t2, "isIdentifierName", { enumerable: true, get: function() {
          return r2.isIdentifierName;
        } }), Object.defineProperty(t2, "isIdentifierStart", { enumerable: true, get: function() {
          return r2.isIdentifierStart;
        } }), Object.defineProperty(t2, "isKeyword", { enumerable: true, get: function() {
          return i.isKeyword;
        } }), Object.defineProperty(t2, "isReservedWord", { enumerable: true, get: function() {
          return i.isReservedWord;
        } }), Object.defineProperty(t2, "isStrictBindOnlyReservedWord", { enumerable: true, get: function() {
          return i.isStrictBindOnlyReservedWord;
        } }), Object.defineProperty(t2, "isStrictBindReservedWord", { enumerable: true, get: function() {
          return i.isStrictBindReservedWord;
        } }), Object.defineProperty(t2, "isStrictReservedWord", { enumerable: true, get: function() {
          return i.isStrictReservedWord;
        } });
        var r2 = n2(7749), i = n2(5562);
      }, 5562: (e2, t2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.isKeyword = function(e3) {
          return n2.has(e3);
        }, t2.isReservedWord = s, t2.isStrictBindOnlyReservedWord = o, t2.isStrictBindReservedWord = function(e3, t3) {
          return a(e3, t3) || o(e3);
        }, t2.isStrictReservedWord = a;
        const n2 = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"]), r2 = /* @__PURE__ */ new Set(["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"]), i = /* @__PURE__ */ new Set(["eval", "arguments"]);
        function s(e3, t3) {
          return t3 && "await" === e3 || "enum" === e3;
        }
        function a(e3, t3) {
          return s(e3, t3) || r2.has(e3);
        }
        function o(e3) {
          return i.has(e3);
        }
      }, 8530: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3 = {}) {
          return "" !== e3 && h(t3) ? function(e4, t4) {
            let n4 = "";
            for (const { type: r3, value: i2 } of u(t4)) {
              const t5 = e4[r3];
              n4 += t5 ? i2.split(l).map((e5) => t5(e5)).join("\n") : i2;
            }
            return n4;
          }({ keyword: (n3 = d(t3.forceColor)).cyan, capitalized: n3.yellow, jsxIdentifier: n3.yellow, punctuator: n3.yellow, number: n3.magenta, string: n3.green, regex: n3.magenta, comment: n3.grey, invalid: n3.white.bgRed.bold }, e3) : e3;
          var n3;
        }, t2.shouldHighlight = h;
        var r2 = n2(6188), i = n2(9649), s = function(e3, t3) {
          if (null === e3 || "object" != typeof e3 && "function" != typeof e3) return { default: e3 };
          var n3 = a(true);
          if (n3 && n3.has(e3)) return n3.get(e3);
          var r3 = {}, i2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var s2 in e3) if ("default" !== s2 && Object.prototype.hasOwnProperty.call(e3, s2)) {
            var o2 = i2 ? Object.getOwnPropertyDescriptor(e3, s2) : null;
            o2 && (o2.get || o2.set) ? Object.defineProperty(r3, s2, o2) : r3[s2] = e3[s2];
          }
          return r3.default = e3, n3 && n3.set(e3, r3), r3;
        }(n2(2589));
        function a(e3) {
          if ("function" != typeof WeakMap) return null;
          var t3 = /* @__PURE__ */ new WeakMap(), n3 = /* @__PURE__ */ new WeakMap();
          return (a = function(e4) {
            return e4 ? n3 : t3;
          })(e3);
        }
        const o = /* @__PURE__ */ new Set(["as", "async", "from", "get", "of", "set"]), l = /\r\n|[\n\r\u2028\u2029]/, c = /^[()[\]{}]$/;
        let u, p;
        {
          const e3 = /^[a-z][\w-]*$/i, t3 = function(t4, n3, r3) {
            if ("name" === t4.type) {
              if ((0, i.isKeyword)(t4.value) || (0, i.isStrictReservedWord)(t4.value, true) || o.has(t4.value)) return "keyword";
              if (e3.test(t4.value) && ("<" === r3[n3 - 1] || "</" == r3.slice(n3 - 2, n3))) return "jsxIdentifier";
              if (t4.value[0] !== t4.value[0].toLowerCase()) return "capitalized";
            }
            return "punctuator" === t4.type && c.test(t4.value) ? "bracket" : "invalid" !== t4.type || "@" !== t4.value && "#" !== t4.value ? t4.type : "punctuator";
          };
          u = function* (e4) {
            let n3;
            for (; n3 = r2.default.exec(e4); ) {
              const i2 = r2.matchToToken(n3);
              yield { type: t3(i2, n3.index, e4), value: i2.value };
            }
          };
        }
        function h(e3) {
          return s.default.level > 0 || e3.forceColor;
        }
        function d(e3) {
          return e3 ? (null != p || (p = new s.default.constructor({ enabled: true, level: 1 })), p) : s.default;
        }
        t2.getChalk = (e3) => d(e3.forceColor);
      }, 7191: (e2, t2) => {
        "use strict";
        function n2(e3, t3) {
          if (null == e3) return {};
          var n3, r3, i2 = {}, s2 = Object.keys(e3);
          for (r3 = 0; r3 < s2.length; r3++) n3 = s2[r3], t3.indexOf(n3) >= 0 || (i2[n3] = e3[n3]);
          return i2;
        }
        class r2 {
          constructor(e3, t3, n3) {
            this.line = void 0, this.column = void 0, this.index = void 0, this.line = e3, this.column = t3, this.index = n3;
          }
        }
        class i {
          constructor(e3, t3) {
            this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = e3, this.end = t3;
          }
        }
        function s(e3, t3) {
          const { line: n3, column: i2, index: s2 } = e3;
          return new r2(n3, i2 + t3, s2 + t3);
        }
        const a = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED";
        var o = { ImportMetaOutsideModule: { message: `import.meta may appear only with 'sourceType: "module"'`, code: a }, ImportOutsideModule: { message: `'import' and 'export' may appear only with 'sourceType: "module"'`, code: a } };
        const l = { ArrayPattern: "array destructuring pattern", AssignmentExpression: "assignment expression", AssignmentPattern: "assignment expression", ArrowFunctionExpression: "arrow function expression", ConditionalExpression: "conditional expression", CatchClause: "catch clause", ForOfStatement: "for-of statement", ForInStatement: "for-in statement", ForStatement: "for-loop", FormalParameters: "function parameter list", Identifier: "identifier", ImportSpecifier: "import specifier", ImportDefaultSpecifier: "import default specifier", ImportNamespaceSpecifier: "import namespace specifier", ObjectPattern: "object destructuring pattern", ParenthesizedExpression: "parenthesized expression", RestElement: "rest element", UpdateExpression: { true: "prefix operation", false: "postfix operation" }, VariableDeclarator: "variable declaration", YieldExpression: "yield expression" }, c = ({ type: e3, prefix: t3 }) => "UpdateExpression" === e3 ? l.UpdateExpression[String(t3)] : l[e3];
        var u = { AccessorIsGenerator: ({ kind: e3 }) => `A ${e3}ter cannot be a generator.`, ArgumentsInClass: "'arguments' is only allowed in functions and class methods.", AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.", AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.", AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.", AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.", AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncFunction: "'await' is only allowed within async functions.", BadGetterArity: "A 'get' accessor must not have any formal parameters.", BadSetterArity: "A 'set' accessor must have exactly one formal parameter.", BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.", ConstructorClassField: "Classes may not have a field named 'constructor'.", ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.", ConstructorIsAccessor: "Class constructor may not be an accessor.", ConstructorIsAsync: "Constructor can't be an async function.", ConstructorIsGenerator: "Constructor can't be a generator.", DeclarationMissingInitializer: ({ kind: e3 }) => `Missing initializer in ${e3} declaration.`, DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.", DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.", DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.", DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?", DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.", DecoratorSemicolon: "Decorators must not be followed by a semicolon.", DecoratorStaticBlock: "Decorators can't be used with a static block.", DeletePrivateField: "Deleting a private field is not allowed.", DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.", DuplicateConstructor: "Duplicate constructor in the same class.", DuplicateDefaultExport: "Only one default export allowed per module.", DuplicateExport: ({ exportName: e3 }) => `\`${e3}\` has already been exported. Exported identifiers must be unique.`, DuplicateProto: "Redefinition of __proto__ property.", DuplicateRegExpFlags: "Duplicate regular expression flag.", ElementAfterRest: "Rest element must be last element.", EscapedCharNotAnIdentifier: "Invalid Unicode escape.", ExportBindingIsString: ({ localName: e3, exportName: t3 }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${e3}' as '${t3}' } from 'some-module'\`?`, ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.", ForInOfLoopInitializer: ({ type: e3 }) => `'${"ForInStatement" === e3 ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`, ForInUsing: "For-in loop may not start with 'using' declaration.", ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.", ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.", GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.", IllegalBreakContinue: ({ type: e3 }) => `Unsyntactic ${"BreakStatement" === e3 ? "break" : "continue"}.`, IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.", IllegalReturn: "'return' outside of function.", ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.", ImportBindingIsString: ({ importName: e3 }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${e3}" as foo }\`?`, ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.", ImportCallArity: ({ maxArgumentCount: e3 }) => `\`import()\` requires exactly ${1 === e3 ? "one argument" : "one or two arguments"}.`, ImportCallNotNewExpression: "Cannot use new with import(...).", ImportCallSpreadArgument: "`...` is not allowed in `import()`.", ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.", ImportReflectionHasAssertion: "`import module x` cannot have assertions.", ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.', IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.", InvalidBigIntLiteral: "Invalid BigIntLiteral.", InvalidCodePoint: "Code point out of bounds.", InvalidCoverInitializedName: "Invalid shorthand property initializer.", InvalidDecimal: "Invalid decimal.", InvalidDigit: ({ radix: e3 }) => `Expected number in radix ${e3}.`, InvalidEscapeSequence: "Bad character escape sequence.", InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.", InvalidEscapedReservedWord: ({ reservedWord: e3 }) => `Escape sequence in keyword ${e3}.`, InvalidIdentifier: ({ identifierName: e3 }) => `Invalid identifier ${e3}.`, InvalidLhs: ({ ancestor: e3 }) => `Invalid left-hand side in ${c(e3)}.`, InvalidLhsBinding: ({ ancestor: e3 }) => `Binding invalid left-hand side in ${c(e3)}.`, InvalidNumber: "Invalid number.", InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.", InvalidOrUnexpectedToken: ({ unexpected: e3 }) => `Unexpected character '${e3}'.`, InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.", InvalidPrivateFieldResolution: ({ identifierName: e3 }) => `Private name #${e3} is not defined.`, InvalidPropertyBindingPattern: "Binding member expression.", InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.", InvalidRestAssignmentPattern: "Invalid rest operator's argument.", LabelRedeclaration: ({ labelName: e3 }) => `Label '${e3}' is already declared.`, LetInLexicalBinding: "'let' is disallowed as a lexically bound name.", LineTerminatorBeforeArrow: "No line break is allowed before '=>'.", MalformedRegExpFlags: "Invalid regular expression flag.", MissingClassName: "A class name is required.", MissingEqInAssignment: "Only '=' operator can be used for specifying default value.", MissingSemicolon: "Missing semicolon.", MissingPlugin: ({ missingPlugin: e3 }) => `This experimental syntax requires enabling the parser plugin: ${e3.map((e4) => JSON.stringify(e4)).join(", ")}.`, MissingOneOfPlugins: ({ missingPlugin: e3 }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${e3.map((e4) => JSON.stringify(e4)).join(", ")}.`, MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.", MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.", ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.", ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.", ModuleAttributesWithDuplicateKeys: ({ key: e3 }) => `Duplicate key "${e3}" is not allowed in module attributes.`, ModuleExportNameHasLoneSurrogate: ({ surrogateCharCode: e3 }) => `An export name cannot include a lone surrogate, found '\\u${e3.toString(16)}'.`, ModuleExportUndefined: ({ localName: e3 }) => `Export '${e3}' is not defined.`, MultipleDefaultsInSwitch: "Multiple default clauses.", NewlineAfterThrow: "Illegal newline after throw.", NoCatchOrFinally: "Missing catch or finally clause.", NumberIdentifier: "Identifier directly after number.", NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.", ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.", OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.", OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.", OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.", ParamDupe: "Argument name clash.", PatternHasAccessor: "Object pattern can't contain getter or setter.", PatternHasMethod: "Object pattern can't contain methods.", PrivateInExpectedIn: ({ identifierName: e3 }) => `Private names are only allowed in property accesses (\`obj.#${e3}\`) or in \`in\` expressions (\`#${e3} in obj\`).`, PrivateNameRedeclaration: ({ identifierName: e3 }) => `Duplicate private name #${e3}.`, RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", RecordNoProto: "'__proto__' is not allowed in Record expressions.", RestTrailingComma: "Unexpected trailing comma after rest element.", SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.", SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.", StaticPrototype: "Classes may not have static property named prototype.", SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?", SuperPrivateField: "Private fields can't be accessed on super.", TrailingDecorator: "Decorators must be attached to a class element.", TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.", UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.', UnexpectedDigitAfterHash: "Unexpected digit after hash token.", UnexpectedImportExport: "'import' and 'export' may only appear at the top level.", UnexpectedKeyword: ({ keyword: e3 }) => `Unexpected keyword '${e3}'.`, UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.", UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.", UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.", UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.", UnexpectedPrivateField: "Unexpected private name.", UnexpectedReservedWord: ({ reservedWord: e3 }) => `Unexpected reserved word '${e3}'.`, UnexpectedSuper: "'super' is only allowed in object methods and classes.", UnexpectedToken: ({ expected: e3, unexpected: t3 }) => `Unexpected token${t3 ? ` '${t3}'.` : ""}${e3 ? `, expected "${e3}"` : ""}`, UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.", UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.", UnsupportedBind: "Binding should be performed on object property.", UnsupportedDecoratorExport: "A decorated export must export a class declaration.", UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.", UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.", UnsupportedMetaProperty: ({ target: e3, onlyValidPropertyName: t3 }) => `The only valid meta property for ${e3} is ${e3}.${t3}.`, UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.", UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.", UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).", UnterminatedComment: "Unterminated comment.", UnterminatedRegExp: "Unterminated regular expression.", UnterminatedString: "Unterminated string constant.", UnterminatedTemplate: "Unterminated template.", UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.", VarRedeclaration: ({ identifierName: e3 }) => `Identifier '${e3}' has already been declared.`, YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.", YieldInParameter: "Yield expression is not allowed in formal parameters.", ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0." };
        const p = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]);
        var h = { PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.", PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.', PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.", PipeTopicUnconfiguredToken: ({ token: e3 }) => `Invalid topic token ${e3}. In order to use ${e3} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${e3}" }.`, PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.", PipeUnparenthesizedBody: ({ type: e3 }) => `Hack-style pipe body cannot be an unparenthesized ${c({ type: e3 })}; please wrap it in parentheses.`, PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.', PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.", PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.", PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.", PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.", PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.' };
        const d = ["toMessage"], f = ["message"];
        function y(e3, t3, n3) {
          Object.defineProperty(e3, t3, { enumerable: false, configurable: true, value: n3 });
        }
        function m(e3) {
          let { toMessage: t3 } = e3, i2 = n2(e3, d);
          return function e4({ loc: n3, details: s2 }) {
            const a2 = new SyntaxError();
            return Object.assign(a2, i2, { loc: n3, pos: n3.index }), "missingPlugin" in s2 && Object.assign(a2, { missingPlugin: s2.missingPlugin }), y(a2, "clone", function(t4 = {}) {
              var i3;
              const { line: a3, column: o2, index: l2 } = null != (i3 = t4.loc) ? i3 : n3;
              return e4({ loc: new r2(a3, o2, l2), details: Object.assign({}, s2, t4.details) });
            }), y(a2, "details", s2), Object.defineProperty(a2, "message", { configurable: true, get() {
              const e5 = `${t3(s2)} (${n3.line}:${n3.column})`;
              return this.message = e5, e5;
            }, set(e5) {
              Object.defineProperty(this, "message", { value: e5, writable: true });
            } }), a2;
          };
        }
        function T(e3, t3) {
          if (Array.isArray(e3)) return (t4) => T(t4, e3[0]);
          const r3 = {};
          for (const i2 of Object.keys(e3)) {
            const s2 = e3[i2], a2 = "string" == typeof s2 ? { message: () => s2 } : "function" == typeof s2 ? { message: s2 } : s2, { message: o2 } = a2, l2 = n2(a2, f), c2 = "string" == typeof o2 ? () => o2 : o2;
            r3[i2] = m(Object.assign({ code: "BABEL_PARSER_SYNTAX_ERROR", reasonCode: i2, toMessage: c2 }, t3 ? { syntaxPlugin: t3 } : {}, l2));
          }
          return r3;
        }
        const g = Object.assign({}, T(o), T(u), T({ StrictDelete: "Deleting local variable in strict mode.", StrictEvalArguments: ({ referenceName: e3 }) => `Assigning to '${e3}' in strict mode.`, StrictEvalArgumentsBinding: ({ bindingName: e3 }) => `Binding '${e3}' in strict mode.`, StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.", StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.", StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.", StrictWith: "'with' in strict mode." }), T`pipelineOperator`(h)), { defineProperty: b } = Object, E = (e3, t3) => b(e3, t3, { enumerable: false, value: e3[t3] });
        function S(e3) {
          return e3.loc.start && E(e3.loc.start, "index"), e3.loc.end && E(e3.loc.end, "index"), e3;
        }
        class P {
          constructor(e3, t3) {
            this.token = void 0, this.preserveSpace = void 0, this.token = e3, this.preserveSpace = !!t3;
          }
        }
        const x = { brace: new P("{"), j_oTag: new P("<tag"), j_cTag: new P("</tag"), j_expr: new P("<tag>...</tag>", true) };
        x.template = new P("`", true);
        const D = true, A = true, v = true, C = true, w = true;
        class O {
          constructor(e3, t3 = {}) {
            this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop = void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = e3, this.keyword = t3.keyword, this.beforeExpr = !!t3.beforeExpr, this.startsExpr = !!t3.startsExpr, this.rightAssociative = !!t3.rightAssociative, this.isLoop = !!t3.isLoop, this.isAssign = !!t3.isAssign, this.prefix = !!t3.prefix, this.postfix = !!t3.postfix, this.binop = null != t3.binop ? t3.binop : null, this.updateContext = null;
          }
        }
        const I = /* @__PURE__ */ new Map();
        function N(e3, t3 = {}) {
          t3.keyword = e3;
          const n3 = U(e3, t3);
          return I.set(e3, n3), n3;
        }
        function F(e3, t3) {
          return U(e3, { beforeExpr: D, binop: t3 });
        }
        let k = -1;
        const L = [], _ = [], M = [], B = [], j = [], R = [];
        function U(e3, t3 = {}) {
          var n3, r3, i2, s2;
          return ++k, _.push(e3), M.push(null != (n3 = t3.binop) ? n3 : -1), B.push(null != (r3 = t3.beforeExpr) && r3), j.push(null != (i2 = t3.startsExpr) && i2), R.push(null != (s2 = t3.prefix) && s2), L.push(new O(e3, t3)), k;
        }
        function V(e3, t3 = {}) {
          var n3, r3, i2, s2;
          return ++k, I.set(e3, k), _.push(e3), M.push(null != (n3 = t3.binop) ? n3 : -1), B.push(null != (r3 = t3.beforeExpr) && r3), j.push(null != (i2 = t3.startsExpr) && i2), R.push(null != (s2 = t3.prefix) && s2), L.push(new O("name", t3)), k;
        }
        const K = { bracketL: U("[", { beforeExpr: D, startsExpr: A }), bracketHashL: U("#[", { beforeExpr: D, startsExpr: A }), bracketBarL: U("[|", { beforeExpr: D, startsExpr: A }), bracketR: U("]"), bracketBarR: U("|]"), braceL: U("{", { beforeExpr: D, startsExpr: A }), braceBarL: U("{|", { beforeExpr: D, startsExpr: A }), braceHashL: U("#{", { beforeExpr: D, startsExpr: A }), braceR: U("}"), braceBarR: U("|}"), parenL: U("(", { beforeExpr: D, startsExpr: A }), parenR: U(")"), comma: U(",", { beforeExpr: D }), semi: U(";", { beforeExpr: D }), colon: U(":", { beforeExpr: D }), doubleColon: U("::", { beforeExpr: D }), dot: U("."), question: U("?", { beforeExpr: D }), questionDot: U("?."), arrow: U("=>", { beforeExpr: D }), template: U("template"), ellipsis: U("...", { beforeExpr: D }), backQuote: U("`", { startsExpr: A }), dollarBraceL: U("${", { beforeExpr: D, startsExpr: A }), templateTail: U("...`", { startsExpr: A }), templateNonTail: U("...${", { beforeExpr: D, startsExpr: A }), at: U("@"), hash: U("#", { startsExpr: A }), interpreterDirective: U("#!..."), eq: U("=", { beforeExpr: D, isAssign: C }), assign: U("_=", { beforeExpr: D, isAssign: C }), slashAssign: U("_=", { beforeExpr: D, isAssign: C }), xorAssign: U("_=", { beforeExpr: D, isAssign: C }), moduloAssign: U("_=", { beforeExpr: D, isAssign: C }), incDec: U("++/--", { prefix: w, postfix: true, startsExpr: A }), bang: U("!", { beforeExpr: D, prefix: w, startsExpr: A }), tilde: U("~", { beforeExpr: D, prefix: w, startsExpr: A }), doubleCaret: U("^^", { startsExpr: A }), doubleAt: U("@@", { startsExpr: A }), pipeline: F("|>", 0), nullishCoalescing: F("??", 1), logicalOR: F("||", 1), logicalAND: F("&&", 2), bitwiseOR: F("|", 3), bitwiseXOR: F("^", 4), bitwiseAND: F("&", 5), equality: F("==/!=/===/!==", 6), lt: F("</>/<=/>=", 7), gt: F("</>/<=/>=", 7), relational: F("</>/<=/>=", 7), bitShift: F("<</>>/>>>", 8), bitShiftL: F("<</>>/>>>", 8), bitShiftR: F("<</>>/>>>", 8), plusMin: U("+/-", { beforeExpr: D, binop: 9, prefix: w, startsExpr: A }), modulo: U("%", { binop: 10, startsExpr: A }), star: U("*", { binop: 10 }), slash: F("/", 10), exponent: U("**", { beforeExpr: D, binop: 11, rightAssociative: true }), _in: N("in", { beforeExpr: D, binop: 7 }), _instanceof: N("instanceof", { beforeExpr: D, binop: 7 }), _break: N("break"), _case: N("case", { beforeExpr: D }), _catch: N("catch"), _continue: N("continue"), _debugger: N("debugger"), _default: N("default", { beforeExpr: D }), _else: N("else", { beforeExpr: D }), _finally: N("finally"), _function: N("function", { startsExpr: A }), _if: N("if"), _return: N("return", { beforeExpr: D }), _switch: N("switch"), _throw: N("throw", { beforeExpr: D, prefix: w, startsExpr: A }), _try: N("try"), _var: N("var"), _const: N("const"), _with: N("with"), _new: N("new", { beforeExpr: D, startsExpr: A }), _this: N("this", { startsExpr: A }), _super: N("super", { startsExpr: A }), _class: N("class", { startsExpr: A }), _extends: N("extends", { beforeExpr: D }), _export: N("export"), _import: N("import", { startsExpr: A }), _null: N("null", { startsExpr: A }), _true: N("true", { startsExpr: A }), _false: N("false", { startsExpr: A }), _typeof: N("typeof", { beforeExpr: D, prefix: w, startsExpr: A }), _void: N("void", { beforeExpr: D, prefix: w, startsExpr: A }), _delete: N("delete", { beforeExpr: D, prefix: w, startsExpr: A }), _do: N("do", { isLoop: v, beforeExpr: D }), _for: N("for", { isLoop: v }), _while: N("while", { isLoop: v }), _as: V("as", { startsExpr: A }), _assert: V("assert", { startsExpr: A }), _async: V("async", { startsExpr: A }), _await: V("await", { startsExpr: A }), _from: V("from", { startsExpr: A }), _get: V("get", { startsExpr: A }), _let: V("let", { startsExpr: A }), _meta: V("meta", { startsExpr: A }), _of: V("of", { startsExpr: A }), _sent: V("sent", { startsExpr: A }), _set: V("set", { startsExpr: A }), _static: V("static", { startsExpr: A }), _using: V("using", { startsExpr: A }), _yield: V("yield", { startsExpr: A }), _asserts: V("asserts", { startsExpr: A }), _checks: V("checks", { startsExpr: A }), _exports: V("exports", { startsExpr: A }), _global: V("global", { startsExpr: A }), _implements: V("implements", { startsExpr: A }), _intrinsic: V("intrinsic", { startsExpr: A }), _infer: V("infer", { startsExpr: A }), _is: V("is", { startsExpr: A }), _mixins: V("mixins", { startsExpr: A }), _proto: V("proto", { startsExpr: A }), _require: V("require", { startsExpr: A }), _satisfies: V("satisfies", { startsExpr: A }), _keyof: V("keyof", { startsExpr: A }), _readonly: V("readonly", { startsExpr: A }), _unique: V("unique", { startsExpr: A }), _abstract: V("abstract", { startsExpr: A }), _declare: V("declare", { startsExpr: A }), _enum: V("enum", { startsExpr: A }), _module: V("module", { startsExpr: A }), _namespace: V("namespace", { startsExpr: A }), _interface: V("interface", { startsExpr: A }), _type: V("type", { startsExpr: A }), _opaque: V("opaque", { startsExpr: A }), name: U("name", { startsExpr: A }), string: U("string", { startsExpr: A }), num: U("num", { startsExpr: A }), bigint: U("bigint", { startsExpr: A }), decimal: U("decimal", { startsExpr: A }), regexp: U("regexp", { startsExpr: A }), privateName: U("#name", { startsExpr: A }), eof: U("eof"), jsxName: U("jsxName"), jsxText: U("jsxText", { beforeExpr: true }), jsxTagStart: U("jsxTagStart", { startsExpr: true }), jsxTagEnd: U("jsxTagEnd"), placeholder: U("%%", { startsExpr: true }) };
        function W(e3) {
          return e3 >= 93 && e3 <= 130;
        }
        function X(e3) {
          return e3 >= 58 && e3 <= 130;
        }
        function Y(e3) {
          return e3 >= 58 && e3 <= 134;
        }
        function q(e3) {
          return j[e3];
        }
        function H(e3) {
          return e3 >= 127 && e3 <= 129;
        }
        function J(e3) {
          return e3 >= 58 && e3 <= 92;
        }
        function $(e3) {
          return _[e3];
        }
        function G(e3) {
          return M[e3];
        }
        function z(e3) {
          return e3 >= 24 && e3 <= 25;
        }
        function Q(e3) {
          return L[e3];
        }
        L[8].updateContext = (e3) => {
          e3.pop();
        }, L[5].updateContext = L[7].updateContext = L[23].updateContext = (e3) => {
          e3.push(x.brace);
        }, L[22].updateContext = (e3) => {
          e3[e3.length - 1] === x.template ? e3.pop() : e3.push(x.template);
        }, L[140].updateContext = (e3) => {
          e3.push(x.j_expr, x.j_oTag);
        };
        let Z = "------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------", ee = "-----------------------------------------------------------------------------------------------------------------------------------------------------";
        const te = new RegExp("[" + Z + "]"), ne = new RegExp("[" + Z + ee + "]");
        Z = ee = null;
        const re = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938, 6, 4191], ie = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
        function se(e3, t3) {
          let n3 = 65536;
          for (let r3 = 0, i2 = t3.length; r3 < i2; r3 += 2) {
            if (n3 += t3[r3], n3 > e3) return false;
            if (n3 += t3[r3 + 1], n3 >= e3) return true;
          }
          return false;
        }
        function ae(e3) {
          return e3 < 65 ? 36 === e3 : e3 <= 90 || (e3 < 97 ? 95 === e3 : e3 <= 122 || (e3 <= 65535 ? e3 >= 170 && te.test(String.fromCharCode(e3)) : se(e3, re)));
        }
        function oe(e3) {
          return e3 < 48 ? 36 === e3 : e3 < 58 || !(e3 < 65) && (e3 <= 90 || (e3 < 97 ? 95 === e3 : e3 <= 122 || (e3 <= 65535 ? e3 >= 170 && ne.test(String.fromCharCode(e3)) : se(e3, re) || se(e3, ie))));
        }
        const le = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"]), ce = /* @__PURE__ */ new Set(["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"]), ue = /* @__PURE__ */ new Set(["eval", "arguments"]);
        function pe(e3, t3) {
          return t3 && "await" === e3 || "enum" === e3;
        }
        function he(e3, t3) {
          return pe(e3, t3) || ce.has(e3);
        }
        function de(e3) {
          return ue.has(e3);
        }
        function fe(e3, t3) {
          return he(e3, t3) || de(e3);
        }
        const ye = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
        class me {
          constructor(e3) {
            this.var = /* @__PURE__ */ new Set(), this.lexical = /* @__PURE__ */ new Set(), this.functions = /* @__PURE__ */ new Set(), this.flags = e3;
          }
        }
        class Te {
          constructor(e3, t3) {
            this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = e3, this.inModule = t3;
          }
          get inTopLevel() {
            return (1 & this.currentScope().flags) > 0;
          }
          get inFunction() {
            return (2 & this.currentVarScopeFlags()) > 0;
          }
          get allowSuper() {
            return (16 & this.currentThisScopeFlags()) > 0;
          }
          get allowDirectSuper() {
            return (32 & this.currentThisScopeFlags()) > 0;
          }
          get inClass() {
            return (64 & this.currentThisScopeFlags()) > 0;
          }
          get inClassAndNotInNonArrowFunction() {
            const e3 = this.currentThisScopeFlags();
            return (64 & e3) > 0 && 0 == (2 & e3);
          }
          get inStaticBlock() {
            for (let e3 = this.scopeStack.length - 1; ; e3--) {
              const { flags: t3 } = this.scopeStack[e3];
              if (128 & t3) return true;
              if (451 & t3) return false;
            }
          }
          get inNonArrowFunction() {
            return (2 & this.currentThisScopeFlags()) > 0;
          }
          get treatFunctionsAsVar() {
            return this.treatFunctionsAsVarInScope(this.currentScope());
          }
          createScope(e3) {
            return new me(e3);
          }
          enter(e3) {
            this.scopeStack.push(this.createScope(e3));
          }
          exit() {
            return this.scopeStack.pop().flags;
          }
          treatFunctionsAsVarInScope(e3) {
            return !!(130 & e3.flags || !this.parser.inModule && 1 & e3.flags);
          }
          declareName(e3, t3, n3) {
            let r3 = this.currentScope();
            if (8 & t3 || 16 & t3) this.checkRedeclarationInScope(r3, e3, t3, n3), 16 & t3 ? r3.functions.add(e3) : r3.lexical.add(e3), 8 & t3 && this.maybeExportDefined(r3, e3);
            else if (4 & t3) for (let i2 = this.scopeStack.length - 1; i2 >= 0 && (r3 = this.scopeStack[i2], this.checkRedeclarationInScope(r3, e3, t3, n3), r3.var.add(e3), this.maybeExportDefined(r3, e3), !(387 & r3.flags)); --i2) ;
            this.parser.inModule && 1 & r3.flags && this.undefinedExports.delete(e3);
          }
          maybeExportDefined(e3, t3) {
            this.parser.inModule && 1 & e3.flags && this.undefinedExports.delete(t3);
          }
          checkRedeclarationInScope(e3, t3, n3, r3) {
            this.isRedeclaredInScope(e3, t3, n3) && this.parser.raise(g.VarRedeclaration, { at: r3, identifierName: t3 });
          }
          isRedeclaredInScope(e3, t3, n3) {
            return !!(1 & n3) && (8 & n3 ? e3.lexical.has(t3) || e3.functions.has(t3) || e3.var.has(t3) : 16 & n3 ? e3.lexical.has(t3) || !this.treatFunctionsAsVarInScope(e3) && e3.var.has(t3) : e3.lexical.has(t3) && !(8 & e3.flags && e3.lexical.values().next().value === t3) || !this.treatFunctionsAsVarInScope(e3) && e3.functions.has(t3));
          }
          checkLocalExport(e3) {
            const { name: t3 } = e3, n3 = this.scopeStack[0];
            n3.lexical.has(t3) || n3.var.has(t3) || n3.functions.has(t3) || this.undefinedExports.set(t3, e3.loc.start);
          }
          currentScope() {
            return this.scopeStack[this.scopeStack.length - 1];
          }
          currentVarScopeFlags() {
            for (let e3 = this.scopeStack.length - 1; ; e3--) {
              const { flags: t3 } = this.scopeStack[e3];
              if (387 & t3) return t3;
            }
          }
          currentThisScopeFlags() {
            for (let e3 = this.scopeStack.length - 1; ; e3--) {
              const { flags: t3 } = this.scopeStack[e3];
              if (451 & t3 && !(4 & t3)) return t3;
            }
          }
        }
        class ge extends me {
          constructor(...e3) {
            super(...e3), this.declareFunctions = /* @__PURE__ */ new Set();
          }
        }
        class be extends Te {
          createScope(e3) {
            return new ge(e3);
          }
          declareName(e3, t3, n3) {
            const r3 = this.currentScope();
            if (2048 & t3) return this.checkRedeclarationInScope(r3, e3, t3, n3), this.maybeExportDefined(r3, e3), void r3.declareFunctions.add(e3);
            super.declareName(e3, t3, n3);
          }
          isRedeclaredInScope(e3, t3, n3) {
            return !!super.isRedeclaredInScope(e3, t3, n3) || !!(2048 & n3) && !e3.declareFunctions.has(t3) && (e3.lexical.has(t3) || e3.functions.has(t3));
          }
          checkLocalExport(e3) {
            this.scopeStack[0].declareFunctions.has(e3.name) || super.checkLocalExport(e3);
          }
        }
        class Ee {
          constructor() {
            this.sawUnambiguousESM = false, this.ambiguousScriptDifferentAst = false;
          }
          hasPlugin(e3) {
            if ("string" == typeof e3) return this.plugins.has(e3);
            {
              const [t3, n3] = e3;
              if (!this.hasPlugin(t3)) return false;
              const r3 = this.plugins.get(t3);
              for (const e4 of Object.keys(n3)) if ((null == r3 ? void 0 : r3[e4]) !== n3[e4]) return false;
              return true;
            }
          }
          getPluginOption(e3, t3) {
            var n3;
            return null == (n3 = this.plugins.get(e3)) ? void 0 : n3[t3];
          }
        }
        function Se(e3, t3) {
          void 0 === e3.trailingComments ? e3.trailingComments = t3 : e3.trailingComments.unshift(...t3);
        }
        function Pe(e3, t3) {
          void 0 === e3.innerComments ? e3.innerComments = t3 : e3.innerComments.unshift(...t3);
        }
        function xe(e3, t3, n3) {
          let r3 = null, i2 = t3.length;
          for (; null === r3 && i2 > 0; ) r3 = t3[--i2];
          null === r3 || r3.start > n3.start ? Pe(e3, n3.comments) : Se(r3, n3.comments);
        }
        class De extends Ee {
          addComment(e3) {
            this.filename && (e3.loc.filename = this.filename), this.state.comments.push(e3);
          }
          processComment(e3) {
            const { commentStack: t3 } = this.state, n3 = t3.length;
            if (0 === n3) return;
            let r3 = n3 - 1;
            const i2 = t3[r3];
            i2.start === e3.end && (i2.leadingNode = e3, r3--);
            const { start: s2 } = e3;
            for (; r3 >= 0; r3--) {
              const n4 = t3[r3], i3 = n4.end;
              if (!(i3 > s2)) {
                i3 === s2 && (n4.trailingNode = e3);
                break;
              }
              n4.containingNode = e3, this.finalizeComment(n4), t3.splice(r3, 1);
            }
          }
          finalizeComment(e3) {
            const { comments: t3 } = e3;
            if (null !== e3.leadingNode || null !== e3.trailingNode) null !== e3.leadingNode && Se(e3.leadingNode, t3), null !== e3.trailingNode && function(e4, t4) {
              void 0 === e4.leadingComments ? e4.leadingComments = t4 : e4.leadingComments.unshift(...t4);
            }(e3.trailingNode, t3);
            else {
              const { containingNode: n3, start: r3 } = e3;
              if (44 === this.input.charCodeAt(r3 - 1)) switch (n3.type) {
                case "ObjectExpression":
                case "ObjectPattern":
                case "RecordExpression":
                  xe(n3, n3.properties, e3);
                  break;
                case "CallExpression":
                case "OptionalCallExpression":
                  xe(n3, n3.arguments, e3);
                  break;
                case "FunctionDeclaration":
                case "FunctionExpression":
                case "ArrowFunctionExpression":
                case "ObjectMethod":
                case "ClassMethod":
                case "ClassPrivateMethod":
                  xe(n3, n3.params, e3);
                  break;
                case "ArrayExpression":
                case "ArrayPattern":
                case "TupleExpression":
                  xe(n3, n3.elements, e3);
                  break;
                case "ExportNamedDeclaration":
                case "ImportDeclaration":
                  xe(n3, n3.specifiers, e3);
                  break;
                default:
                  Pe(n3, t3);
              }
              else Pe(n3, t3);
            }
          }
          finalizeRemainingComments() {
            const { commentStack: e3 } = this.state;
            for (let t3 = e3.length - 1; t3 >= 0; t3--) this.finalizeComment(e3[t3]);
            this.state.commentStack = [];
          }
          resetPreviousNodeTrailingComments(e3) {
            const { commentStack: t3 } = this.state, { length: n3 } = t3;
            if (0 === n3) return;
            const r3 = t3[n3 - 1];
            r3.leadingNode === e3 && (r3.leadingNode = null);
          }
          resetPreviousIdentifierLeadingComments(e3) {
            const { commentStack: t3 } = this.state, { length: n3 } = t3;
            0 !== n3 && (t3[n3 - 1].trailingNode === e3 ? t3[n3 - 1].trailingNode = null : n3 >= 2 && t3[n3 - 2].trailingNode === e3 && (t3[n3 - 2].trailingNode = null));
          }
          takeSurroundingComments(e3, t3, n3) {
            const { commentStack: r3 } = this.state, i2 = r3.length;
            if (0 === i2) return;
            let s2 = i2 - 1;
            for (; s2 >= 0; s2--) {
              const i3 = r3[s2], a2 = i3.end;
              if (i3.start === n3) i3.leadingNode = e3;
              else if (a2 === t3) i3.trailingNode = e3;
              else if (a2 < t3) break;
            }
          }
        }
        const Ae = /\r\n?|[\n\u2028\u2029]/, ve = new RegExp(Ae.source, "g");
        function Ce(e3) {
          switch (e3) {
            case 10:
            case 13:
            case 8232:
            case 8233:
              return true;
            default:
              return false;
          }
        }
        const we = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, Oe = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g, Ie = new RegExp("(?=(" + Oe.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
        function Ne(e3) {
          switch (e3) {
            case 9:
            case 11:
            case 12:
            case 32:
            case 160:
            case 5760:
            case 8192:
            case 8193:
            case 8194:
            case 8195:
            case 8196:
            case 8197:
            case 8198:
            case 8199:
            case 8200:
            case 8201:
            case 8202:
            case 8239:
            case 8287:
            case 12288:
            case 65279:
              return true;
            default:
              return false;
          }
        }
        class Fe {
          constructor() {
            this.strict = void 0, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.maybeInArrowParameters = false, this.inType = false, this.noAnonFunctionType = false, this.hasFlowComment = false, this.isAmbientContext = false, this.inAbstractClass = false, this.inDisallowConditionalTypesContext = false, this.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null }, this.soloAwait = false, this.inFSharpPipelineDirectBody = false, this.labels = [], this.comments = [], this.commentStack = [], this.pos = 0, this.type = 137, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.lastTokStart = 0, this.context = [x.brace], this.canStartJSXElement = true, this.containsEsc = false, this.firstInvalidTemplateEscapePos = null, this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
          }
          init({ strictMode: e3, sourceType: t3, startLine: n3, startColumn: i2 }) {
            this.strict = false !== e3 && (true === e3 || "module" === t3), this.curLine = n3, this.lineStart = -i2, this.startLoc = this.endLoc = new r2(n3, i2, 0);
          }
          curPosition() {
            return new r2(this.curLine, this.pos - this.lineStart, this.pos);
          }
          clone(e3) {
            const t3 = new Fe(), n3 = Object.keys(this);
            for (let r3 = 0, i2 = n3.length; r3 < i2; r3++) {
              const i3 = n3[r3];
              let s2 = this[i3];
              !e3 && Array.isArray(s2) && (s2 = s2.slice()), t3[i3] = s2;
            }
            return t3;
          }
        }
        var ke = function(e3) {
          return e3 >= 48 && e3 <= 57;
        };
        const Le = { decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]), hex: /* @__PURE__ */ new Set([46, 88, 95, 120]) }, _e = { bin: (e3) => 48 === e3 || 49 === e3, oct: (e3) => e3 >= 48 && e3 <= 55, dec: (e3) => e3 >= 48 && e3 <= 57, hex: (e3) => e3 >= 48 && e3 <= 57 || e3 >= 65 && e3 <= 70 || e3 >= 97 && e3 <= 102 };
        function Me(e3, t3, n3, r3, i2, s2) {
          const a2 = n3, o2 = r3, l2 = i2;
          let c2 = "", u2 = null, p2 = n3;
          const { length: h2 } = t3;
          for (; ; ) {
            if (n3 >= h2) {
              s2.unterminated(a2, o2, l2), c2 += t3.slice(p2, n3);
              break;
            }
            const d2 = t3.charCodeAt(n3);
            if (Be(e3, d2, t3, n3)) {
              c2 += t3.slice(p2, n3);
              break;
            }
            if (92 === d2) {
              c2 += t3.slice(p2, n3);
              const a3 = je(t3, n3, r3, i2, "template" === e3, s2);
              null !== a3.ch || u2 ? c2 += a3.ch : u2 = { pos: n3, lineStart: r3, curLine: i2 }, { pos: n3, lineStart: r3, curLine: i2 } = a3, p2 = n3;
            } else 8232 === d2 || 8233 === d2 ? (++i2, r3 = ++n3) : 10 === d2 || 13 === d2 ? "template" === e3 ? (c2 += t3.slice(p2, n3) + "\n", ++n3, 13 === d2 && 10 === t3.charCodeAt(n3) && ++n3, ++i2, p2 = r3 = n3) : s2.unterminated(a2, o2, l2) : ++n3;
          }
          return { pos: n3, str: c2, firstInvalidLoc: u2, lineStart: r3, curLine: i2, containsInvalid: !!u2 };
        }
        function Be(e3, t3, n3, r3) {
          return "template" === e3 ? 96 === t3 || 36 === t3 && 123 === n3.charCodeAt(r3 + 1) : t3 === ("double" === e3 ? 34 : 39);
        }
        function je(e3, t3, n3, r3, i2, s2) {
          const a2 = !i2;
          t3++;
          const o2 = (e4) => ({ pos: t3, ch: e4, lineStart: n3, curLine: r3 }), l2 = e3.charCodeAt(t3++);
          switch (l2) {
            case 110:
              return o2("\n");
            case 114:
              return o2("\r");
            case 120: {
              let i3;
              return { code: i3, pos: t3 } = Re(e3, t3, n3, r3, 2, false, a2, s2), o2(null === i3 ? null : String.fromCharCode(i3));
            }
            case 117: {
              let i3;
              return { code: i3, pos: t3 } = Ve(e3, t3, n3, r3, a2, s2), o2(null === i3 ? null : String.fromCodePoint(i3));
            }
            case 116:
              return o2("	");
            case 98:
              return o2("\b");
            case 118:
              return o2("\v");
            case 102:
              return o2("\f");
            case 13:
              10 === e3.charCodeAt(t3) && ++t3;
            case 10:
              n3 = t3, ++r3;
            case 8232:
            case 8233:
              return o2("");
            case 56:
            case 57:
              if (i2) return o2(null);
              s2.strictNumericEscape(t3 - 1, n3, r3);
            default:
              if (l2 >= 48 && l2 <= 55) {
                const a3 = t3 - 1;
                let l3 = e3.slice(a3, t3 + 2).match(/^[0-7]+/)[0], c2 = parseInt(l3, 8);
                c2 > 255 && (l3 = l3.slice(0, -1), c2 = parseInt(l3, 8)), t3 += l3.length - 1;
                const u2 = e3.charCodeAt(t3);
                if ("0" !== l3 || 56 === u2 || 57 === u2) {
                  if (i2) return o2(null);
                  s2.strictNumericEscape(a3, n3, r3);
                }
                return o2(String.fromCharCode(c2));
              }
              return o2(String.fromCharCode(l2));
          }
        }
        function Re(e3, t3, n3, r3, i2, s2, a2, o2) {
          const l2 = t3;
          let c2;
          return { n: c2, pos: t3 } = Ue(e3, t3, n3, r3, 16, i2, s2, false, o2, !a2), null === c2 && (a2 ? o2.invalidEscapeSequence(l2, n3, r3) : t3 = l2 - 1), { code: c2, pos: t3 };
        }
        function Ue(e3, t3, n3, r3, i2, s2, a2, o2, l2, c2) {
          const u2 = t3, p2 = 16 === i2 ? Le.hex : Le.decBinOct, h2 = 16 === i2 ? _e.hex : 10 === i2 ? _e.dec : 8 === i2 ? _e.oct : _e.bin;
          let d2 = false, f2 = 0;
          for (let u3 = 0, y2 = null == s2 ? 1 / 0 : s2; u3 < y2; ++u3) {
            const s3 = e3.charCodeAt(t3);
            let u4;
            if (95 !== s3 || "bail" === o2) {
              if (u4 = s3 >= 97 ? s3 - 97 + 10 : s3 >= 65 ? s3 - 65 + 10 : ke(s3) ? s3 - 48 : 1 / 0, u4 >= i2) {
                if (u4 <= 9 && c2) return { n: null, pos: t3 };
                if (u4 <= 9 && l2.invalidDigit(t3, n3, r3, i2)) u4 = 0;
                else {
                  if (!a2) break;
                  u4 = 0, d2 = true;
                }
              }
              ++t3, f2 = f2 * i2 + u4;
            } else {
              const i3 = e3.charCodeAt(t3 - 1), s4 = e3.charCodeAt(t3 + 1);
              if (o2) {
                if (Number.isNaN(s4) || !h2(s4) || p2.has(i3) || p2.has(s4)) {
                  if (c2) return { n: null, pos: t3 };
                  l2.unexpectedNumericSeparator(t3, n3, r3);
                }
              } else {
                if (c2) return { n: null, pos: t3 };
                l2.numericSeparatorInEscapeSequence(t3, n3, r3);
              }
              ++t3;
            }
          }
          return t3 === u2 || null != s2 && t3 - u2 !== s2 || d2 ? { n: null, pos: t3 } : { n: f2, pos: t3 };
        }
        function Ve(e3, t3, n3, r3, i2, s2) {
          let a2;
          if (123 === e3.charCodeAt(t3)) {
            if (++t3, { code: a2, pos: t3 } = Re(e3, t3, n3, r3, e3.indexOf("}", t3) - t3, true, i2, s2), ++t3, null !== a2 && a2 > 1114111) {
              if (!i2) return { code: null, pos: t3 };
              s2.invalidCodePoint(t3, n3, r3);
            }
          } else ({ code: a2, pos: t3 } = Re(e3, t3, n3, r3, 4, false, i2, s2));
          return { code: a2, pos: t3 };
        }
        const Ke = ["at"], We = ["at"];
        function Xe(e3, t3, n3) {
          return new r2(n3, e3 - t3, e3);
        }
        const Ye = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]);
        class qe {
          constructor(e3) {
            this.type = e3.type, this.value = e3.value, this.start = e3.start, this.end = e3.end, this.loc = new i(e3.startLoc, e3.endLoc);
          }
        }
        class He extends De {
          constructor(e3, t3) {
            super(), this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = { invalidDigit: (e4, t4, n3, r3) => !!this.options.errorRecovery && (this.raise(g.InvalidDigit, { at: Xe(e4, t4, n3), radix: r3 }), true), numericSeparatorInEscapeSequence: this.errorBuilder(g.NumericSeparatorInEscapeSequence), unexpectedNumericSeparator: this.errorBuilder(g.UnexpectedNumericSeparator) }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, { invalidEscapeSequence: this.errorBuilder(g.InvalidEscapeSequence), invalidCodePoint: this.errorBuilder(g.InvalidCodePoint) }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, { strictNumericEscape: (e4, t4, n3) => {
              this.recordStrictModeErrors(g.StrictNumericEscape, { at: Xe(e4, t4, n3) });
            }, unterminated: (e4, t4, n3) => {
              throw this.raise(g.UnterminatedString, { at: Xe(e4 - 1, t4, n3) });
            } }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, { strictNumericEscape: this.errorBuilder(g.StrictNumericEscape), unterminated: (e4, t4, n3) => {
              throw this.raise(g.UnterminatedTemplate, { at: Xe(e4, t4, n3) });
            } }), this.state = new Fe(), this.state.init(e3), this.input = t3, this.length = t3.length, this.isLookahead = false;
          }
          pushToken(e3) {
            this.tokens.length = this.state.tokensLength, this.tokens.push(e3), ++this.state.tokensLength;
          }
          next() {
            this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new qe(this.state)), this.state.lastTokStart = this.state.start, this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
          }
          eat(e3) {
            return !!this.match(e3) && (this.next(), true);
          }
          match(e3) {
            return this.state.type === e3;
          }
          createLookaheadState(e3) {
            return { pos: e3.pos, value: null, type: e3.type, start: e3.start, end: e3.end, context: [this.curContext()], inType: e3.inType, startLoc: e3.startLoc, lastTokEndLoc: e3.lastTokEndLoc, curLine: e3.curLine, lineStart: e3.lineStart, curPosition: e3.curPosition };
          }
          lookahead() {
            const e3 = this.state;
            this.state = this.createLookaheadState(e3), this.isLookahead = true, this.nextToken(), this.isLookahead = false;
            const t3 = this.state;
            return this.state = e3, t3;
          }
          nextTokenStart() {
            return this.nextTokenStartSince(this.state.pos);
          }
          nextTokenStartSince(e3) {
            return we.lastIndex = e3, we.test(this.input) ? we.lastIndex : e3;
          }
          lookaheadCharCode() {
            return this.input.charCodeAt(this.nextTokenStart());
          }
          nextTokenInLineStart() {
            return this.nextTokenInLineStartSince(this.state.pos);
          }
          nextTokenInLineStartSince(e3) {
            return Oe.lastIndex = e3, Oe.test(this.input) ? Oe.lastIndex : e3;
          }
          lookaheadInLineCharCode() {
            return this.input.charCodeAt(this.nextTokenInLineStart());
          }
          codePointAtPos(e3) {
            let t3 = this.input.charCodeAt(e3);
            if (55296 == (64512 & t3) && ++e3 < this.input.length) {
              const n3 = this.input.charCodeAt(e3);
              56320 == (64512 & n3) && (t3 = 65536 + ((1023 & t3) << 10) + (1023 & n3));
            }
            return t3;
          }
          setStrict(e3) {
            this.state.strict = e3, e3 && (this.state.strictErrors.forEach(([e4, t3]) => this.raise(e4, { at: t3 })), this.state.strictErrors.clear());
          }
          curContext() {
            return this.state.context[this.state.context.length - 1];
          }
          nextToken() {
            this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length ? this.finishToken(137) : this.getTokenFromCode(this.codePointAtPos(this.state.pos));
          }
          skipBlockComment(e3) {
            let t3;
            this.isLookahead || (t3 = this.state.curPosition());
            const n3 = this.state.pos, r3 = this.input.indexOf(e3, n3 + 2);
            if (-1 === r3) throw this.raise(g.UnterminatedComment, { at: this.state.curPosition() });
            for (this.state.pos = r3 + e3.length, ve.lastIndex = n3 + 2; ve.test(this.input) && ve.lastIndex <= r3; ) ++this.state.curLine, this.state.lineStart = ve.lastIndex;
            if (this.isLookahead) return;
            const s2 = { type: "CommentBlock", value: this.input.slice(n3 + 2, r3), start: n3, end: r3 + e3.length, loc: new i(t3, this.state.curPosition()) };
            return this.options.tokens && this.pushToken(s2), s2;
          }
          skipLineComment(e3) {
            const t3 = this.state.pos;
            let n3;
            this.isLookahead || (n3 = this.state.curPosition());
            let r3 = this.input.charCodeAt(this.state.pos += e3);
            if (this.state.pos < this.length) for (; !Ce(r3) && ++this.state.pos < this.length; ) r3 = this.input.charCodeAt(this.state.pos);
            if (this.isLookahead) return;
            const s2 = this.state.pos, a2 = { type: "CommentLine", value: this.input.slice(t3 + e3, s2), start: t3, end: s2, loc: new i(n3, this.state.curPosition()) };
            return this.options.tokens && this.pushToken(a2), a2;
          }
          skipSpace() {
            const e3 = this.state.pos, t3 = [];
            e: for (; this.state.pos < this.length; ) {
              const n3 = this.input.charCodeAt(this.state.pos);
              switch (n3) {
                case 32:
                case 160:
                case 9:
                  ++this.state.pos;
                  break;
                case 13:
                  10 === this.input.charCodeAt(this.state.pos + 1) && ++this.state.pos;
                case 10:
                case 8232:
                case 8233:
                  ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
                  break;
                case 47:
                  switch (this.input.charCodeAt(this.state.pos + 1)) {
                    case 42: {
                      const e4 = this.skipBlockComment("*/");
                      void 0 !== e4 && (this.addComment(e4), this.options.attachComment && t3.push(e4));
                      break;
                    }
                    case 47: {
                      const e4 = this.skipLineComment(2);
                      void 0 !== e4 && (this.addComment(e4), this.options.attachComment && t3.push(e4));
                      break;
                    }
                    default:
                      break e;
                  }
                  break;
                default:
                  if (Ne(n3)) ++this.state.pos;
                  else if (45 === n3 && !this.inModule && this.options.annexB) {
                    const n4 = this.state.pos;
                    if (45 !== this.input.charCodeAt(n4 + 1) || 62 !== this.input.charCodeAt(n4 + 2) || !(0 === e3 || this.state.lineStart > e3)) break e;
                    {
                      const e4 = this.skipLineComment(3);
                      void 0 !== e4 && (this.addComment(e4), this.options.attachComment && t3.push(e4));
                    }
                  } else {
                    if (60 !== n3 || this.inModule || !this.options.annexB) break e;
                    {
                      const e4 = this.state.pos;
                      if (33 !== this.input.charCodeAt(e4 + 1) || 45 !== this.input.charCodeAt(e4 + 2) || 45 !== this.input.charCodeAt(e4 + 3)) break e;
                      {
                        const e5 = this.skipLineComment(4);
                        void 0 !== e5 && (this.addComment(e5), this.options.attachComment && t3.push(e5));
                      }
                    }
                  }
              }
            }
            if (t3.length > 0) {
              const n3 = { start: e3, end: this.state.pos, comments: t3, leadingNode: null, trailingNode: null, containingNode: null };
              this.state.commentStack.push(n3);
            }
          }
          finishToken(e3, t3) {
            this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
            const n3 = this.state.type;
            this.state.type = e3, this.state.value = t3, this.isLookahead || this.updateContext(n3);
          }
          replaceToken(e3) {
            this.state.type = e3, this.updateContext();
          }
          readToken_numberSign() {
            if (0 === this.state.pos && this.readToken_interpreter()) return;
            const e3 = this.state.pos + 1, t3 = this.codePointAtPos(e3);
            if (t3 >= 48 && t3 <= 57) throw this.raise(g.UnexpectedDigitAfterHash, { at: this.state.curPosition() });
            if (123 === t3 || 91 === t3 && this.hasPlugin("recordAndTuple")) {
              if (this.expectPlugin("recordAndTuple"), "bar" === this.getPluginOption("recordAndTuple", "syntaxType")) throw this.raise(123 === t3 ? g.RecordExpressionHashIncorrectStartSyntaxType : g.TupleExpressionHashIncorrectStartSyntaxType, { at: this.state.curPosition() });
              this.state.pos += 2, 123 === t3 ? this.finishToken(7) : this.finishToken(1);
            } else ae(t3) ? (++this.state.pos, this.finishToken(136, this.readWord1(t3))) : 92 === t3 ? (++this.state.pos, this.finishToken(136, this.readWord1())) : this.finishOp(27, 1);
          }
          readToken_dot() {
            const e3 = this.input.charCodeAt(this.state.pos + 1);
            e3 >= 48 && e3 <= 57 ? this.readNumber(true) : 46 === e3 && 46 === this.input.charCodeAt(this.state.pos + 2) ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(16));
          }
          readToken_slash() {
            61 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(31, 2) : this.finishOp(56, 1);
          }
          readToken_interpreter() {
            if (0 !== this.state.pos || this.length < 2) return false;
            let e3 = this.input.charCodeAt(this.state.pos + 1);
            if (33 !== e3) return false;
            const t3 = this.state.pos;
            for (this.state.pos += 1; !Ce(e3) && ++this.state.pos < this.length; ) e3 = this.input.charCodeAt(this.state.pos);
            const n3 = this.input.slice(t3 + 2, this.state.pos);
            return this.finishToken(28, n3), true;
          }
          readToken_mult_modulo(e3) {
            let t3 = 42 === e3 ? 55 : 54, n3 = 1, r3 = this.input.charCodeAt(this.state.pos + 1);
            42 === e3 && 42 === r3 && (n3++, r3 = this.input.charCodeAt(this.state.pos + 2), t3 = 57), 61 !== r3 || this.state.inType || (n3++, t3 = 37 === e3 ? 33 : 30), this.finishOp(t3, n3);
          }
          readToken_pipe_amp(e3) {
            const t3 = this.input.charCodeAt(this.state.pos + 1);
            if (t3 !== e3) {
              if (124 === e3) {
                if (62 === t3) return void this.finishOp(39, 2);
                if (this.hasPlugin("recordAndTuple") && 125 === t3) {
                  if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType")) throw this.raise(g.RecordExpressionBarIncorrectEndSyntaxType, { at: this.state.curPosition() });
                  return this.state.pos += 2, void this.finishToken(9);
                }
                if (this.hasPlugin("recordAndTuple") && 93 === t3) {
                  if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType")) throw this.raise(g.TupleExpressionBarIncorrectEndSyntaxType, { at: this.state.curPosition() });
                  return this.state.pos += 2, void this.finishToken(4);
                }
              }
              61 !== t3 ? this.finishOp(124 === e3 ? 43 : 45, 1) : this.finishOp(30, 2);
            } else 61 === this.input.charCodeAt(this.state.pos + 2) ? this.finishOp(30, 3) : this.finishOp(124 === e3 ? 41 : 42, 2);
          }
          readToken_caret() {
            const e3 = this.input.charCodeAt(this.state.pos + 1);
            61 !== e3 || this.state.inType ? 94 === e3 && this.hasPlugin(["pipelineOperator", { proposal: "hack", topicToken: "^^" }]) ? (this.finishOp(37, 2), 94 === this.input.codePointAt(this.state.pos) && this.unexpected()) : this.finishOp(44, 1) : this.finishOp(32, 2);
          }
          readToken_atSign() {
            64 === this.input.charCodeAt(this.state.pos + 1) && this.hasPlugin(["pipelineOperator", { proposal: "hack", topicToken: "@@" }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
          }
          readToken_plus_min(e3) {
            const t3 = this.input.charCodeAt(this.state.pos + 1);
            t3 !== e3 ? 61 === t3 ? this.finishOp(30, 2) : this.finishOp(53, 1) : this.finishOp(34, 2);
          }
          readToken_lt() {
            const { pos: e3 } = this.state, t3 = this.input.charCodeAt(e3 + 1);
            if (60 === t3) return 61 === this.input.charCodeAt(e3 + 2) ? void this.finishOp(30, 3) : void this.finishOp(51, 2);
            61 !== t3 ? this.finishOp(47, 1) : this.finishOp(49, 2);
          }
          readToken_gt() {
            const { pos: e3 } = this.state, t3 = this.input.charCodeAt(e3 + 1);
            if (62 === t3) {
              const t4 = 62 === this.input.charCodeAt(e3 + 2) ? 3 : 2;
              return 61 === this.input.charCodeAt(e3 + t4) ? void this.finishOp(30, t4 + 1) : void this.finishOp(52, t4);
            }
            61 !== t3 ? this.finishOp(48, 1) : this.finishOp(49, 2);
          }
          readToken_eq_excl(e3) {
            const t3 = this.input.charCodeAt(this.state.pos + 1);
            if (61 !== t3) return 61 === e3 && 62 === t3 ? (this.state.pos += 2, void this.finishToken(19)) : void this.finishOp(61 === e3 ? 29 : 35, 1);
            this.finishOp(46, 61 === this.input.charCodeAt(this.state.pos + 2) ? 3 : 2);
          }
          readToken_question() {
            const e3 = this.input.charCodeAt(this.state.pos + 1), t3 = this.input.charCodeAt(this.state.pos + 2);
            63 === e3 ? 61 === t3 ? this.finishOp(30, 3) : this.finishOp(40, 2) : 46 !== e3 || t3 >= 48 && t3 <= 57 ? (++this.state.pos, this.finishToken(17)) : (this.state.pos += 2, this.finishToken(18));
          }
          getTokenFromCode(e3) {
            switch (e3) {
              case 46:
                return void this.readToken_dot();
              case 40:
                return ++this.state.pos, void this.finishToken(10);
              case 41:
                return ++this.state.pos, void this.finishToken(11);
              case 59:
                return ++this.state.pos, void this.finishToken(13);
              case 44:
                return ++this.state.pos, void this.finishToken(12);
              case 91:
                if (this.hasPlugin("recordAndTuple") && 124 === this.input.charCodeAt(this.state.pos + 1)) {
                  if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType")) throw this.raise(g.TupleExpressionBarIncorrectStartSyntaxType, { at: this.state.curPosition() });
                  this.state.pos += 2, this.finishToken(2);
                } else ++this.state.pos, this.finishToken(0);
                return;
              case 93:
                return ++this.state.pos, void this.finishToken(3);
              case 123:
                if (this.hasPlugin("recordAndTuple") && 124 === this.input.charCodeAt(this.state.pos + 1)) {
                  if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType")) throw this.raise(g.RecordExpressionBarIncorrectStartSyntaxType, { at: this.state.curPosition() });
                  this.state.pos += 2, this.finishToken(6);
                } else ++this.state.pos, this.finishToken(5);
                return;
              case 125:
                return ++this.state.pos, void this.finishToken(8);
              case 58:
                return void (this.hasPlugin("functionBind") && 58 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(15, 2) : (++this.state.pos, this.finishToken(14)));
              case 63:
                return void this.readToken_question();
              case 96:
                return void this.readTemplateToken();
              case 48: {
                const e4 = this.input.charCodeAt(this.state.pos + 1);
                if (120 === e4 || 88 === e4) return void this.readRadixNumber(16);
                if (111 === e4 || 79 === e4) return void this.readRadixNumber(8);
                if (98 === e4 || 66 === e4) return void this.readRadixNumber(2);
              }
              case 49:
              case 50:
              case 51:
              case 52:
              case 53:
              case 54:
              case 55:
              case 56:
              case 57:
                return void this.readNumber(false);
              case 34:
              case 39:
                return void this.readString(e3);
              case 47:
                return void this.readToken_slash();
              case 37:
              case 42:
                return void this.readToken_mult_modulo(e3);
              case 124:
              case 38:
                return void this.readToken_pipe_amp(e3);
              case 94:
                return void this.readToken_caret();
              case 43:
              case 45:
                return void this.readToken_plus_min(e3);
              case 60:
                return void this.readToken_lt();
              case 62:
                return void this.readToken_gt();
              case 61:
              case 33:
                return void this.readToken_eq_excl(e3);
              case 126:
                return void this.finishOp(36, 1);
              case 64:
                return void this.readToken_atSign();
              case 35:
                return void this.readToken_numberSign();
              case 92:
                return void this.readWord();
              default:
                if (ae(e3)) return void this.readWord(e3);
            }
            throw this.raise(g.InvalidOrUnexpectedToken, { at: this.state.curPosition(), unexpected: String.fromCodePoint(e3) });
          }
          finishOp(e3, t3) {
            const n3 = this.input.slice(this.state.pos, this.state.pos + t3);
            this.state.pos += t3, this.finishToken(e3, n3);
          }
          readRegexp() {
            const e3 = this.state.startLoc, t3 = this.state.start + 1;
            let n3, r3, { pos: i2 } = this.state;
            for (; ; ++i2) {
              if (i2 >= this.length) throw this.raise(g.UnterminatedRegExp, { at: s(e3, 1) });
              const t4 = this.input.charCodeAt(i2);
              if (Ce(t4)) throw this.raise(g.UnterminatedRegExp, { at: s(e3, 1) });
              if (n3) n3 = false;
              else {
                if (91 === t4) r3 = true;
                else if (93 === t4 && r3) r3 = false;
                else if (47 === t4 && !r3) break;
                n3 = 92 === t4;
              }
            }
            const a2 = this.input.slice(t3, i2);
            ++i2;
            let o2 = "";
            const l2 = () => s(e3, i2 + 2 - t3);
            for (; i2 < this.length; ) {
              const e4 = this.codePointAtPos(i2), t4 = String.fromCharCode(e4);
              if (Ye.has(e4)) 118 === e4 ? o2.includes("u") && this.raise(g.IncompatibleRegExpUVFlags, { at: l2() }) : 117 === e4 && o2.includes("v") && this.raise(g.IncompatibleRegExpUVFlags, { at: l2() }), o2.includes(t4) && this.raise(g.DuplicateRegExpFlags, { at: l2() });
              else {
                if (!oe(e4) && 92 !== e4) break;
                this.raise(g.MalformedRegExpFlags, { at: l2() });
              }
              ++i2, o2 += t4;
            }
            this.state.pos = i2, this.finishToken(135, { pattern: a2, flags: o2 });
          }
          readInt(e3, t3, n3 = false, r3 = true) {
            const { n: i2, pos: s2 } = Ue(this.input, this.state.pos, this.state.lineStart, this.state.curLine, e3, t3, n3, r3, this.errorHandlers_readInt, false);
            return this.state.pos = s2, i2;
          }
          readRadixNumber(e3) {
            const t3 = this.state.curPosition();
            let n3 = false;
            this.state.pos += 2;
            const r3 = this.readInt(e3);
            null == r3 && this.raise(g.InvalidDigit, { at: s(t3, 2), radix: e3 });
            const i2 = this.input.charCodeAt(this.state.pos);
            if (110 === i2) ++this.state.pos, n3 = true;
            else if (109 === i2) throw this.raise(g.InvalidDecimal, { at: t3 });
            if (ae(this.codePointAtPos(this.state.pos))) throw this.raise(g.NumberIdentifier, { at: this.state.curPosition() });
            if (n3) {
              const e4 = this.input.slice(t3.index, this.state.pos).replace(/[_n]/g, "");
              this.finishToken(133, e4);
            } else this.finishToken(132, r3);
          }
          readNumber(e3) {
            const t3 = this.state.pos, n3 = this.state.curPosition();
            let r3 = false, i2 = false, a2 = false, o2 = false, l2 = false;
            e3 || null !== this.readInt(10) || this.raise(g.InvalidNumber, { at: this.state.curPosition() });
            const c2 = this.state.pos - t3 >= 2 && 48 === this.input.charCodeAt(t3);
            if (c2) {
              const e4 = this.input.slice(t3, this.state.pos);
              if (this.recordStrictModeErrors(g.StrictOctalLiteral, { at: n3 }), !this.state.strict) {
                const t4 = e4.indexOf("_");
                t4 > 0 && this.raise(g.ZeroDigitNumericSeparator, { at: s(n3, t4) });
              }
              l2 = c2 && !/[89]/.test(e4);
            }
            let u2 = this.input.charCodeAt(this.state.pos);
            if (46 !== u2 || l2 || (++this.state.pos, this.readInt(10), r3 = true, u2 = this.input.charCodeAt(this.state.pos)), 69 !== u2 && 101 !== u2 || l2 || (u2 = this.input.charCodeAt(++this.state.pos), 43 !== u2 && 45 !== u2 || ++this.state.pos, null === this.readInt(10) && this.raise(g.InvalidOrMissingExponent, { at: n3 }), r3 = true, o2 = true, u2 = this.input.charCodeAt(this.state.pos)), 110 === u2 && ((r3 || c2) && this.raise(g.InvalidBigIntLiteral, { at: n3 }), ++this.state.pos, i2 = true), 109 === u2 && (this.expectPlugin("decimal", this.state.curPosition()), (o2 || c2) && this.raise(g.InvalidDecimal, { at: n3 }), ++this.state.pos, a2 = true), ae(this.codePointAtPos(this.state.pos))) throw this.raise(g.NumberIdentifier, { at: this.state.curPosition() });
            const p2 = this.input.slice(t3, this.state.pos).replace(/[_mn]/g, "");
            if (i2) return void this.finishToken(133, p2);
            if (a2) return void this.finishToken(134, p2);
            const h2 = l2 ? parseInt(p2, 8) : parseFloat(p2);
            this.finishToken(132, h2);
          }
          readCodePoint(e3) {
            const { code: t3, pos: n3 } = Ve(this.input, this.state.pos, this.state.lineStart, this.state.curLine, e3, this.errorHandlers_readCodePoint);
            return this.state.pos = n3, t3;
          }
          readString(e3) {
            const { str: t3, pos: n3, curLine: r3, lineStart: i2 } = Me(34 === e3 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
            this.state.pos = n3 + 1, this.state.lineStart = i2, this.state.curLine = r3, this.finishToken(131, t3);
          }
          readTemplateContinuation() {
            this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
          }
          readTemplateToken() {
            const e3 = this.input[this.state.pos], { str: t3, firstInvalidLoc: n3, pos: i2, curLine: s2, lineStart: a2 } = Me("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
            this.state.pos = i2 + 1, this.state.lineStart = a2, this.state.curLine = s2, n3 && (this.state.firstInvalidTemplateEscapePos = new r2(n3.curLine, n3.pos - n3.lineStart, n3.pos)), 96 === this.input.codePointAt(i2) ? this.finishToken(24, n3 ? null : e3 + t3 + "`") : (this.state.pos++, this.finishToken(25, n3 ? null : e3 + t3 + "${"));
          }
          recordStrictModeErrors(e3, { at: t3 }) {
            const n3 = t3.index;
            this.state.strict && !this.state.strictErrors.has(n3) ? this.raise(e3, { at: t3 }) : this.state.strictErrors.set(n3, [e3, t3]);
          }
          readWord1(e3) {
            this.state.containsEsc = false;
            let t3 = "";
            const n3 = this.state.pos;
            let r3 = this.state.pos;
            for (void 0 !== e3 && (this.state.pos += e3 <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
              const e4 = this.codePointAtPos(this.state.pos);
              if (oe(e4)) this.state.pos += e4 <= 65535 ? 1 : 2;
              else {
                if (92 !== e4) break;
                {
                  this.state.containsEsc = true, t3 += this.input.slice(r3, this.state.pos);
                  const e5 = this.state.curPosition(), i2 = this.state.pos === n3 ? ae : oe;
                  if (117 !== this.input.charCodeAt(++this.state.pos)) {
                    this.raise(g.MissingUnicodeEscape, { at: this.state.curPosition() }), r3 = this.state.pos - 1;
                    continue;
                  }
                  ++this.state.pos;
                  const s2 = this.readCodePoint(true);
                  null !== s2 && (i2(s2) || this.raise(g.EscapedCharNotAnIdentifier, { at: e5 }), t3 += String.fromCodePoint(s2)), r3 = this.state.pos;
                }
              }
            }
            return t3 + this.input.slice(r3, this.state.pos);
          }
          readWord(e3) {
            const t3 = this.readWord1(e3), n3 = I.get(t3);
            void 0 !== n3 ? this.finishToken(n3, $(n3)) : this.finishToken(130, t3);
          }
          checkKeywordEscapes() {
            const { type: e3 } = this.state;
            J(e3) && this.state.containsEsc && this.raise(g.InvalidEscapedReservedWord, { at: this.state.startLoc, reservedWord: $(e3) });
          }
          raise(e3, t3) {
            const { at: i2 } = t3, s2 = n2(t3, Ke), a2 = e3({ loc: i2 instanceof r2 ? i2 : i2.loc.start, details: s2 });
            if (!this.options.errorRecovery) throw a2;
            return this.isLookahead || this.state.errors.push(a2), a2;
          }
          raiseOverwrite(e3, t3) {
            const { at: i2 } = t3, s2 = n2(t3, We), a2 = i2 instanceof r2 ? i2 : i2.loc.start, o2 = a2.index, l2 = this.state.errors;
            for (let t4 = l2.length - 1; t4 >= 0; t4--) {
              const n3 = l2[t4];
              if (n3.loc.index === o2) return l2[t4] = e3({ loc: a2, details: s2 });
              if (n3.loc.index < o2) break;
            }
            return this.raise(e3, t3);
          }
          updateContext(e3) {
          }
          unexpected(e3, t3) {
            throw this.raise(g.UnexpectedToken, { expected: t3 ? $(t3) : null, at: null != e3 ? e3 : this.state.startLoc });
          }
          expectPlugin(e3, t3) {
            if (this.hasPlugin(e3)) return true;
            throw this.raise(g.MissingPlugin, { at: null != t3 ? t3 : this.state.startLoc, missingPlugin: [e3] });
          }
          expectOnePlugin(e3) {
            if (!e3.some((e4) => this.hasPlugin(e4))) throw this.raise(g.MissingOneOfPlugins, { at: this.state.startLoc, missingPlugin: e3 });
          }
          errorBuilder(e3) {
            return (t3, n3, r3) => {
              this.raise(e3, { at: Xe(t3, n3, r3) });
            };
          }
        }
        class Je {
          constructor() {
            this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
          }
        }
        class $e {
          constructor(e3) {
            this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = e3;
          }
          current() {
            return this.stack[this.stack.length - 1];
          }
          enter() {
            this.stack.push(new Je());
          }
          exit() {
            const e3 = this.stack.pop(), t3 = this.current();
            for (const [n3, r3] of Array.from(e3.undefinedPrivateNames)) t3 ? t3.undefinedPrivateNames.has(n3) || t3.undefinedPrivateNames.set(n3, r3) : this.parser.raise(g.InvalidPrivateFieldResolution, { at: r3, identifierName: n3 });
          }
          declarePrivateName(e3, t3, n3) {
            const { privateNames: r3, loneAccessors: i2, undefinedPrivateNames: s2 } = this.current();
            let a2 = r3.has(e3);
            if (3 & t3) {
              const n4 = a2 && i2.get(e3);
              n4 ? (a2 = (3 & n4) == (3 & t3) || (4 & n4) != (4 & t3), a2 || i2.delete(e3)) : a2 || i2.set(e3, t3);
            }
            a2 && this.parser.raise(g.PrivateNameRedeclaration, { at: n3, identifierName: e3 }), r3.add(e3), s2.delete(e3);
          }
          usePrivateName(e3, t3) {
            let n3;
            for (n3 of this.stack) if (n3.privateNames.has(e3)) return;
            n3 ? n3.undefinedPrivateNames.set(e3, t3) : this.parser.raise(g.InvalidPrivateFieldResolution, { at: t3, identifierName: e3 });
          }
        }
        class Ge {
          constructor(e3 = 0) {
            this.type = e3;
          }
          canBeArrowParameterDeclaration() {
            return 2 === this.type || 1 === this.type;
          }
          isCertainlyParameterDeclaration() {
            return 3 === this.type;
          }
        }
        class ze extends Ge {
          constructor(e3) {
            super(e3), this.declarationErrors = /* @__PURE__ */ new Map();
          }
          recordDeclarationError(e3, { at: t3 }) {
            const n3 = t3.index;
            this.declarationErrors.set(n3, [e3, t3]);
          }
          clearDeclarationError(e3) {
            this.declarationErrors.delete(e3);
          }
          iterateErrors(e3) {
            this.declarationErrors.forEach(e3);
          }
        }
        class Qe {
          constructor(e3) {
            this.parser = void 0, this.stack = [new Ge()], this.parser = e3;
          }
          enter(e3) {
            this.stack.push(e3);
          }
          exit() {
            this.stack.pop();
          }
          recordParameterInitializerError(e3, { at: t3 }) {
            const n3 = { at: t3.loc.start }, { stack: r3 } = this;
            let i2 = r3.length - 1, s2 = r3[i2];
            for (; !s2.isCertainlyParameterDeclaration(); ) {
              if (!s2.canBeArrowParameterDeclaration()) return;
              s2.recordDeclarationError(e3, n3), s2 = r3[--i2];
            }
            this.parser.raise(e3, n3);
          }
          recordArrowParameterBindingError(e3, { at: t3 }) {
            const { stack: n3 } = this, r3 = n3[n3.length - 1], i2 = { at: t3.loc.start };
            if (r3.isCertainlyParameterDeclaration()) this.parser.raise(e3, i2);
            else {
              if (!r3.canBeArrowParameterDeclaration()) return;
              r3.recordDeclarationError(e3, i2);
            }
          }
          recordAsyncArrowParametersError({ at: e3 }) {
            const { stack: t3 } = this;
            let n3 = t3.length - 1, r3 = t3[n3];
            for (; r3.canBeArrowParameterDeclaration(); ) 2 === r3.type && r3.recordDeclarationError(g.AwaitBindingIdentifier, { at: e3 }), r3 = t3[--n3];
          }
          validateAsPattern() {
            const { stack: e3 } = this, t3 = e3[e3.length - 1];
            t3.canBeArrowParameterDeclaration() && t3.iterateErrors(([t4, n3]) => {
              this.parser.raise(t4, { at: n3 });
              let r3 = e3.length - 2, i2 = e3[r3];
              for (; i2.canBeArrowParameterDeclaration(); ) i2.clearDeclarationError(n3.index), i2 = e3[--r3];
            });
          }
        }
        function Ze() {
          return new Ge();
        }
        class et {
          constructor() {
            this.stacks = [];
          }
          enter(e3) {
            this.stacks.push(e3);
          }
          exit() {
            this.stacks.pop();
          }
          currentFlags() {
            return this.stacks[this.stacks.length - 1];
          }
          get hasAwait() {
            return (2 & this.currentFlags()) > 0;
          }
          get hasYield() {
            return (1 & this.currentFlags()) > 0;
          }
          get hasReturn() {
            return (4 & this.currentFlags()) > 0;
          }
          get hasIn() {
            return (8 & this.currentFlags()) > 0;
          }
        }
        function tt(e3, t3) {
          return (e3 ? 2 : 0) | (t3 ? 1 : 0);
        }
        class nt extends He {
          addExtra(e3, t3, n3, r3 = true) {
            if (!e3) return;
            const i2 = e3.extra = e3.extra || {};
            r3 ? i2[t3] = n3 : Object.defineProperty(i2, t3, { enumerable: r3, value: n3 });
          }
          isContextual(e3) {
            return this.state.type === e3 && !this.state.containsEsc;
          }
          isUnparsedContextual(e3, t3) {
            const n3 = e3 + t3.length;
            if (this.input.slice(e3, n3) === t3) {
              const e4 = this.input.charCodeAt(n3);
              return !(oe(e4) || 55296 == (64512 & e4));
            }
            return false;
          }
          isLookaheadContextual(e3) {
            const t3 = this.nextTokenStart();
            return this.isUnparsedContextual(t3, e3);
          }
          eatContextual(e3) {
            return !!this.isContextual(e3) && (this.next(), true);
          }
          expectContextual(e3, t3) {
            if (!this.eatContextual(e3)) {
              if (null != t3) throw this.raise(t3, { at: this.state.startLoc });
              this.unexpected(null, e3);
            }
          }
          canInsertSemicolon() {
            return this.match(137) || this.match(8) || this.hasPrecedingLineBreak();
          }
          hasPrecedingLineBreak() {
            return Ae.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
          }
          hasFollowingLineBreak() {
            return Ie.lastIndex = this.state.end, Ie.test(this.input);
          }
          isLineTerminator() {
            return this.eat(13) || this.canInsertSemicolon();
          }
          semicolon(e3 = true) {
            (e3 ? this.isLineTerminator() : this.eat(13)) || this.raise(g.MissingSemicolon, { at: this.state.lastTokEndLoc });
          }
          expect(e3, t3) {
            this.eat(e3) || this.unexpected(t3, e3);
          }
          tryParse(e3, t3 = this.state.clone()) {
            const n3 = { node: null };
            try {
              const r3 = e3((e4 = null) => {
                throw n3.node = e4, n3;
              });
              if (this.state.errors.length > t3.errors.length) {
                const e4 = this.state;
                return this.state = t3, this.state.tokensLength = e4.tokensLength, { node: r3, error: e4.errors[t3.errors.length], thrown: false, aborted: false, failState: e4 };
              }
              return { node: r3, error: null, thrown: false, aborted: false, failState: null };
            } catch (e4) {
              const r3 = this.state;
              if (this.state = t3, e4 instanceof SyntaxError) return { node: null, error: e4, thrown: true, aborted: false, failState: r3 };
              if (e4 === n3) return { node: n3.node, error: null, thrown: false, aborted: true, failState: r3 };
              throw e4;
            }
          }
          checkExpressionErrors(e3, t3) {
            if (!e3) return false;
            const { shorthandAssignLoc: n3, doubleProtoLoc: r3, privateKeyLoc: i2, optionalParametersLoc: s2 } = e3;
            if (!t3) return !!(n3 || r3 || s2 || i2);
            null != n3 && this.raise(g.InvalidCoverInitializedName, { at: n3 }), null != r3 && this.raise(g.DuplicateProto, { at: r3 }), null != i2 && this.raise(g.UnexpectedPrivateField, { at: i2 }), null != s2 && this.unexpected(s2);
          }
          isLiteralPropertyName() {
            return Y(this.state.type);
          }
          isPrivateName(e3) {
            return "PrivateName" === e3.type;
          }
          getPrivateNameSV(e3) {
            return e3.id.name;
          }
          hasPropertyAsPrivateName(e3) {
            return ("MemberExpression" === e3.type || "OptionalMemberExpression" === e3.type) && this.isPrivateName(e3.property);
          }
          isObjectProperty(e3) {
            return "ObjectProperty" === e3.type;
          }
          isObjectMethod(e3) {
            return "ObjectMethod" === e3.type;
          }
          initializeScopes(e3 = "module" === this.options.sourceType) {
            const t3 = this.state.labels;
            this.state.labels = [];
            const n3 = this.exportedIdentifiers;
            this.exportedIdentifiers = /* @__PURE__ */ new Set();
            const r3 = this.inModule;
            this.inModule = e3;
            const i2 = this.scope, s2 = this.getScopeHandler();
            this.scope = new s2(this, e3);
            const a2 = this.prodParam;
            this.prodParam = new et();
            const o2 = this.classScope;
            this.classScope = new $e(this);
            const l2 = this.expressionScope;
            return this.expressionScope = new Qe(this), () => {
              this.state.labels = t3, this.exportedIdentifiers = n3, this.inModule = r3, this.scope = i2, this.prodParam = a2, this.classScope = o2, this.expressionScope = l2;
            };
          }
          enterInitialScopes() {
            let e3 = 0;
            this.inModule && (e3 |= 2), this.scope.enter(1), this.prodParam.enter(e3);
          }
          checkDestructuringPrivate(e3) {
            const { privateKeyLoc: t3 } = e3;
            null !== t3 && this.expectPlugin("destructuringPrivate", t3);
          }
        }
        class rt {
          constructor() {
            this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null;
          }
        }
        class it {
          constructor(e3, t3, n3) {
            this.type = "", this.start = t3, this.end = 0, this.loc = new i(n3), null != e3 && e3.options.ranges && (this.range = [t3, 0]), null != e3 && e3.filename && (this.loc.filename = e3.filename);
          }
        }
        const st = it.prototype;
        function at(e3) {
          const { type: t3, start: n3, end: r3, loc: i2, range: s2, extra: a2, name: o2 } = e3, l2 = Object.create(st);
          return l2.type = t3, l2.start = n3, l2.end = r3, l2.loc = i2, l2.range = s2, l2.extra = a2, l2.name = o2, "Placeholder" === t3 && (l2.expectedNode = e3.expectedNode), l2;
        }
        st.__clone = function() {
          const e3 = new it(void 0, this.start, this.loc.start), t3 = Object.keys(this);
          for (let n3 = 0, r3 = t3.length; n3 < r3; n3++) {
            const r4 = t3[n3];
            "leadingComments" !== r4 && "trailingComments" !== r4 && "innerComments" !== r4 && (e3[r4] = this[r4]);
          }
          return e3;
        };
        class ot extends nt {
          startNode() {
            return new it(this, this.state.start, this.state.startLoc);
          }
          startNodeAt(e3) {
            return new it(this, e3.index, e3);
          }
          startNodeAtNode(e3) {
            return this.startNodeAt(e3.loc.start);
          }
          finishNode(e3, t3) {
            return this.finishNodeAt(e3, t3, this.state.lastTokEndLoc);
          }
          finishNodeAt(e3, t3, n3) {
            return e3.type = t3, e3.end = n3.index, e3.loc.end = n3, this.options.ranges && (e3.range[1] = n3.index), this.options.attachComment && this.processComment(e3), e3;
          }
          resetStartLocation(e3, t3) {
            e3.start = t3.index, e3.loc.start = t3, this.options.ranges && (e3.range[0] = t3.index);
          }
          resetEndLocation(e3, t3 = this.state.lastTokEndLoc) {
            e3.end = t3.index, e3.loc.end = t3, this.options.ranges && (e3.range[1] = t3.index);
          }
          resetStartLocationFromNode(e3, t3) {
            this.resetStartLocation(e3, t3.loc.start);
          }
        }
        const lt = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]), ct = T`flow`({ AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.", AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.", AssignReservedType: ({ reservedType: e3 }) => `Cannot overwrite reserved type ${e3}.`, DeclareClassElement: "The `declare` modifier can only appear on class fields.", DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.", DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.", EnumBooleanMemberNotInitialized: ({ memberName: e3, enumName: t3 }) => `Boolean enum members need to be initialized. Use either \`${e3} = true,\` or \`${e3} = false,\` in enum \`${t3}\`.`, EnumDuplicateMemberName: ({ memberName: e3, enumName: t3 }) => `Enum member names need to be unique, but the name \`${e3}\` has already been used before in enum \`${t3}\`.`, EnumInconsistentMemberValues: ({ enumName: e3 }) => `Enum \`${e3}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`, EnumInvalidExplicitType: ({ invalidEnumType: e3, enumName: t3 }) => `Enum type \`${e3}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${t3}\`.`, EnumInvalidExplicitTypeUnknownSupplied: ({ enumName: e3 }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${e3}\`.`, EnumInvalidMemberInitializerPrimaryType: ({ enumName: e3, memberName: t3, explicitType: n3 }) => `Enum \`${e3}\` has type \`${n3}\`, so the initializer of \`${t3}\` needs to be a ${n3} literal.`, EnumInvalidMemberInitializerSymbolType: ({ enumName: e3, memberName: t3 }) => `Symbol enum members cannot be initialized. Use \`${t3},\` in enum \`${e3}\`.`, EnumInvalidMemberInitializerUnknownType: ({ enumName: e3, memberName: t3 }) => `The enum member initializer for \`${t3}\` needs to be a literal (either a boolean, number, or string) in enum \`${e3}\`.`, EnumInvalidMemberName: ({ enumName: e3, memberName: t3, suggestion: n3 }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${t3}\`, consider using \`${n3}\`, in enum \`${e3}\`.`, EnumNumberMemberNotInitialized: ({ enumName: e3, memberName: t3 }) => `Number enum members need to be initialized, e.g. \`${t3} = 1\` in enum \`${e3}\`.`, EnumStringMemberInconsistentlyInitialized: ({ enumName: e3 }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${e3}\`.`, GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.", ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.", ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.", InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.", InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.", InexactVariance: "Explicit inexact syntax cannot have variance.", InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.", MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.", NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.", NestedFlowComment: "Cannot have a flow comment inside another flow comment.", PatternIsOptional: Object.assign({ message: "A binding pattern parameter cannot be optional in an implementation signature." }, { reasonCode: "OptionalBindingPattern" }), SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.", SpreadVariance: "Spread properties cannot have variance.", ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.", ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.", ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.", ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.", ThisParamNoDefault: "The `this` parameter may not have a default value.", TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.", UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.", UnexpectedReservedType: ({ reservedType: e3 }) => `Unexpected reserved type ${e3}.`, UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.", UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.", UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.", UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".', UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.", UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.", UnsupportedDeclareExportKind: ({ unsupportedExportKind: e3, suggestion: t3 }) => `\`declare export ${e3}\` is not supported. Use \`${t3}\` instead.`, UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.", UnterminatedFlowComment: "Unterminated flow-comment." });
        function ut(e3) {
          return "type" === e3.importKind || "typeof" === e3.importKind;
        }
        const pt = { const: "declare export var", let: "declare export var", type: "export type", interface: "export interface" }, ht = /\*?\s*@((?:no)?flow)\b/, dt = { __proto__: null, quot: '"', amp: "&", apos: "'", lt: "<", gt: ">", nbsp: "", iexcl: "", cent: "", pound: "", curren: "", yen: "", brvbar: "", sect: "", uml: "", copy: "", ordf: "", laquo: "", not: "", shy: "", reg: "", macr: "", deg: "", plusmn: "", sup2: "", sup3: "", acute: "", micro: "", para: "", middot: "", cedil: "", sup1: "", ordm: "", raquo: "", frac14: "", frac12: "", frac34: "", iquest: "", Agrave: "", Aacute: "", Acirc: "", Atilde: "", Auml: "", Aring: "", AElig: "", Ccedil: "", Egrave: "", Eacute: "", Ecirc: "", Euml: "", Igrave: "", Iacute: "", Icirc: "", Iuml: "", ETH: "", Ntilde: "", Ograve: "", Oacute: "", Ocirc: "", Otilde: "", Ouml: "", times: "", Oslash: "", Ugrave: "", Uacute: "", Ucirc: "", Uuml: "", Yacute: "", THORN: "", szlig: "", agrave: "", aacute: "", acirc: "", atilde: "", auml: "", aring: "", aelig: "", ccedil: "", egrave: "", eacute: "", ecirc: "", euml: "", igrave: "", iacute: "", icirc: "", iuml: "", eth: "", ntilde: "", ograve: "", oacute: "", ocirc: "", otilde: "", ouml: "", divide: "", oslash: "", ugrave: "", uacute: "", ucirc: "", uuml: "", yacute: "", thorn: "", yuml: "", OElig: "", oelig: "", Scaron: "", scaron: "", Yuml: "", fnof: "", circ: "", tilde: "", Alpha: "", Beta: "", Gamma: "", Delta: "", Epsilon: "", Zeta: "", Eta: "", Theta: "", Iota: "", Kappa: "", Lambda: "", Mu: "", Nu: "", Xi: "", Omicron: "", Pi: "", Rho: "", Sigma: "", Tau: "", Upsilon: "", Phi: "", Chi: "", Psi: "", Omega: "", alpha: "", beta: "", gamma: "", delta: "", epsilon: "", zeta: "", eta: "", theta: "", iota: "", kappa: "", lambda: "", mu: "", nu: "", xi: "", omicron: "", pi: "", rho: "", sigmaf: "", sigma: "", tau: "", upsilon: "", phi: "", chi: "", psi: "", omega: "", thetasym: "", upsih: "", piv: "", ensp: "", emsp: "", thinsp: "", zwnj: "", zwj: "", lrm: "", rlm: "", ndash: "", mdash: "", lsquo: "", rsquo: "", sbquo: "", ldquo: "", rdquo: "", bdquo: "", dagger: "", Dagger: "", bull: "", hellip: "", permil: "", prime: "", Prime: "", lsaquo: "", rsaquo: "", oline: "", frasl: "", euro: "", image: "", weierp: "", real: "", trade: "", alefsym: "", larr: "", uarr: "", rarr: "", darr: "", harr: "", crarr: "", lArr: "", uArr: "", rArr: "", dArr: "", hArr: "", forall: "", part: "", exist: "", empty: "", nabla: "", isin: "", notin: "", ni: "", prod: "", sum: "", minus: "", lowast: "", radic: "", prop: "", infin: "", ang: "", and: "", or: "", cap: "", cup: "", int: "", there4: "", sim: "", cong: "", asymp: "", ne: "", equiv: "", le: "", ge: "", sub: "", sup: "", nsub: "", sube: "", supe: "", oplus: "", otimes: "", perp: "", sdot: "", lceil: "", rceil: "", lfloor: "", rfloor: "", lang: "", rang: "", loz: "", spades: "", clubs: "", hearts: "", diams: "" }, ft = T`jsx`({ AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.", MissingClosingTagElement: ({ openingTagName: e3 }) => `Expected corresponding JSX closing tag for <${e3}>.`, MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.", UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?", UnexpectedToken: ({ unexpected: e3, HTMLEntity: t3 }) => `Unexpected token \`${e3}\`. Did you mean \`${t3}\` or \`{'${e3}'}\`?`, UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.", UnterminatedJsxContent: "Unterminated JSX contents.", UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?" });
        function yt(e3) {
          return !!e3 && ("JSXOpeningFragment" === e3.type || "JSXClosingFragment" === e3.type);
        }
        function mt(e3) {
          if ("JSXIdentifier" === e3.type) return e3.name;
          if ("JSXNamespacedName" === e3.type) return e3.namespace.name + ":" + e3.name.name;
          if ("JSXMemberExpression" === e3.type) return mt(e3.object) + "." + mt(e3.property);
          throw new Error("Node had unexpected type: " + e3.type);
        }
        class Tt extends me {
          constructor(...e3) {
            super(...e3), this.types = /* @__PURE__ */ new Set(), this.enums = /* @__PURE__ */ new Set(), this.constEnums = /* @__PURE__ */ new Set(), this.classes = /* @__PURE__ */ new Set(), this.exportOnlyBindings = /* @__PURE__ */ new Set();
          }
        }
        class gt extends Te {
          constructor(...e3) {
            super(...e3), this.importsStack = [];
          }
          createScope(e3) {
            return this.importsStack.push(/* @__PURE__ */ new Set()), new Tt(e3);
          }
          enter(e3) {
            256 == e3 && this.importsStack.push(/* @__PURE__ */ new Set()), super.enter(e3);
          }
          exit() {
            const e3 = super.exit();
            return 256 == e3 && this.importsStack.pop(), e3;
          }
          hasImport(e3, t3) {
            const n3 = this.importsStack.length;
            if (this.importsStack[n3 - 1].has(e3)) return true;
            if (!t3 && n3 > 1) {
              for (let t4 = 0; t4 < n3 - 1; t4++) if (this.importsStack[t4].has(e3)) return true;
            }
            return false;
          }
          declareName(e3, t3, n3) {
            if (4096 & t3) return this.hasImport(e3, true) && this.parser.raise(g.VarRedeclaration, { at: n3, identifierName: e3 }), void this.importsStack[this.importsStack.length - 1].add(e3);
            const r3 = this.currentScope();
            if (1024 & t3) return this.maybeExportDefined(r3, e3), void r3.exportOnlyBindings.add(e3);
            super.declareName(e3, t3, n3), 2 & t3 && (1 & t3 || (this.checkRedeclarationInScope(r3, e3, t3, n3), this.maybeExportDefined(r3, e3)), r3.types.add(e3)), 256 & t3 && r3.enums.add(e3), 512 & t3 && r3.constEnums.add(e3), 128 & t3 && r3.classes.add(e3);
          }
          isRedeclaredInScope(e3, t3, n3) {
            return e3.enums.has(t3) ? !(256 & n3) || !!(512 & n3) !== e3.constEnums.has(t3) : 128 & n3 && e3.classes.has(t3) ? !!e3.lexical.has(t3) && !!(1 & n3) : !!(2 & n3 && e3.types.has(t3)) || super.isRedeclaredInScope(e3, t3, n3);
          }
          checkLocalExport(e3) {
            const { name: t3 } = e3;
            if (!this.hasImport(t3)) {
              for (let e4 = this.scopeStack.length - 1; e4 >= 0; e4--) {
                const n3 = this.scopeStack[e4];
                if (n3.types.has(t3) || n3.exportOnlyBindings.has(t3)) return;
              }
              super.checkLocalExport(e3);
            }
          }
        }
        const bt = (e3) => "ParenthesizedExpression" === e3.type ? bt(e3.expression) : e3;
        class Et extends ot {
          toAssignable(e3, t3 = false) {
            var n3, r3;
            let i2;
            switch (("ParenthesizedExpression" === e3.type || null != (n3 = e3.extra) && n3.parenthesized) && (i2 = bt(e3), t3 ? "Identifier" === i2.type ? this.expressionScope.recordArrowParameterBindingError(g.InvalidParenthesizedAssignment, { at: e3 }) : "MemberExpression" !== i2.type && this.raise(g.InvalidParenthesizedAssignment, { at: e3 }) : this.raise(g.InvalidParenthesizedAssignment, { at: e3 })), e3.type) {
              case "Identifier":
              case "ObjectPattern":
              case "ArrayPattern":
              case "AssignmentPattern":
              case "RestElement":
                break;
              case "ObjectExpression":
                e3.type = "ObjectPattern";
                for (let n4 = 0, r4 = e3.properties.length, i3 = r4 - 1; n4 < r4; n4++) {
                  var s2;
                  const r5 = e3.properties[n4], a2 = n4 === i3;
                  this.toAssignableObjectExpressionProp(r5, a2, t3), a2 && "RestElement" === r5.type && null != (s2 = e3.extra) && s2.trailingCommaLoc && this.raise(g.RestTrailingComma, { at: e3.extra.trailingCommaLoc });
                }
                break;
              case "ObjectProperty": {
                const { key: n4, value: r4 } = e3;
                this.isPrivateName(n4) && this.classScope.usePrivateName(this.getPrivateNameSV(n4), n4.loc.start), this.toAssignable(r4, t3);
                break;
              }
              case "SpreadElement":
                throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
              case "ArrayExpression":
                e3.type = "ArrayPattern", this.toAssignableList(e3.elements, null == (r3 = e3.extra) ? void 0 : r3.trailingCommaLoc, t3);
                break;
              case "AssignmentExpression":
                "=" !== e3.operator && this.raise(g.MissingEqInAssignment, { at: e3.left.loc.end }), e3.type = "AssignmentPattern", delete e3.operator, this.toAssignable(e3.left, t3);
                break;
              case "ParenthesizedExpression":
                this.toAssignable(i2, t3);
            }
          }
          toAssignableObjectExpressionProp(e3, t3, n3) {
            if ("ObjectMethod" === e3.type) this.raise("get" === e3.kind || "set" === e3.kind ? g.PatternHasAccessor : g.PatternHasMethod, { at: e3.key });
            else if ("SpreadElement" === e3.type) {
              e3.type = "RestElement";
              const r3 = e3.argument;
              this.checkToRestConversion(r3, false), this.toAssignable(r3, n3), t3 || this.raise(g.RestTrailingComma, { at: e3 });
            } else this.toAssignable(e3, n3);
          }
          toAssignableList(e3, t3, n3) {
            const r3 = e3.length - 1;
            for (let i2 = 0; i2 <= r3; i2++) {
              const s2 = e3[i2];
              if (s2) {
                if ("SpreadElement" === s2.type) {
                  s2.type = "RestElement";
                  const e4 = s2.argument;
                  this.checkToRestConversion(e4, true), this.toAssignable(e4, n3);
                } else this.toAssignable(s2, n3);
                "RestElement" === s2.type && (i2 < r3 ? this.raise(g.RestTrailingComma, { at: s2 }) : t3 && this.raise(g.RestTrailingComma, { at: t3 }));
              }
            }
          }
          isAssignable(e3, t3) {
            switch (e3.type) {
              case "Identifier":
              case "ObjectPattern":
              case "ArrayPattern":
              case "AssignmentPattern":
              case "RestElement":
                return true;
              case "ObjectExpression": {
                const t4 = e3.properties.length - 1;
                return e3.properties.every((e4, n3) => "ObjectMethod" !== e4.type && (n3 === t4 || "SpreadElement" !== e4.type) && this.isAssignable(e4));
              }
              case "ObjectProperty":
                return this.isAssignable(e3.value);
              case "SpreadElement":
                return this.isAssignable(e3.argument);
              case "ArrayExpression":
                return e3.elements.every((e4) => null === e4 || this.isAssignable(e4));
              case "AssignmentExpression":
                return "=" === e3.operator;
              case "ParenthesizedExpression":
                return this.isAssignable(e3.expression);
              case "MemberExpression":
              case "OptionalMemberExpression":
                return !t3;
              default:
                return false;
            }
          }
          toReferencedList(e3, t3) {
            return e3;
          }
          toReferencedListDeep(e3, t3) {
            this.toReferencedList(e3, t3);
            for (const t4 of e3) "ArrayExpression" === (null == t4 ? void 0 : t4.type) && this.toReferencedListDeep(t4.elements);
          }
          parseSpread(e3) {
            const t3 = this.startNode();
            return this.next(), t3.argument = this.parseMaybeAssignAllowIn(e3, void 0), this.finishNode(t3, "SpreadElement");
          }
          parseRestBinding() {
            const e3 = this.startNode();
            return this.next(), e3.argument = this.parseBindingAtom(), this.finishNode(e3, "RestElement");
          }
          parseBindingAtom() {
            switch (this.state.type) {
              case 0: {
                const e3 = this.startNode();
                return this.next(), e3.elements = this.parseBindingList(3, 93, 1), this.finishNode(e3, "ArrayPattern");
              }
              case 5:
                return this.parseObjectLike(8, true);
            }
            return this.parseIdentifier();
          }
          parseBindingList(e3, t3, n3) {
            const r3 = 1 & n3, i2 = [];
            let s2 = true;
            for (; !this.eat(e3); ) if (s2 ? s2 = false : this.expect(12), r3 && this.match(12)) i2.push(null);
            else {
              if (this.eat(e3)) break;
              if (this.match(21)) {
                if (i2.push(this.parseAssignableListItemTypes(this.parseRestBinding(), n3)), !this.checkCommaAfterRest(t3)) {
                  this.expect(e3);
                  break;
                }
              } else {
                const e4 = [];
                for (this.match(26) && this.hasPlugin("decorators") && this.raise(g.UnsupportedParameterDecorator, { at: this.state.startLoc }); this.match(26); ) e4.push(this.parseDecorator());
                i2.push(this.parseAssignableListItem(n3, e4));
              }
            }
            return i2;
          }
          parseBindingRestProperty(e3) {
            return this.next(), e3.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(e3, "RestElement");
          }
          parseBindingProperty() {
            const e3 = this.startNode(), { type: t3, startLoc: n3 } = this.state;
            return 21 === t3 ? this.parseBindingRestProperty(e3) : (136 === t3 ? (this.expectPlugin("destructuringPrivate", n3), this.classScope.usePrivateName(this.state.value, n3), e3.key = this.parsePrivateName()) : this.parsePropertyName(e3), e3.method = false, this.parseObjPropValue(e3, n3, false, false, true, false));
          }
          parseAssignableListItem(e3, t3) {
            const n3 = this.parseMaybeDefault();
            this.parseAssignableListItemTypes(n3, e3);
            const r3 = this.parseMaybeDefault(n3.loc.start, n3);
            return t3.length && (n3.decorators = t3), r3;
          }
          parseAssignableListItemTypes(e3, t3) {
            return e3;
          }
          parseMaybeDefault(e3, t3) {
            var n3;
            if (null != e3 || (e3 = this.state.startLoc), t3 = null != (n3 = t3) ? n3 : this.parseBindingAtom(), !this.eat(29)) return t3;
            const r3 = this.startNodeAt(e3);
            return r3.left = t3, r3.right = this.parseMaybeAssignAllowIn(), this.finishNode(r3, "AssignmentPattern");
          }
          isValidLVal(e3, t3, n3) {
            return r3 = { AssignmentPattern: "left", RestElement: "argument", ObjectProperty: "value", ParenthesizedExpression: "expression", ArrayPattern: "elements", ObjectPattern: "properties" }, i2 = e3, Object.hasOwnProperty.call(r3, i2) && r3[i2];
            var r3, i2;
          }
          checkLVal(e3, { in: t3, binding: n3 = 64, checkClashes: r3 = false, strictModeChanged: i2 = false, hasParenthesizedAncestor: s2 = false }) {
            var a2;
            const o2 = e3.type;
            if (this.isObjectMethod(e3)) return;
            if ("MemberExpression" === o2) return void (64 !== n3 && this.raise(g.InvalidPropertyBindingPattern, { at: e3 }));
            if ("Identifier" === o2) {
              this.checkIdentifier(e3, n3, i2);
              const { name: t4 } = e3;
              return void (r3 && (r3.has(t4) ? this.raise(g.ParamDupe, { at: e3 }) : r3.add(t4)));
            }
            const l2 = this.isValidLVal(o2, !(s2 || null != (a2 = e3.extra) && a2.parenthesized) && "AssignmentExpression" === t3.type, n3);
            if (true === l2) return;
            if (false === l2) {
              const r4 = 64 === n3 ? g.InvalidLhs : g.InvalidLhsBinding;
              return void this.raise(r4, { at: e3, ancestor: t3 });
            }
            const [c2, u2] = Array.isArray(l2) ? l2 : [l2, "ParenthesizedExpression" === o2], p2 = "ArrayPattern" === o2 || "ObjectPattern" === o2 || "ParenthesizedExpression" === o2 ? { type: o2 } : t3;
            for (const t4 of [].concat(e3[c2])) t4 && this.checkLVal(t4, { in: p2, binding: n3, checkClashes: r3, strictModeChanged: i2, hasParenthesizedAncestor: u2 });
          }
          checkIdentifier(e3, t3, n3 = false) {
            this.state.strict && (n3 ? fe(e3.name, this.inModule) : de(e3.name)) && (64 === t3 ? this.raise(g.StrictEvalArguments, { at: e3, referenceName: e3.name }) : this.raise(g.StrictEvalArgumentsBinding, { at: e3, bindingName: e3.name })), 8192 & t3 && "let" === e3.name && this.raise(g.LetInLexicalBinding, { at: e3 }), 64 & t3 || this.declareNameFromIdentifier(e3, t3);
          }
          declareNameFromIdentifier(e3, t3) {
            this.scope.declareName(e3.name, t3, e3.loc.start);
          }
          checkToRestConversion(e3, t3) {
            switch (e3.type) {
              case "ParenthesizedExpression":
                this.checkToRestConversion(e3.expression, t3);
                break;
              case "Identifier":
              case "MemberExpression":
                break;
              case "ArrayExpression":
              case "ObjectExpression":
                if (t3) break;
              default:
                this.raise(g.InvalidRestAssignmentPattern, { at: e3 });
            }
          }
          checkCommaAfterRest(e3) {
            return !!this.match(12) && (this.raise(this.lookaheadCharCode() === e3 ? g.RestTrailingComma : g.ElementAfterRest, { at: this.state.startLoc }), true);
          }
        }
        function St(e3) {
          if (!e3) throw new Error("Assert fail");
        }
        const Pt = T`typescript`({ AbstractMethodHasImplementation: ({ methodName: e3 }) => `Method '${e3}' cannot have an implementation because it is marked abstract.`, AbstractPropertyHasInitializer: ({ propertyName: e3 }) => `Property '${e3}' cannot have an initializer because it is marked abstract.`, AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.", AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.", AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.", ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.", ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.", ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.", ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.", DeclareAccessor: ({ kind: e3 }) => `'declare' is not allowed in ${e3}ters.`, DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.", DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.", DuplicateAccessibilityModifier: ({ modifier: e3 }) => "Accessibility modifier already seen.", DuplicateModifier: ({ modifier: e3 }) => `Duplicate modifier: '${e3}'.`, EmptyHeritageClauseType: ({ token: e3 }) => `'${e3}' list cannot be empty.`, EmptyTypeArguments: "Type argument list cannot be empty.", EmptyTypeParameters: "Type parameter list cannot be empty.", ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.", ImportAliasHasImportType: "An import alias can not use 'import type'.", ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier", IncompatibleModifiers: ({ modifiers: e3 }) => `'${e3[0]}' modifier cannot be used with '${e3[1]}' modifier.`, IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.", IndexSignatureHasAccessibility: ({ modifier: e3 }) => `Index signatures cannot have an accessibility modifier ('${e3}').`, IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.", IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.", IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.", InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.", InvalidModifierOnTypeMember: ({ modifier: e3 }) => `'${e3}' modifier cannot appear on a type member.`, InvalidModifierOnTypeParameter: ({ modifier: e3 }) => `'${e3}' modifier cannot appear on a type parameter.`, InvalidModifierOnTypeParameterPositions: ({ modifier: e3 }) => `'${e3}' modifier can only appear on a type parameter of a class, interface or type alias.`, InvalidModifiersOrder: ({ orderedModifiers: e3 }) => `'${e3[0]}' modifier must precede '${e3[1]}' modifier.`, InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.", InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.", MissingInterfaceName: "'interface' declarations must be followed by an identifier.", MixedLabeledAndUnlabeledElements: "Tuple members must all have names or all not have names.", NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.", NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.", OptionalTypeBeforeRequired: "A required element cannot follow an optional element.", OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.", PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.", PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.", PrivateElementHasAccessibility: ({ modifier: e3 }) => `Private elements cannot have an accessibility modifier ('${e3}').`, ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.", ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.", ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.", SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.", SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.", SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.", SingleTypeParameterWithoutTrailingComma: ({ typeParameterName: e3 }) => `Single type parameter ${e3} should have a trailing comma. Example usage: <${e3},>.`, StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.", TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).", TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.", TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.", TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.", UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.", UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.", UnexpectedTypeAnnotation: "Did not expect a type annotation here.", UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.", UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.", UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.", UnsupportedSignatureParameterKind: ({ type: e3 }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${e3}.` });
        function xt(e3) {
          return "private" === e3 || "public" === e3 || "protected" === e3;
        }
        function Dt(e3) {
          return "in" === e3 || "out" === e3;
        }
        function At(e3) {
          if ("MemberExpression" !== e3.type) return false;
          const { computed: t3, property: n3 } = e3;
          return (!t3 || "StringLiteral" === n3.type || !("TemplateLiteral" !== n3.type || n3.expressions.length > 0)) && wt(e3.object);
        }
        function vt(e3, t3) {
          var n3;
          const { type: r3 } = e3;
          if (null != (n3 = e3.extra) && n3.parenthesized) return false;
          if (t3) {
            if ("Literal" === r3) {
              const { value: t4 } = e3;
              if ("string" == typeof t4 || "boolean" == typeof t4) return true;
            }
          } else if ("StringLiteral" === r3 || "BooleanLiteral" === r3) return true;
          return !(!Ct(e3, t3) && !function(e4, t4) {
            if ("UnaryExpression" === e4.type) {
              const { operator: n4, argument: r4 } = e4;
              if ("-" === n4 && Ct(r4, t4)) return true;
            }
            return false;
          }(e3, t3)) || "TemplateLiteral" === r3 && 0 === e3.expressions.length || !!At(e3);
        }
        function Ct(e3, t3) {
          return t3 ? "Literal" === e3.type && ("number" == typeof e3.value || "bigint" in e3) : "NumericLiteral" === e3.type || "BigIntLiteral" === e3.type;
        }
        function wt(e3) {
          return "Identifier" === e3.type || "MemberExpression" === e3.type && !e3.computed && wt(e3.object);
        }
        const Ot = T`placeholders`({ ClassNameIsRequired: "A class name is required.", UnexpectedSpace: "Unexpected space in placeholder." });
        function It(e3, t3) {
          const [n3, r3] = "string" == typeof t3 ? [t3, {}] : t3, i2 = Object.keys(r3), s2 = 0 === i2.length;
          return e3.some((e4) => {
            if ("string" == typeof e4) return s2 && e4 === n3;
            {
              const [t4, s3] = e4;
              if (t4 !== n3) return false;
              for (const e5 of i2) if (s3[e5] !== r3[e5]) return false;
              return true;
            }
          });
        }
        function Nt(e3, t3, n3) {
          const r3 = e3.find((e4) => Array.isArray(e4) ? e4[0] === t3 : e4 === t3);
          return r3 && Array.isArray(r3) && r3.length > 1 ? r3[1][n3] : null;
        }
        const Ft = ["minimal", "fsharp", "hack", "smart"], kt = ["^^", "@@", "^", "%", "#"], Lt = ["hash", "bar"], _t = { estree: (e3) => class extends e3 {
          parse() {
            const e4 = S(super.parse());
            return this.options.tokens && (e4.tokens = e4.tokens.map(S)), e4;
          }
          parseRegExpLiteral({ pattern: e4, flags: t3 }) {
            let n3 = null;
            try {
              n3 = new RegExp(e4, t3);
            } catch (e5) {
            }
            const r3 = this.estreeParseLiteral(n3);
            return r3.regex = { pattern: e4, flags: t3 }, r3;
          }
          parseBigIntLiteral(e4) {
            let t3;
            try {
              t3 = BigInt(e4);
            } catch (e5) {
              t3 = null;
            }
            const n3 = this.estreeParseLiteral(t3);
            return n3.bigint = String(n3.value || e4), n3;
          }
          parseDecimalLiteral(e4) {
            const t3 = this.estreeParseLiteral(null);
            return t3.decimal = String(t3.value || e4), t3;
          }
          estreeParseLiteral(e4) {
            return this.parseLiteral(e4, "Literal");
          }
          parseStringLiteral(e4) {
            return this.estreeParseLiteral(e4);
          }
          parseNumericLiteral(e4) {
            return this.estreeParseLiteral(e4);
          }
          parseNullLiteral() {
            return this.estreeParseLiteral(null);
          }
          parseBooleanLiteral(e4) {
            return this.estreeParseLiteral(e4);
          }
          directiveToStmt(e4) {
            const t3 = e4.value;
            delete e4.value, t3.type = "Literal", t3.raw = t3.extra.raw, t3.value = t3.extra.expressionValue;
            const n3 = e4;
            return n3.type = "ExpressionStatement", n3.expression = t3, n3.directive = t3.extra.rawValue, delete t3.extra, n3;
          }
          initFunction(e4, t3) {
            super.initFunction(e4, t3), e4.expression = false;
          }
          checkDeclaration(e4) {
            null != e4 && this.isObjectProperty(e4) ? this.checkDeclaration(e4.value) : super.checkDeclaration(e4);
          }
          getObjectOrClassMethodParams(e4) {
            return e4.value.params;
          }
          isValidDirective(e4) {
            var t3;
            return "ExpressionStatement" === e4.type && "Literal" === e4.expression.type && "string" == typeof e4.expression.value && !(null != (t3 = e4.expression.extra) && t3.parenthesized);
          }
          parseBlockBody(e4, t3, n3, r3, i2) {
            super.parseBlockBody(e4, t3, n3, r3, i2);
            const s2 = e4.directives.map((e5) => this.directiveToStmt(e5));
            e4.body = s2.concat(e4.body), delete e4.directives;
          }
          pushClassMethod(e4, t3, n3, r3, i2, s2) {
            this.parseMethod(t3, n3, r3, i2, s2, "ClassMethod", true), t3.typeParameters && (t3.value.typeParameters = t3.typeParameters, delete t3.typeParameters), e4.body.push(t3);
          }
          parsePrivateName() {
            const e4 = super.parsePrivateName();
            return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(e4) : e4;
          }
          convertPrivateNameToPrivateIdentifier(e4) {
            const t3 = super.getPrivateNameSV(e4);
            return delete e4.id, e4.name = t3, e4.type = "PrivateIdentifier", e4;
          }
          isPrivateName(e4) {
            return this.getPluginOption("estree", "classFeatures") ? "PrivateIdentifier" === e4.type : super.isPrivateName(e4);
          }
          getPrivateNameSV(e4) {
            return this.getPluginOption("estree", "classFeatures") ? e4.name : super.getPrivateNameSV(e4);
          }
          parseLiteral(e4, t3) {
            const n3 = super.parseLiteral(e4, t3);
            return n3.raw = n3.extra.raw, delete n3.extra, n3;
          }
          parseFunctionBody(e4, t3, n3 = false) {
            super.parseFunctionBody(e4, t3, n3), e4.expression = "BlockStatement" !== e4.body.type;
          }
          parseMethod(e4, t3, n3, r3, i2, s2, a2 = false) {
            let o2 = this.startNode();
            return o2.kind = e4.kind, o2 = super.parseMethod(o2, t3, n3, r3, i2, s2, a2), o2.type = "FunctionExpression", delete o2.kind, e4.value = o2, "ClassPrivateMethod" === s2 && (e4.computed = false), this.finishNode(e4, "MethodDefinition");
          }
          parseClassProperty(...e4) {
            const t3 = super.parseClassProperty(...e4);
            return this.getPluginOption("estree", "classFeatures") ? (t3.type = "PropertyDefinition", t3) : t3;
          }
          parseClassPrivateProperty(...e4) {
            const t3 = super.parseClassPrivateProperty(...e4);
            return this.getPluginOption("estree", "classFeatures") ? (t3.type = "PropertyDefinition", t3.computed = false, t3) : t3;
          }
          parseObjectMethod(e4, t3, n3, r3, i2) {
            const s2 = super.parseObjectMethod(e4, t3, n3, r3, i2);
            return s2 && (s2.type = "Property", "method" === s2.kind && (s2.kind = "init"), s2.shorthand = false), s2;
          }
          parseObjectProperty(e4, t3, n3, r3) {
            const i2 = super.parseObjectProperty(e4, t3, n3, r3);
            return i2 && (i2.kind = "init", i2.type = "Property"), i2;
          }
          isValidLVal(e4, t3, n3) {
            return "Property" === e4 ? "value" : super.isValidLVal(e4, t3, n3);
          }
          isAssignable(e4, t3) {
            return null != e4 && this.isObjectProperty(e4) ? this.isAssignable(e4.value, t3) : super.isAssignable(e4, t3);
          }
          toAssignable(e4, t3 = false) {
            if (null != e4 && this.isObjectProperty(e4)) {
              const { key: n3, value: r3 } = e4;
              this.isPrivateName(n3) && this.classScope.usePrivateName(this.getPrivateNameSV(n3), n3.loc.start), this.toAssignable(r3, t3);
            } else super.toAssignable(e4, t3);
          }
          toAssignableObjectExpressionProp(e4, t3, n3) {
            "get" === e4.kind || "set" === e4.kind ? this.raise(g.PatternHasAccessor, { at: e4.key }) : e4.method ? this.raise(g.PatternHasMethod, { at: e4.key }) : super.toAssignableObjectExpressionProp(e4, t3, n3);
          }
          finishCallExpression(e4, t3) {
            const n3 = super.finishCallExpression(e4, t3);
            var r3;
            "Import" === n3.callee.type && (n3.type = "ImportExpression", n3.source = n3.arguments[0], (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) && (n3.attributes = null != (r3 = n3.arguments[1]) ? r3 : null), delete n3.arguments, delete n3.callee);
            return n3;
          }
          toReferencedArguments(e4) {
            "ImportExpression" !== e4.type && super.toReferencedArguments(e4);
          }
          parseExport(e4, t3) {
            const n3 = this.state.lastTokStartLoc, r3 = super.parseExport(e4, t3);
            switch (r3.type) {
              case "ExportAllDeclaration":
                r3.exported = null;
                break;
              case "ExportNamedDeclaration":
                1 === r3.specifiers.length && "ExportNamespaceSpecifier" === r3.specifiers[0].type && (r3.type = "ExportAllDeclaration", r3.exported = r3.specifiers[0].exported, delete r3.specifiers);
              case "ExportDefaultDeclaration": {
                var i2;
                const { declaration: e5 } = r3;
                "ClassDeclaration" === (null == e5 ? void 0 : e5.type) && (null == (i2 = e5.decorators) ? void 0 : i2.length) > 0 && e5.start === r3.start && this.resetStartLocation(r3, n3);
              }
            }
            return r3;
          }
          parseSubscript(e4, t3, n3, r3) {
            const i2 = super.parseSubscript(e4, t3, n3, r3);
            if (r3.optionalChainMember) {
              if ("OptionalMemberExpression" !== i2.type && "OptionalCallExpression" !== i2.type || (i2.type = i2.type.substring(8)), r3.stop) {
                const e5 = this.startNodeAtNode(i2);
                return e5.expression = i2, this.finishNode(e5, "ChainExpression");
              }
            } else "MemberExpression" !== i2.type && "CallExpression" !== i2.type || (i2.optional = false);
            return i2;
          }
          hasPropertyAsPrivateName(e4) {
            return "ChainExpression" === e4.type && (e4 = e4.expression), super.hasPropertyAsPrivateName(e4);
          }
          isObjectProperty(e4) {
            return "Property" === e4.type && "init" === e4.kind && !e4.method;
          }
          isObjectMethod(e4) {
            return e4.method || "get" === e4.kind || "set" === e4.kind;
          }
          finishNodeAt(e4, t3, n3) {
            return S(super.finishNodeAt(e4, t3, n3));
          }
          resetStartLocation(e4, t3) {
            super.resetStartLocation(e4, t3), S(e4);
          }
          resetEndLocation(e4, t3 = this.state.lastTokEndLoc) {
            super.resetEndLocation(e4, t3), S(e4);
          }
        }, jsx: (e3) => class extends e3 {
          jsxReadToken() {
            let e4 = "", t3 = this.state.pos;
            for (; ; ) {
              if (this.state.pos >= this.length) throw this.raise(ft.UnterminatedJsxContent, { at: this.state.startLoc });
              const n3 = this.input.charCodeAt(this.state.pos);
              switch (n3) {
                case 60:
                case 123:
                  return this.state.pos === this.state.start ? void (60 === n3 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(140)) : super.getTokenFromCode(n3)) : (e4 += this.input.slice(t3, this.state.pos), void this.finishToken(139, e4));
                case 38:
                  e4 += this.input.slice(t3, this.state.pos), e4 += this.jsxReadEntity(), t3 = this.state.pos;
                  break;
                default:
                  Ce(n3) ? (e4 += this.input.slice(t3, this.state.pos), e4 += this.jsxReadNewLine(true), t3 = this.state.pos) : ++this.state.pos;
              }
            }
          }
          jsxReadNewLine(e4) {
            const t3 = this.input.charCodeAt(this.state.pos);
            let n3;
            return ++this.state.pos, 13 === t3 && 10 === this.input.charCodeAt(this.state.pos) ? (++this.state.pos, n3 = e4 ? "\n" : "\r\n") : n3 = String.fromCharCode(t3), ++this.state.curLine, this.state.lineStart = this.state.pos, n3;
          }
          jsxReadString(e4) {
            let t3 = "", n3 = ++this.state.pos;
            for (; ; ) {
              if (this.state.pos >= this.length) throw this.raise(g.UnterminatedString, { at: this.state.startLoc });
              const r3 = this.input.charCodeAt(this.state.pos);
              if (r3 === e4) break;
              38 === r3 ? (t3 += this.input.slice(n3, this.state.pos), t3 += this.jsxReadEntity(), n3 = this.state.pos) : Ce(r3) ? (t3 += this.input.slice(n3, this.state.pos), t3 += this.jsxReadNewLine(false), n3 = this.state.pos) : ++this.state.pos;
            }
            t3 += this.input.slice(n3, this.state.pos++), this.finishToken(131, t3);
          }
          jsxReadEntity() {
            const e4 = ++this.state.pos;
            if (35 === this.codePointAtPos(this.state.pos)) {
              ++this.state.pos;
              let e5 = 10;
              120 === this.codePointAtPos(this.state.pos) && (e5 = 16, ++this.state.pos);
              const t3 = this.readInt(e5, void 0, false, "bail");
              if (null !== t3 && 59 === this.codePointAtPos(this.state.pos)) return ++this.state.pos, String.fromCodePoint(t3);
            } else {
              let t3 = 0, n3 = false;
              for (; t3++ < 10 && this.state.pos < this.length && !(n3 = 59 == this.codePointAtPos(this.state.pos)); ) ++this.state.pos;
              if (n3) {
                const t4 = this.input.slice(e4, this.state.pos), n4 = dt[t4];
                if (++this.state.pos, n4) return n4;
              }
            }
            return this.state.pos = e4, "&";
          }
          jsxReadWord() {
            let e4;
            const t3 = this.state.pos;
            do {
              e4 = this.input.charCodeAt(++this.state.pos);
            } while (oe(e4) || 45 === e4);
            this.finishToken(138, this.input.slice(t3, this.state.pos));
          }
          jsxParseIdentifier() {
            const e4 = this.startNode();
            return this.match(138) ? e4.name = this.state.value : J(this.state.type) ? e4.name = $(this.state.type) : this.unexpected(), this.next(), this.finishNode(e4, "JSXIdentifier");
          }
          jsxParseNamespacedName() {
            const e4 = this.state.startLoc, t3 = this.jsxParseIdentifier();
            if (!this.eat(14)) return t3;
            const n3 = this.startNodeAt(e4);
            return n3.namespace = t3, n3.name = this.jsxParseIdentifier(), this.finishNode(n3, "JSXNamespacedName");
          }
          jsxParseElementName() {
            const e4 = this.state.startLoc;
            let t3 = this.jsxParseNamespacedName();
            if ("JSXNamespacedName" === t3.type) return t3;
            for (; this.eat(16); ) {
              const n3 = this.startNodeAt(e4);
              n3.object = t3, n3.property = this.jsxParseIdentifier(), t3 = this.finishNode(n3, "JSXMemberExpression");
            }
            return t3;
          }
          jsxParseAttributeValue() {
            let e4;
            switch (this.state.type) {
              case 5:
                return e4 = this.startNode(), this.setContext(x.brace), this.next(), e4 = this.jsxParseExpressionContainer(e4, x.j_oTag), "JSXEmptyExpression" === e4.expression.type && this.raise(ft.AttributeIsEmpty, { at: e4 }), e4;
              case 140:
              case 131:
                return this.parseExprAtom();
              default:
                throw this.raise(ft.UnsupportedJsxValue, { at: this.state.startLoc });
            }
          }
          jsxParseEmptyExpression() {
            const e4 = this.startNodeAt(this.state.lastTokEndLoc);
            return this.finishNodeAt(e4, "JSXEmptyExpression", this.state.startLoc);
          }
          jsxParseSpreadChild(e4) {
            return this.next(), e4.expression = this.parseExpression(), this.setContext(x.j_expr), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e4, "JSXSpreadChild");
          }
          jsxParseExpressionContainer(e4, t3) {
            if (this.match(8)) e4.expression = this.jsxParseEmptyExpression();
            else {
              const t4 = this.parseExpression();
              e4.expression = t4;
            }
            return this.setContext(t3), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e4, "JSXExpressionContainer");
          }
          jsxParseAttribute() {
            const e4 = this.startNode();
            return this.match(5) ? (this.setContext(x.brace), this.next(), this.expect(21), e4.argument = this.parseMaybeAssignAllowIn(), this.setContext(x.j_oTag), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e4, "JSXSpreadAttribute")) : (e4.name = this.jsxParseNamespacedName(), e4.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(e4, "JSXAttribute"));
          }
          jsxParseOpeningElementAt(e4) {
            const t3 = this.startNodeAt(e4);
            return this.eat(141) ? this.finishNode(t3, "JSXOpeningFragment") : (t3.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(t3));
          }
          jsxParseOpeningElementAfterName(e4) {
            const t3 = [];
            for (; !this.match(56) && !this.match(141); ) t3.push(this.jsxParseAttribute());
            return e4.attributes = t3, e4.selfClosing = this.eat(56), this.expect(141), this.finishNode(e4, "JSXOpeningElement");
          }
          jsxParseClosingElementAt(e4) {
            const t3 = this.startNodeAt(e4);
            return this.eat(141) ? this.finishNode(t3, "JSXClosingFragment") : (t3.name = this.jsxParseElementName(), this.expect(141), this.finishNode(t3, "JSXClosingElement"));
          }
          jsxParseElementAt(e4) {
            const t3 = this.startNodeAt(e4), n3 = [], r3 = this.jsxParseOpeningElementAt(e4);
            let i2 = null;
            if (!r3.selfClosing) {
              e: for (; ; ) switch (this.state.type) {
                case 140:
                  if (e4 = this.state.startLoc, this.next(), this.eat(56)) {
                    i2 = this.jsxParseClosingElementAt(e4);
                    break e;
                  }
                  n3.push(this.jsxParseElementAt(e4));
                  break;
                case 139:
                  n3.push(this.parseExprAtom());
                  break;
                case 5: {
                  const e5 = this.startNode();
                  this.setContext(x.brace), this.next(), this.match(21) ? n3.push(this.jsxParseSpreadChild(e5)) : n3.push(this.jsxParseExpressionContainer(e5, x.j_expr));
                  break;
                }
                default:
                  this.unexpected();
              }
              yt(r3) && !yt(i2) && null !== i2 ? this.raise(ft.MissingClosingTagFragment, { at: i2 }) : !yt(r3) && yt(i2) ? this.raise(ft.MissingClosingTagElement, { at: i2, openingTagName: mt(r3.name) }) : yt(r3) || yt(i2) || mt(i2.name) !== mt(r3.name) && this.raise(ft.MissingClosingTagElement, { at: i2, openingTagName: mt(r3.name) });
            }
            if (yt(r3) ? (t3.openingFragment = r3, t3.closingFragment = i2) : (t3.openingElement = r3, t3.closingElement = i2), t3.children = n3, this.match(47)) throw this.raise(ft.UnwrappedAdjacentJSXElements, { at: this.state.startLoc });
            return yt(r3) ? this.finishNode(t3, "JSXFragment") : this.finishNode(t3, "JSXElement");
          }
          jsxParseElement() {
            const e4 = this.state.startLoc;
            return this.next(), this.jsxParseElementAt(e4);
          }
          setContext(e4) {
            const { context: t3 } = this.state;
            t3[t3.length - 1] = e4;
          }
          parseExprAtom(e4) {
            return this.match(139) ? this.parseLiteral(this.state.value, "JSXText") : this.match(140) ? this.jsxParseElement() : this.match(47) && 33 !== this.input.charCodeAt(this.state.pos) ? (this.replaceToken(140), this.jsxParseElement()) : super.parseExprAtom(e4);
          }
          skipSpace() {
            this.curContext().preserveSpace || super.skipSpace();
          }
          getTokenFromCode(e4) {
            const t3 = this.curContext();
            if (t3 !== x.j_expr) {
              if (t3 === x.j_oTag || t3 === x.j_cTag) {
                if (ae(e4)) return void this.jsxReadWord();
                if (62 === e4) return ++this.state.pos, void this.finishToken(141);
                if ((34 === e4 || 39 === e4) && t3 === x.j_oTag) return void this.jsxReadString(e4);
              }
              if (60 === e4 && this.state.canStartJSXElement && 33 !== this.input.charCodeAt(this.state.pos + 1)) return ++this.state.pos, void this.finishToken(140);
              super.getTokenFromCode(e4);
            } else this.jsxReadToken();
          }
          updateContext(e4) {
            const { context: t3, type: n3 } = this.state;
            if (56 === n3 && 140 === e4) t3.splice(-2, 2, x.j_cTag), this.state.canStartJSXElement = false;
            else if (140 === n3) t3.push(x.j_oTag);
            else if (141 === n3) {
              const n4 = t3[t3.length - 1];
              n4 === x.j_oTag && 56 === e4 || n4 === x.j_cTag ? (t3.pop(), this.state.canStartJSXElement = t3[t3.length - 1] === x.j_expr) : (this.setContext(x.j_expr), this.state.canStartJSXElement = true);
            } else this.state.canStartJSXElement = B[n3];
          }
        }, flow: (e3) => class extends e3 {
          constructor(...e4) {
            super(...e4), this.flowPragma = void 0;
          }
          getScopeHandler() {
            return be;
          }
          shouldParseTypes() {
            return this.getPluginOption("flow", "all") || "flow" === this.flowPragma;
          }
          shouldParseEnums() {
            return !!this.getPluginOption("flow", "enums");
          }
          finishToken(e4, t3) {
            131 !== e4 && 13 !== e4 && 28 !== e4 && void 0 === this.flowPragma && (this.flowPragma = null), super.finishToken(e4, t3);
          }
          addComment(e4) {
            if (void 0 === this.flowPragma) {
              const t3 = ht.exec(e4.value);
              if (t3) if ("flow" === t3[1]) this.flowPragma = "flow";
              else {
                if ("noflow" !== t3[1]) throw new Error("Unexpected flow pragma");
                this.flowPragma = "noflow";
              }
            }
            super.addComment(e4);
          }
          flowParseTypeInitialiser(e4) {
            const t3 = this.state.inType;
            this.state.inType = true, this.expect(e4 || 14);
            const n3 = this.flowParseType();
            return this.state.inType = t3, n3;
          }
          flowParsePredicate() {
            const e4 = this.startNode(), t3 = this.state.startLoc;
            return this.next(), this.expectContextual(108), this.state.lastTokStart > t3.index + 1 && this.raise(ct.UnexpectedSpaceBetweenModuloChecks, { at: t3 }), this.eat(10) ? (e4.value = super.parseExpression(), this.expect(11), this.finishNode(e4, "DeclaredPredicate")) : this.finishNode(e4, "InferredPredicate");
          }
          flowParseTypeAndPredicateInitialiser() {
            const e4 = this.state.inType;
            this.state.inType = true, this.expect(14);
            let t3 = null, n3 = null;
            return this.match(54) ? (this.state.inType = e4, n3 = this.flowParsePredicate()) : (t3 = this.flowParseType(), this.state.inType = e4, this.match(54) && (n3 = this.flowParsePredicate())), [t3, n3];
          }
          flowParseDeclareClass(e4) {
            return this.next(), this.flowParseInterfaceish(e4, true), this.finishNode(e4, "DeclareClass");
          }
          flowParseDeclareFunction(e4) {
            this.next();
            const t3 = e4.id = this.parseIdentifier(), n3 = this.startNode(), r3 = this.startNode();
            this.match(47) ? n3.typeParameters = this.flowParseTypeParameterDeclaration() : n3.typeParameters = null, this.expect(10);
            const i2 = this.flowParseFunctionTypeParams();
            return n3.params = i2.params, n3.rest = i2.rest, n3.this = i2._this, this.expect(11), [n3.returnType, e4.predicate] = this.flowParseTypeAndPredicateInitialiser(), r3.typeAnnotation = this.finishNode(n3, "FunctionTypeAnnotation"), t3.typeAnnotation = this.finishNode(r3, "TypeAnnotation"), this.resetEndLocation(t3), this.semicolon(), this.scope.declareName(e4.id.name, 2048, e4.id.loc.start), this.finishNode(e4, "DeclareFunction");
          }
          flowParseDeclare(e4, t3) {
            return this.match(80) ? this.flowParseDeclareClass(e4) : this.match(68) ? this.flowParseDeclareFunction(e4) : this.match(74) ? this.flowParseDeclareVariable(e4) : this.eatContextual(125) ? this.match(16) ? this.flowParseDeclareModuleExports(e4) : (t3 && this.raise(ct.NestedDeclareModule, { at: this.state.lastTokStartLoc }), this.flowParseDeclareModule(e4)) : this.isContextual(128) ? this.flowParseDeclareTypeAlias(e4) : this.isContextual(129) ? this.flowParseDeclareOpaqueType(e4) : this.isContextual(127) ? this.flowParseDeclareInterface(e4) : this.match(82) ? this.flowParseDeclareExportDeclaration(e4, t3) : void this.unexpected();
          }
          flowParseDeclareVariable(e4) {
            return this.next(), e4.id = this.flowParseTypeAnnotatableIdentifier(true), this.scope.declareName(e4.id.name, 5, e4.id.loc.start), this.semicolon(), this.finishNode(e4, "DeclareVariable");
          }
          flowParseDeclareModule(e4) {
            this.scope.enter(0), this.match(131) ? e4.id = super.parseExprAtom() : e4.id = this.parseIdentifier();
            const t3 = e4.body = this.startNode(), n3 = t3.body = [];
            for (this.expect(5); !this.match(8); ) {
              let e5 = this.startNode();
              this.match(83) ? (this.next(), this.isContextual(128) || this.match(87) || this.raise(ct.InvalidNonTypeImportInDeclareModule, { at: this.state.lastTokStartLoc }), super.parseImport(e5)) : (this.expectContextual(123, ct.UnsupportedStatementInDeclareModule), e5 = this.flowParseDeclare(e5, true)), n3.push(e5);
            }
            this.scope.exit(), this.expect(8), this.finishNode(t3, "BlockStatement");
            let r3 = null, i2 = false;
            return n3.forEach((e5) => {
              !function(e6) {
                return "DeclareExportAllDeclaration" === e6.type || "DeclareExportDeclaration" === e6.type && (!e6.declaration || "TypeAlias" !== e6.declaration.type && "InterfaceDeclaration" !== e6.declaration.type);
              }(e5) ? "DeclareModuleExports" === e5.type && (i2 && this.raise(ct.DuplicateDeclareModuleExports, { at: e5 }), "ES" === r3 && this.raise(ct.AmbiguousDeclareModuleKind, { at: e5 }), r3 = "CommonJS", i2 = true) : ("CommonJS" === r3 && this.raise(ct.AmbiguousDeclareModuleKind, { at: e5 }), r3 = "ES");
            }), e4.kind = r3 || "CommonJS", this.finishNode(e4, "DeclareModule");
          }
          flowParseDeclareExportDeclaration(e4, t3) {
            if (this.expect(82), this.eat(65)) return this.match(68) || this.match(80) ? e4.declaration = this.flowParseDeclare(this.startNode()) : (e4.declaration = this.flowParseType(), this.semicolon()), e4.default = true, this.finishNode(e4, "DeclareExportDeclaration");
            if (this.match(75) || this.isLet() || (this.isContextual(128) || this.isContextual(127)) && !t3) {
              const e5 = this.state.value;
              throw this.raise(ct.UnsupportedDeclareExportKind, { at: this.state.startLoc, unsupportedExportKind: e5, suggestion: pt[e5] });
            }
            return this.match(74) || this.match(68) || this.match(80) || this.isContextual(129) ? (e4.declaration = this.flowParseDeclare(this.startNode()), e4.default = false, this.finishNode(e4, "DeclareExportDeclaration")) : this.match(55) || this.match(5) || this.isContextual(127) || this.isContextual(128) || this.isContextual(129) ? ("ExportNamedDeclaration" === (e4 = this.parseExport(e4, null)).type && (e4.type = "ExportDeclaration", e4.default = false, delete e4.exportKind), e4.type = "Declare" + e4.type, e4) : void this.unexpected();
          }
          flowParseDeclareModuleExports(e4) {
            return this.next(), this.expectContextual(109), e4.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(e4, "DeclareModuleExports");
          }
          flowParseDeclareTypeAlias(e4) {
            this.next();
            const t3 = this.flowParseTypeAlias(e4);
            return t3.type = "DeclareTypeAlias", t3;
          }
          flowParseDeclareOpaqueType(e4) {
            this.next();
            const t3 = this.flowParseOpaqueType(e4, true);
            return t3.type = "DeclareOpaqueType", t3;
          }
          flowParseDeclareInterface(e4) {
            return this.next(), this.flowParseInterfaceish(e4, false), this.finishNode(e4, "DeclareInterface");
          }
          flowParseInterfaceish(e4, t3) {
            if (e4.id = this.flowParseRestrictedIdentifier(!t3, true), this.scope.declareName(e4.id.name, t3 ? 17 : 8201, e4.id.loc.start), this.match(47) ? e4.typeParameters = this.flowParseTypeParameterDeclaration() : e4.typeParameters = null, e4.extends = [], this.eat(81)) do {
              e4.extends.push(this.flowParseInterfaceExtends());
            } while (!t3 && this.eat(12));
            if (t3) {
              if (e4.implements = [], e4.mixins = [], this.eatContextual(115)) do {
                e4.mixins.push(this.flowParseInterfaceExtends());
              } while (this.eat(12));
              if (this.eatContextual(111)) do {
                e4.implements.push(this.flowParseInterfaceExtends());
              } while (this.eat(12));
            }
            e4.body = this.flowParseObjectType({ allowStatic: t3, allowExact: false, allowSpread: false, allowProto: t3, allowInexact: false });
          }
          flowParseInterfaceExtends() {
            const e4 = this.startNode();
            return e4.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? e4.typeParameters = this.flowParseTypeParameterInstantiation() : e4.typeParameters = null, this.finishNode(e4, "InterfaceExtends");
          }
          flowParseInterface(e4) {
            return this.flowParseInterfaceish(e4, false), this.finishNode(e4, "InterfaceDeclaration");
          }
          checkNotUnderscore(e4) {
            "_" === e4 && this.raise(ct.UnexpectedReservedUnderscore, { at: this.state.startLoc });
          }
          checkReservedType(e4, t3, n3) {
            lt.has(e4) && this.raise(n3 ? ct.AssignReservedType : ct.UnexpectedReservedType, { at: t3, reservedType: e4 });
          }
          flowParseRestrictedIdentifier(e4, t3) {
            return this.checkReservedType(this.state.value, this.state.startLoc, t3), this.parseIdentifier(e4);
          }
          flowParseTypeAlias(e4) {
            return e4.id = this.flowParseRestrictedIdentifier(false, true), this.scope.declareName(e4.id.name, 8201, e4.id.loc.start), this.match(47) ? e4.typeParameters = this.flowParseTypeParameterDeclaration() : e4.typeParameters = null, e4.right = this.flowParseTypeInitialiser(29), this.semicolon(), this.finishNode(e4, "TypeAlias");
          }
          flowParseOpaqueType(e4, t3) {
            return this.expectContextual(128), e4.id = this.flowParseRestrictedIdentifier(true, true), this.scope.declareName(e4.id.name, 8201, e4.id.loc.start), this.match(47) ? e4.typeParameters = this.flowParseTypeParameterDeclaration() : e4.typeParameters = null, e4.supertype = null, this.match(14) && (e4.supertype = this.flowParseTypeInitialiser(14)), e4.impltype = null, t3 || (e4.impltype = this.flowParseTypeInitialiser(29)), this.semicolon(), this.finishNode(e4, "OpaqueType");
          }
          flowParseTypeParameter(e4 = false) {
            const t3 = this.state.startLoc, n3 = this.startNode(), r3 = this.flowParseVariance(), i2 = this.flowParseTypeAnnotatableIdentifier();
            return n3.name = i2.name, n3.variance = r3, n3.bound = i2.typeAnnotation, this.match(29) ? (this.eat(29), n3.default = this.flowParseType()) : e4 && this.raise(ct.MissingTypeParamDefault, { at: t3 }), this.finishNode(n3, "TypeParameter");
          }
          flowParseTypeParameterDeclaration() {
            const e4 = this.state.inType, t3 = this.startNode();
            t3.params = [], this.state.inType = true, this.match(47) || this.match(140) ? this.next() : this.unexpected();
            let n3 = false;
            do {
              const e5 = this.flowParseTypeParameter(n3);
              t3.params.push(e5), e5.default && (n3 = true), this.match(48) || this.expect(12);
            } while (!this.match(48));
            return this.expect(48), this.state.inType = e4, this.finishNode(t3, "TypeParameterDeclaration");
          }
          flowParseTypeParameterInstantiation() {
            const e4 = this.startNode(), t3 = this.state.inType;
            e4.params = [], this.state.inType = true, this.expect(47);
            const n3 = this.state.noAnonFunctionType;
            for (this.state.noAnonFunctionType = false; !this.match(48); ) e4.params.push(this.flowParseType()), this.match(48) || this.expect(12);
            return this.state.noAnonFunctionType = n3, this.expect(48), this.state.inType = t3, this.finishNode(e4, "TypeParameterInstantiation");
          }
          flowParseTypeParameterInstantiationCallOrNew() {
            const e4 = this.startNode(), t3 = this.state.inType;
            for (e4.params = [], this.state.inType = true, this.expect(47); !this.match(48); ) e4.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
            return this.expect(48), this.state.inType = t3, this.finishNode(e4, "TypeParameterInstantiation");
          }
          flowParseInterfaceType() {
            const e4 = this.startNode();
            if (this.expectContextual(127), e4.extends = [], this.eat(81)) do {
              e4.extends.push(this.flowParseInterfaceExtends());
            } while (this.eat(12));
            return e4.body = this.flowParseObjectType({ allowStatic: false, allowExact: false, allowSpread: false, allowProto: false, allowInexact: false }), this.finishNode(e4, "InterfaceTypeAnnotation");
          }
          flowParseObjectPropertyKey() {
            return this.match(132) || this.match(131) ? super.parseExprAtom() : this.parseIdentifier(true);
          }
          flowParseObjectTypeIndexer(e4, t3, n3) {
            return e4.static = t3, 14 === this.lookahead().type ? (e4.id = this.flowParseObjectPropertyKey(), e4.key = this.flowParseTypeInitialiser()) : (e4.id = null, e4.key = this.flowParseType()), this.expect(3), e4.value = this.flowParseTypeInitialiser(), e4.variance = n3, this.finishNode(e4, "ObjectTypeIndexer");
          }
          flowParseObjectTypeInternalSlot(e4, t3) {
            return e4.static = t3, e4.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (e4.method = true, e4.optional = false, e4.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e4.loc.start))) : (e4.method = false, this.eat(17) && (e4.optional = true), e4.value = this.flowParseTypeInitialiser()), this.finishNode(e4, "ObjectTypeInternalSlot");
          }
          flowParseObjectTypeMethodish(e4) {
            for (e4.params = [], e4.rest = null, e4.typeParameters = null, e4.this = null, this.match(47) && (e4.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(10), this.match(78) && (e4.this = this.flowParseFunctionTypeParam(true), e4.this.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); ) e4.params.push(this.flowParseFunctionTypeParam(false)), this.match(11) || this.expect(12);
            return this.eat(21) && (e4.rest = this.flowParseFunctionTypeParam(false)), this.expect(11), e4.returnType = this.flowParseTypeInitialiser(), this.finishNode(e4, "FunctionTypeAnnotation");
          }
          flowParseObjectTypeCallProperty(e4, t3) {
            const n3 = this.startNode();
            return e4.static = t3, e4.value = this.flowParseObjectTypeMethodish(n3), this.finishNode(e4, "ObjectTypeCallProperty");
          }
          flowParseObjectType({ allowStatic: e4, allowExact: t3, allowSpread: n3, allowProto: r3, allowInexact: i2 }) {
            const s2 = this.state.inType;
            this.state.inType = true;
            const a2 = this.startNode();
            let o2, l2;
            a2.callProperties = [], a2.properties = [], a2.indexers = [], a2.internalSlots = [];
            let c2 = false;
            for (t3 && this.match(6) ? (this.expect(6), o2 = 9, l2 = true) : (this.expect(5), o2 = 8, l2 = false), a2.exact = l2; !this.match(o2); ) {
              let t4 = false, s3 = null, o3 = null;
              const u3 = this.startNode();
              if (r3 && this.isContextual(116)) {
                const t5 = this.lookahead();
                14 !== t5.type && 17 !== t5.type && (this.next(), s3 = this.state.startLoc, e4 = false);
              }
              if (e4 && this.isContextual(104)) {
                const e5 = this.lookahead();
                14 !== e5.type && 17 !== e5.type && (this.next(), t4 = true);
              }
              const p2 = this.flowParseVariance();
              if (this.eat(0)) null != s3 && this.unexpected(s3), this.eat(0) ? (p2 && this.unexpected(p2.loc.start), a2.internalSlots.push(this.flowParseObjectTypeInternalSlot(u3, t4))) : a2.indexers.push(this.flowParseObjectTypeIndexer(u3, t4, p2));
              else if (this.match(10) || this.match(47)) null != s3 && this.unexpected(s3), p2 && this.unexpected(p2.loc.start), a2.callProperties.push(this.flowParseObjectTypeCallProperty(u3, t4));
              else {
                let e5 = "init";
                (this.isContextual(98) || this.isContextual(103)) && Y(this.lookahead().type) && (e5 = this.state.value, this.next());
                const r4 = this.flowParseObjectTypeProperty(u3, t4, s3, p2, e5, n3, null != i2 ? i2 : !l2);
                null === r4 ? (c2 = true, o3 = this.state.lastTokStartLoc) : a2.properties.push(r4);
              }
              this.flowObjectTypeSemicolon(), !o3 || this.match(8) || this.match(9) || this.raise(ct.UnexpectedExplicitInexactInObject, { at: o3 });
            }
            this.expect(o2), n3 && (a2.inexact = c2);
            const u2 = this.finishNode(a2, "ObjectTypeAnnotation");
            return this.state.inType = s2, u2;
          }
          flowParseObjectTypeProperty(e4, t3, n3, r3, i2, s2, a2) {
            if (this.eat(21)) return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (s2 ? a2 || this.raise(ct.InexactInsideExact, { at: this.state.lastTokStartLoc }) : this.raise(ct.InexactInsideNonObject, { at: this.state.lastTokStartLoc }), r3 && this.raise(ct.InexactVariance, { at: r3 }), null) : (s2 || this.raise(ct.UnexpectedSpreadType, { at: this.state.lastTokStartLoc }), null != n3 && this.unexpected(n3), r3 && this.raise(ct.SpreadVariance, { at: r3 }), e4.argument = this.flowParseType(), this.finishNode(e4, "ObjectTypeSpreadProperty"));
            {
              e4.key = this.flowParseObjectPropertyKey(), e4.static = t3, e4.proto = null != n3, e4.kind = i2;
              let a3 = false;
              return this.match(47) || this.match(10) ? (e4.method = true, null != n3 && this.unexpected(n3), r3 && this.unexpected(r3.loc.start), e4.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e4.loc.start)), "get" !== i2 && "set" !== i2 || this.flowCheckGetterSetterParams(e4), !s2 && "constructor" === e4.key.name && e4.value.this && this.raise(ct.ThisParamBannedInConstructor, { at: e4.value.this })) : ("init" !== i2 && this.unexpected(), e4.method = false, this.eat(17) && (a3 = true), e4.value = this.flowParseTypeInitialiser(), e4.variance = r3), e4.optional = a3, this.finishNode(e4, "ObjectTypeProperty");
            }
          }
          flowCheckGetterSetterParams(e4) {
            const t3 = "get" === e4.kind ? 0 : 1, n3 = e4.value.params.length + (e4.value.rest ? 1 : 0);
            e4.value.this && this.raise("get" === e4.kind ? ct.GetterMayNotHaveThisParam : ct.SetterMayNotHaveThisParam, { at: e4.value.this }), n3 !== t3 && this.raise("get" === e4.kind ? g.BadGetterArity : g.BadSetterArity, { at: e4 }), "set" === e4.kind && e4.value.rest && this.raise(g.BadSetterRestParameter, { at: e4 });
          }
          flowObjectTypeSemicolon() {
            this.eat(13) || this.eat(12) || this.match(8) || this.match(9) || this.unexpected();
          }
          flowParseQualifiedTypeIdentifier(e4, t3) {
            null != e4 || (e4 = this.state.startLoc);
            let n3 = t3 || this.flowParseRestrictedIdentifier(true);
            for (; this.eat(16); ) {
              const t4 = this.startNodeAt(e4);
              t4.qualification = n3, t4.id = this.flowParseRestrictedIdentifier(true), n3 = this.finishNode(t4, "QualifiedTypeIdentifier");
            }
            return n3;
          }
          flowParseGenericType(e4, t3) {
            const n3 = this.startNodeAt(e4);
            return n3.typeParameters = null, n3.id = this.flowParseQualifiedTypeIdentifier(e4, t3), this.match(47) && (n3.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(n3, "GenericTypeAnnotation");
          }
          flowParseTypeofType() {
            const e4 = this.startNode();
            return this.expect(87), e4.argument = this.flowParsePrimaryType(), this.finishNode(e4, "TypeofTypeAnnotation");
          }
          flowParseTupleType() {
            const e4 = this.startNode();
            for (e4.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (e4.types.push(this.flowParseType()), !this.match(3)); ) this.expect(12);
            return this.expect(3), this.finishNode(e4, "TupleTypeAnnotation");
          }
          flowParseFunctionTypeParam(e4) {
            let t3 = null, n3 = false, r3 = null;
            const i2 = this.startNode(), s2 = this.lookahead(), a2 = 78 === this.state.type;
            return 14 === s2.type || 17 === s2.type ? (a2 && !e4 && this.raise(ct.ThisParamMustBeFirst, { at: i2 }), t3 = this.parseIdentifier(a2), this.eat(17) && (n3 = true, a2 && this.raise(ct.ThisParamMayNotBeOptional, { at: i2 })), r3 = this.flowParseTypeInitialiser()) : r3 = this.flowParseType(), i2.name = t3, i2.optional = n3, i2.typeAnnotation = r3, this.finishNode(i2, "FunctionTypeParam");
          }
          reinterpretTypeAsFunctionTypeParam(e4) {
            const t3 = this.startNodeAt(e4.loc.start);
            return t3.name = null, t3.optional = false, t3.typeAnnotation = e4, this.finishNode(t3, "FunctionTypeParam");
          }
          flowParseFunctionTypeParams(e4 = []) {
            let t3 = null, n3 = null;
            for (this.match(78) && (n3 = this.flowParseFunctionTypeParam(true), n3.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); ) e4.push(this.flowParseFunctionTypeParam(false)), this.match(11) || this.expect(12);
            return this.eat(21) && (t3 = this.flowParseFunctionTypeParam(false)), { params: e4, rest: t3, _this: n3 };
          }
          flowIdentToTypeAnnotation(e4, t3, n3) {
            switch (n3.name) {
              case "any":
                return this.finishNode(t3, "AnyTypeAnnotation");
              case "bool":
              case "boolean":
                return this.finishNode(t3, "BooleanTypeAnnotation");
              case "mixed":
                return this.finishNode(t3, "MixedTypeAnnotation");
              case "empty":
                return this.finishNode(t3, "EmptyTypeAnnotation");
              case "number":
                return this.finishNode(t3, "NumberTypeAnnotation");
              case "string":
                return this.finishNode(t3, "StringTypeAnnotation");
              case "symbol":
                return this.finishNode(t3, "SymbolTypeAnnotation");
              default:
                return this.checkNotUnderscore(n3.name), this.flowParseGenericType(e4, n3);
            }
          }
          flowParsePrimaryType() {
            const e4 = this.state.startLoc, t3 = this.startNode();
            let n3, r3, i2 = false;
            const s2 = this.state.noAnonFunctionType;
            switch (this.state.type) {
              case 5:
                return this.flowParseObjectType({ allowStatic: false, allowExact: false, allowSpread: true, allowProto: false, allowInexact: true });
              case 6:
                return this.flowParseObjectType({ allowStatic: false, allowExact: true, allowSpread: true, allowProto: false, allowInexact: false });
              case 0:
                return this.state.noAnonFunctionType = false, r3 = this.flowParseTupleType(), this.state.noAnonFunctionType = s2, r3;
              case 47:
                return t3.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), n3 = this.flowParseFunctionTypeParams(), t3.params = n3.params, t3.rest = n3.rest, t3.this = n3._this, this.expect(11), this.expect(19), t3.returnType = this.flowParseType(), this.finishNode(t3, "FunctionTypeAnnotation");
              case 10:
                if (this.next(), !this.match(11) && !this.match(21)) if (W(this.state.type) || this.match(78)) {
                  const e5 = this.lookahead().type;
                  i2 = 17 !== e5 && 14 !== e5;
                } else i2 = true;
                if (i2) {
                  if (this.state.noAnonFunctionType = false, r3 = this.flowParseType(), this.state.noAnonFunctionType = s2, this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && 19 === this.lookahead().type)) return this.expect(11), r3;
                  this.eat(12);
                }
                return n3 = r3 ? this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(r3)]) : this.flowParseFunctionTypeParams(), t3.params = n3.params, t3.rest = n3.rest, t3.this = n3._this, this.expect(11), this.expect(19), t3.returnType = this.flowParseType(), t3.typeParameters = null, this.finishNode(t3, "FunctionTypeAnnotation");
              case 131:
                return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
              case 85:
              case 86:
                return t3.value = this.match(85), this.next(), this.finishNode(t3, "BooleanLiteralTypeAnnotation");
              case 53:
                if ("-" === this.state.value) {
                  if (this.next(), this.match(132)) return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", t3);
                  if (this.match(133)) return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", t3);
                  throw this.raise(ct.UnexpectedSubtractionOperand, { at: this.state.startLoc });
                }
                return void this.unexpected();
              case 132:
                return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
              case 133:
                return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
              case 88:
                return this.next(), this.finishNode(t3, "VoidTypeAnnotation");
              case 84:
                return this.next(), this.finishNode(t3, "NullLiteralTypeAnnotation");
              case 78:
                return this.next(), this.finishNode(t3, "ThisTypeAnnotation");
              case 55:
                return this.next(), this.finishNode(t3, "ExistsTypeAnnotation");
              case 87:
                return this.flowParseTypeofType();
              default:
                if (J(this.state.type)) {
                  const e5 = $(this.state.type);
                  return this.next(), super.createIdentifier(t3, e5);
                }
                if (W(this.state.type)) return this.isContextual(127) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(e4, t3, this.parseIdentifier());
            }
            this.unexpected();
          }
          flowParsePostfixType() {
            const e4 = this.state.startLoc;
            let t3 = this.flowParsePrimaryType(), n3 = false;
            for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
              const r3 = this.startNodeAt(e4), i2 = this.eat(18);
              n3 = n3 || i2, this.expect(0), !i2 && this.match(3) ? (r3.elementType = t3, this.next(), t3 = this.finishNode(r3, "ArrayTypeAnnotation")) : (r3.objectType = t3, r3.indexType = this.flowParseType(), this.expect(3), n3 ? (r3.optional = i2, t3 = this.finishNode(r3, "OptionalIndexedAccessType")) : t3 = this.finishNode(r3, "IndexedAccessType"));
            }
            return t3;
          }
          flowParsePrefixType() {
            const e4 = this.startNode();
            return this.eat(17) ? (e4.typeAnnotation = this.flowParsePrefixType(), this.finishNode(e4, "NullableTypeAnnotation")) : this.flowParsePostfixType();
          }
          flowParseAnonFunctionWithoutParens() {
            const e4 = this.flowParsePrefixType();
            if (!this.state.noAnonFunctionType && this.eat(19)) {
              const t3 = this.startNodeAt(e4.loc.start);
              return t3.params = [this.reinterpretTypeAsFunctionTypeParam(e4)], t3.rest = null, t3.this = null, t3.returnType = this.flowParseType(), t3.typeParameters = null, this.finishNode(t3, "FunctionTypeAnnotation");
            }
            return e4;
          }
          flowParseIntersectionType() {
            const e4 = this.startNode();
            this.eat(45);
            const t3 = this.flowParseAnonFunctionWithoutParens();
            for (e4.types = [t3]; this.eat(45); ) e4.types.push(this.flowParseAnonFunctionWithoutParens());
            return 1 === e4.types.length ? t3 : this.finishNode(e4, "IntersectionTypeAnnotation");
          }
          flowParseUnionType() {
            const e4 = this.startNode();
            this.eat(43);
            const t3 = this.flowParseIntersectionType();
            for (e4.types = [t3]; this.eat(43); ) e4.types.push(this.flowParseIntersectionType());
            return 1 === e4.types.length ? t3 : this.finishNode(e4, "UnionTypeAnnotation");
          }
          flowParseType() {
            const e4 = this.state.inType;
            this.state.inType = true;
            const t3 = this.flowParseUnionType();
            return this.state.inType = e4, t3;
          }
          flowParseTypeOrImplicitInstantiation() {
            if (130 === this.state.type && "_" === this.state.value) {
              const e4 = this.state.startLoc, t3 = this.parseIdentifier();
              return this.flowParseGenericType(e4, t3);
            }
            return this.flowParseType();
          }
          flowParseTypeAnnotation() {
            const e4 = this.startNode();
            return e4.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(e4, "TypeAnnotation");
          }
          flowParseTypeAnnotatableIdentifier(e4) {
            const t3 = e4 ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
            return this.match(14) && (t3.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(t3)), t3;
          }
          typeCastToParameter(e4) {
            return e4.expression.typeAnnotation = e4.typeAnnotation, this.resetEndLocation(e4.expression, e4.typeAnnotation.loc.end), e4.expression;
          }
          flowParseVariance() {
            let e4 = null;
            return this.match(53) ? (e4 = this.startNode(), "+" === this.state.value ? e4.kind = "plus" : e4.kind = "minus", this.next(), this.finishNode(e4, "Variance")) : e4;
          }
          parseFunctionBody(e4, t3, n3 = false) {
            t3 ? this.forwardNoArrowParamsConversionAt(e4, () => super.parseFunctionBody(e4, true, n3)) : super.parseFunctionBody(e4, false, n3);
          }
          parseFunctionBodyAndFinish(e4, t3, n3 = false) {
            if (this.match(14)) {
              const t4 = this.startNode();
              [t4.typeAnnotation, e4.predicate] = this.flowParseTypeAndPredicateInitialiser(), e4.returnType = t4.typeAnnotation ? this.finishNode(t4, "TypeAnnotation") : null;
            }
            return super.parseFunctionBodyAndFinish(e4, t3, n3);
          }
          parseStatementLike(e4) {
            if (this.state.strict && this.isContextual(127)) {
              if (X(this.lookahead().type)) {
                const e5 = this.startNode();
                return this.next(), this.flowParseInterface(e5);
              }
            } else if (this.shouldParseEnums() && this.isContextual(124)) {
              const e5 = this.startNode();
              return this.next(), this.flowParseEnumDeclaration(e5);
            }
            const t3 = super.parseStatementLike(e4);
            return void 0 !== this.flowPragma || this.isValidDirective(t3) || (this.flowPragma = null), t3;
          }
          parseExpressionStatement(e4, t3, n3) {
            if ("Identifier" === t3.type) {
              if ("declare" === t3.name) {
                if (this.match(80) || W(this.state.type) || this.match(68) || this.match(74) || this.match(82)) return this.flowParseDeclare(e4);
              } else if (W(this.state.type)) {
                if ("interface" === t3.name) return this.flowParseInterface(e4);
                if ("type" === t3.name) return this.flowParseTypeAlias(e4);
                if ("opaque" === t3.name) return this.flowParseOpaqueType(e4, false);
              }
            }
            return super.parseExpressionStatement(e4, t3, n3);
          }
          shouldParseExportDeclaration() {
            const { type: e4 } = this.state;
            return H(e4) || this.shouldParseEnums() && 124 === e4 ? !this.state.containsEsc : super.shouldParseExportDeclaration();
          }
          isExportDefaultSpecifier() {
            const { type: e4 } = this.state;
            return H(e4) || this.shouldParseEnums() && 124 === e4 ? this.state.containsEsc : super.isExportDefaultSpecifier();
          }
          parseExportDefaultExpression() {
            if (this.shouldParseEnums() && this.isContextual(124)) {
              const e4 = this.startNode();
              return this.next(), this.flowParseEnumDeclaration(e4);
            }
            return super.parseExportDefaultExpression();
          }
          parseConditional(e4, t3, n3) {
            if (!this.match(17)) return e4;
            if (this.state.maybeInArrowParameters) {
              const t4 = this.lookaheadCharCode();
              if (44 === t4 || 61 === t4 || 58 === t4 || 41 === t4) return this.setOptionalParametersError(n3), e4;
            }
            this.expect(17);
            const r3 = this.state.clone(), i2 = this.state.noArrowAt, s2 = this.startNodeAt(t3);
            let { consequent: a2, failed: o2 } = this.tryParseConditionalConsequent(), [l2, c2] = this.getArrowLikeExpressions(a2);
            if (o2 || c2.length > 0) {
              const e5 = [...i2];
              if (c2.length > 0) {
                this.state = r3, this.state.noArrowAt = e5;
                for (let t4 = 0; t4 < c2.length; t4++) e5.push(c2[t4].start);
                ({ consequent: a2, failed: o2 } = this.tryParseConditionalConsequent()), [l2, c2] = this.getArrowLikeExpressions(a2);
              }
              o2 && l2.length > 1 && this.raise(ct.AmbiguousConditionalArrow, { at: r3.startLoc }), o2 && 1 === l2.length && (this.state = r3, e5.push(l2[0].start), this.state.noArrowAt = e5, { consequent: a2, failed: o2 } = this.tryParseConditionalConsequent());
            }
            return this.getArrowLikeExpressions(a2, true), this.state.noArrowAt = i2, this.expect(14), s2.test = e4, s2.consequent = a2, s2.alternate = this.forwardNoArrowParamsConversionAt(s2, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(s2, "ConditionalExpression");
          }
          tryParseConditionalConsequent() {
            this.state.noArrowParamsConversionAt.push(this.state.start);
            const e4 = this.parseMaybeAssignAllowIn(), t3 = !this.match(14);
            return this.state.noArrowParamsConversionAt.pop(), { consequent: e4, failed: t3 };
          }
          getArrowLikeExpressions(e4, t3) {
            const n3 = [e4], r3 = [];
            for (; 0 !== n3.length; ) {
              const e5 = n3.pop();
              "ArrowFunctionExpression" === e5.type ? (e5.typeParameters || !e5.returnType ? this.finishArrowValidation(e5) : r3.push(e5), n3.push(e5.body)) : "ConditionalExpression" === e5.type && (n3.push(e5.consequent), n3.push(e5.alternate));
            }
            return t3 ? (r3.forEach((e5) => this.finishArrowValidation(e5)), [r3, []]) : function(e5, t4) {
              const n4 = [], r4 = [];
              for (let i2 = 0; i2 < e5.length; i2++) (t4(e5[i2]) ? n4 : r4).push(e5[i2]);
              return [n4, r4];
            }(r3, (e5) => e5.params.every((e6) => this.isAssignable(e6, true)));
          }
          finishArrowValidation(e4) {
            var t3;
            this.toAssignableList(e4.params, null == (t3 = e4.extra) ? void 0 : t3.trailingCommaLoc, false), this.scope.enter(6), super.checkParams(e4, false, true), this.scope.exit();
          }
          forwardNoArrowParamsConversionAt(e4, t3) {
            let n3;
            return -1 !== this.state.noArrowParamsConversionAt.indexOf(e4.start) ? (this.state.noArrowParamsConversionAt.push(this.state.start), n3 = t3(), this.state.noArrowParamsConversionAt.pop()) : n3 = t3(), n3;
          }
          parseParenItem(e4, t3) {
            if (e4 = super.parseParenItem(e4, t3), this.eat(17) && (e4.optional = true, this.resetEndLocation(e4)), this.match(14)) {
              const n3 = this.startNodeAt(t3);
              return n3.expression = e4, n3.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(n3, "TypeCastExpression");
            }
            return e4;
          }
          assertModuleNodeAllowed(e4) {
            "ImportDeclaration" === e4.type && ("type" === e4.importKind || "typeof" === e4.importKind) || "ExportNamedDeclaration" === e4.type && "type" === e4.exportKind || "ExportAllDeclaration" === e4.type && "type" === e4.exportKind || super.assertModuleNodeAllowed(e4);
          }
          parseExportDeclaration(e4) {
            if (this.isContextual(128)) {
              e4.exportKind = "type";
              const t3 = this.startNode();
              return this.next(), this.match(5) ? (e4.specifiers = this.parseExportSpecifiers(true), super.parseExportFrom(e4), null) : this.flowParseTypeAlias(t3);
            }
            if (this.isContextual(129)) {
              e4.exportKind = "type";
              const t3 = this.startNode();
              return this.next(), this.flowParseOpaqueType(t3, false);
            }
            if (this.isContextual(127)) {
              e4.exportKind = "type";
              const t3 = this.startNode();
              return this.next(), this.flowParseInterface(t3);
            }
            if (this.shouldParseEnums() && this.isContextual(124)) {
              e4.exportKind = "value";
              const t3 = this.startNode();
              return this.next(), this.flowParseEnumDeclaration(t3);
            }
            return super.parseExportDeclaration(e4);
          }
          eatExportStar(e4) {
            return !!super.eatExportStar(e4) || !(!this.isContextual(128) || 55 !== this.lookahead().type) && (e4.exportKind = "type", this.next(), this.next(), true);
          }
          maybeParseExportNamespaceSpecifier(e4) {
            const { startLoc: t3 } = this.state, n3 = super.maybeParseExportNamespaceSpecifier(e4);
            return n3 && "type" === e4.exportKind && this.unexpected(t3), n3;
          }
          parseClassId(e4, t3, n3) {
            super.parseClassId(e4, t3, n3), this.match(47) && (e4.typeParameters = this.flowParseTypeParameterDeclaration());
          }
          parseClassMember(e4, t3, n3) {
            const { startLoc: r3 } = this.state;
            if (this.isContextual(123)) {
              if (super.parseClassMemberFromModifier(e4, t3)) return;
              t3.declare = true;
            }
            super.parseClassMember(e4, t3, n3), t3.declare && ("ClassProperty" !== t3.type && "ClassPrivateProperty" !== t3.type && "PropertyDefinition" !== t3.type ? this.raise(ct.DeclareClassElement, { at: r3 }) : t3.value && this.raise(ct.DeclareClassFieldInitializer, { at: t3.value }));
          }
          isIterator(e4) {
            return "iterator" === e4 || "asyncIterator" === e4;
          }
          readIterator() {
            const e4 = super.readWord1(), t3 = "@@" + e4;
            this.isIterator(e4) && this.state.inType || this.raise(g.InvalidIdentifier, { at: this.state.curPosition(), identifierName: t3 }), this.finishToken(130, t3);
          }
          getTokenFromCode(e4) {
            const t3 = this.input.charCodeAt(this.state.pos + 1);
            123 === e4 && 124 === t3 ? this.finishOp(6, 2) : !this.state.inType || 62 !== e4 && 60 !== e4 ? this.state.inType && 63 === e4 ? 46 === t3 ? this.finishOp(18, 2) : this.finishOp(17, 1) : function(e5, t4, n3) {
              return 64 === e5 && 64 === t4 && ae(n3);
            }(e4, t3, this.input.charCodeAt(this.state.pos + 2)) ? (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(e4) : this.finishOp(62 === e4 ? 48 : 47, 1);
          }
          isAssignable(e4, t3) {
            return "TypeCastExpression" === e4.type ? this.isAssignable(e4.expression, t3) : super.isAssignable(e4, t3);
          }
          toAssignable(e4, t3 = false) {
            t3 || "AssignmentExpression" !== e4.type || "TypeCastExpression" !== e4.left.type || (e4.left = this.typeCastToParameter(e4.left)), super.toAssignable(e4, t3);
          }
          toAssignableList(e4, t3, n3) {
            for (let t4 = 0; t4 < e4.length; t4++) {
              const n4 = e4[t4];
              "TypeCastExpression" === (null == n4 ? void 0 : n4.type) && (e4[t4] = this.typeCastToParameter(n4));
            }
            super.toAssignableList(e4, t3, n3);
          }
          toReferencedList(e4, t3) {
            for (let r3 = 0; r3 < e4.length; r3++) {
              var n3;
              const i2 = e4[r3];
              !i2 || "TypeCastExpression" !== i2.type || null != (n3 = i2.extra) && n3.parenthesized || !(e4.length > 1) && t3 || this.raise(ct.TypeCastInPattern, { at: i2.typeAnnotation });
            }
            return e4;
          }
          parseArrayLike(e4, t3, n3, r3) {
            const i2 = super.parseArrayLike(e4, t3, n3, r3);
            return t3 && !this.state.maybeInArrowParameters && this.toReferencedList(i2.elements), i2;
          }
          isValidLVal(e4, t3, n3) {
            return "TypeCastExpression" === e4 || super.isValidLVal(e4, t3, n3);
          }
          parseClassProperty(e4) {
            return this.match(14) && (e4.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(e4);
          }
          parseClassPrivateProperty(e4) {
            return this.match(14) && (e4.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(e4);
          }
          isClassMethod() {
            return this.match(47) || super.isClassMethod();
          }
          isClassProperty() {
            return this.match(14) || super.isClassProperty();
          }
          isNonstaticConstructor(e4) {
            return !this.match(14) && super.isNonstaticConstructor(e4);
          }
          pushClassMethod(e4, t3, n3, r3, i2, s2) {
            if (t3.variance && this.unexpected(t3.variance.loc.start), delete t3.variance, this.match(47) && (t3.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(e4, t3, n3, r3, i2, s2), t3.params && i2) {
              const e5 = t3.params;
              e5.length > 0 && this.isThisParam(e5[0]) && this.raise(ct.ThisParamBannedInConstructor, { at: t3 });
            } else if ("MethodDefinition" === t3.type && i2 && t3.value.params) {
              const e5 = t3.value.params;
              e5.length > 0 && this.isThisParam(e5[0]) && this.raise(ct.ThisParamBannedInConstructor, { at: t3 });
            }
          }
          pushClassPrivateMethod(e4, t3, n3, r3) {
            t3.variance && this.unexpected(t3.variance.loc.start), delete t3.variance, this.match(47) && (t3.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(e4, t3, n3, r3);
          }
          parseClassSuper(e4) {
            if (super.parseClassSuper(e4), e4.superClass && this.match(47) && (e4.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.isContextual(111)) {
              this.next();
              const t3 = e4.implements = [];
              do {
                const e5 = this.startNode();
                e5.id = this.flowParseRestrictedIdentifier(true), this.match(47) ? e5.typeParameters = this.flowParseTypeParameterInstantiation() : e5.typeParameters = null, t3.push(this.finishNode(e5, "ClassImplements"));
              } while (this.eat(12));
            }
          }
          checkGetterSetterParams(e4) {
            super.checkGetterSetterParams(e4);
            const t3 = this.getObjectOrClassMethodParams(e4);
            if (t3.length > 0) {
              const n3 = t3[0];
              this.isThisParam(n3) && "get" === e4.kind ? this.raise(ct.GetterMayNotHaveThisParam, { at: n3 }) : this.isThisParam(n3) && this.raise(ct.SetterMayNotHaveThisParam, { at: n3 });
            }
          }
          parsePropertyNamePrefixOperator(e4) {
            e4.variance = this.flowParseVariance();
          }
          parseObjPropValue(e4, t3, n3, r3, i2, s2, a2) {
            let o2;
            e4.variance && this.unexpected(e4.variance.loc.start), delete e4.variance, this.match(47) && !s2 && (o2 = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
            const l2 = super.parseObjPropValue(e4, t3, n3, r3, i2, s2, a2);
            return o2 && ((l2.value || l2).typeParameters = o2), l2;
          }
          parseAssignableListItemTypes(e4) {
            return this.eat(17) && ("Identifier" !== e4.type && this.raise(ct.PatternIsOptional, { at: e4 }), this.isThisParam(e4) && this.raise(ct.ThisParamMayNotBeOptional, { at: e4 }), e4.optional = true), this.match(14) ? e4.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(e4) && this.raise(ct.ThisParamAnnotationRequired, { at: e4 }), this.match(29) && this.isThisParam(e4) && this.raise(ct.ThisParamNoDefault, { at: e4 }), this.resetEndLocation(e4), e4;
          }
          parseMaybeDefault(e4, t3) {
            const n3 = super.parseMaybeDefault(e4, t3);
            return "AssignmentPattern" === n3.type && n3.typeAnnotation && n3.right.start < n3.typeAnnotation.start && this.raise(ct.TypeBeforeInitializer, { at: n3.typeAnnotation }), n3;
          }
          checkImportReflection(e4) {
            super.checkImportReflection(e4), e4.module && "value" !== e4.importKind && this.raise(ct.ImportReflectionHasImportType, { at: e4.specifiers[0].loc.start });
          }
          parseImportSpecifierLocal(e4, t3, n3) {
            t3.local = ut(e4) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier(), e4.specifiers.push(this.finishImportSpecifier(t3, n3));
          }
          isPotentialImportPhase(e4) {
            if (super.isPotentialImportPhase(e4)) return true;
            if (this.isContextual(128)) {
              if (!e4) return true;
              const t3 = this.lookaheadCharCode();
              return 123 === t3 || 42 === t3;
            }
            return !e4 && this.isContextual(87);
          }
          applyImportPhase(e4, t3, n3, r3) {
            if (super.applyImportPhase(e4, t3, n3, r3), t3) {
              if (!n3 && this.match(65)) return;
              e4.exportKind = "type" === n3 ? n3 : "value";
            } else "type" === n3 && this.match(55) && this.unexpected(), e4.importKind = "type" === n3 || "typeof" === n3 ? n3 : "value";
          }
          parseImportSpecifier(e4, t3, n3, r3, i2) {
            const s2 = e4.imported;
            let a2 = null;
            "Identifier" === s2.type && ("type" === s2.name ? a2 = "type" : "typeof" === s2.name && (a2 = "typeof"));
            let o2 = false;
            if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
              const t4 = this.parseIdentifier(true);
              null === a2 || X(this.state.type) ? (e4.imported = s2, e4.importKind = null, e4.local = this.parseIdentifier()) : (e4.imported = t4, e4.importKind = a2, e4.local = at(t4));
            } else {
              if (null !== a2 && X(this.state.type)) e4.imported = this.parseIdentifier(true), e4.importKind = a2;
              else {
                if (t3) throw this.raise(g.ImportBindingIsString, { at: e4, importName: s2.value });
                e4.imported = s2, e4.importKind = null;
              }
              this.eatContextual(93) ? e4.local = this.parseIdentifier() : (o2 = true, e4.local = at(e4.imported));
            }
            const l2 = ut(e4);
            return n3 && l2 && this.raise(ct.ImportTypeShorthandOnlyInPureImport, { at: e4 }), (n3 || l2) && this.checkReservedType(e4.local.name, e4.local.loc.start, true), !o2 || n3 || l2 || this.checkReservedWord(e4.local.name, e4.loc.start, true, true), this.finishImportSpecifier(e4, "ImportSpecifier");
          }
          parseBindingAtom() {
            return 78 === this.state.type ? this.parseIdentifier(true) : super.parseBindingAtom();
          }
          parseFunctionParams(e4, t3) {
            const n3 = e4.kind;
            "get" !== n3 && "set" !== n3 && this.match(47) && (e4.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(e4, t3);
          }
          parseVarId(e4, t3) {
            super.parseVarId(e4, t3), this.match(14) && (e4.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(e4.id));
          }
          parseAsyncArrowFromCallExpression(e4, t3) {
            if (this.match(14)) {
              const t4 = this.state.noAnonFunctionType;
              this.state.noAnonFunctionType = true, e4.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = t4;
            }
            return super.parseAsyncArrowFromCallExpression(e4, t3);
          }
          shouldParseAsyncArrow() {
            return this.match(14) || super.shouldParseAsyncArrow();
          }
          parseMaybeAssign(e4, t3) {
            var n3;
            let r3, i2 = null;
            if (this.hasPlugin("jsx") && (this.match(140) || this.match(47))) {
              if (i2 = this.state.clone(), r3 = this.tryParse(() => super.parseMaybeAssign(e4, t3), i2), !r3.error) return r3.node;
              const { context: n4 } = this.state, s3 = n4[n4.length - 1];
              s3 !== x.j_oTag && s3 !== x.j_expr || n4.pop();
            }
            if (null != (n3 = r3) && n3.error || this.match(47)) {
              var s2, a2;
              let n4;
              i2 = i2 || this.state.clone();
              const o2 = this.tryParse((r4) => {
                var i3;
                n4 = this.flowParseTypeParameterDeclaration();
                const s3 = this.forwardNoArrowParamsConversionAt(n4, () => {
                  const r5 = super.parseMaybeAssign(e4, t3);
                  return this.resetStartLocationFromNode(r5, n4), r5;
                });
                null != (i3 = s3.extra) && i3.parenthesized && r4();
                const a3 = this.maybeUnwrapTypeCastExpression(s3);
                return "ArrowFunctionExpression" !== a3.type && r4(), a3.typeParameters = n4, this.resetStartLocationFromNode(a3, n4), s3;
              }, i2);
              let l2 = null;
              if (o2.node && "ArrowFunctionExpression" === this.maybeUnwrapTypeCastExpression(o2.node).type) {
                if (!o2.error && !o2.aborted) return o2.node.async && this.raise(ct.UnexpectedTypeParameterBeforeAsyncArrowFunction, { at: n4 }), o2.node;
                l2 = o2.node;
              }
              if (null != (s2 = r3) && s2.node) return this.state = r3.failState, r3.node;
              if (l2) return this.state = o2.failState, l2;
              if (null != (a2 = r3) && a2.thrown) throw r3.error;
              if (o2.thrown) throw o2.error;
              throw this.raise(ct.UnexpectedTokenAfterTypeParameter, { at: n4 });
            }
            return super.parseMaybeAssign(e4, t3);
          }
          parseArrow(e4) {
            if (this.match(14)) {
              const t3 = this.tryParse(() => {
                const t4 = this.state.noAnonFunctionType;
                this.state.noAnonFunctionType = true;
                const n3 = this.startNode();
                return [n3.typeAnnotation, e4.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = t4, this.canInsertSemicolon() && this.unexpected(), this.match(19) || this.unexpected(), n3;
              });
              if (t3.thrown) return null;
              t3.error && (this.state = t3.failState), e4.returnType = t3.node.typeAnnotation ? this.finishNode(t3.node, "TypeAnnotation") : null;
            }
            return super.parseArrow(e4);
          }
          shouldParseArrow(e4) {
            return this.match(14) || super.shouldParseArrow(e4);
          }
          setArrowFunctionParameters(e4, t3) {
            -1 !== this.state.noArrowParamsConversionAt.indexOf(e4.start) ? e4.params = t3 : super.setArrowFunctionParameters(e4, t3);
          }
          checkParams(e4, t3, n3, r3 = true) {
            if (!n3 || -1 === this.state.noArrowParamsConversionAt.indexOf(e4.start)) {
              for (let t4 = 0; t4 < e4.params.length; t4++) this.isThisParam(e4.params[t4]) && t4 > 0 && this.raise(ct.ThisParamMustBeFirst, { at: e4.params[t4] });
              super.checkParams(e4, t3, n3, r3);
            }
          }
          parseParenAndDistinguishExpression(e4) {
            return super.parseParenAndDistinguishExpression(e4 && -1 === this.state.noArrowAt.indexOf(this.state.start));
          }
          parseSubscripts(e4, t3, n3) {
            if ("Identifier" === e4.type && "async" === e4.name && -1 !== this.state.noArrowAt.indexOf(t3.index)) {
              this.next();
              const n4 = this.startNodeAt(t3);
              n4.callee = e4, n4.arguments = super.parseCallExpressionArguments(11, false), e4 = this.finishNode(n4, "CallExpression");
            } else if ("Identifier" === e4.type && "async" === e4.name && this.match(47)) {
              const r3 = this.state.clone(), i2 = this.tryParse((e5) => this.parseAsyncArrowWithTypeParameters(t3) || e5(), r3);
              if (!i2.error && !i2.aborted) return i2.node;
              const s2 = this.tryParse(() => super.parseSubscripts(e4, t3, n3), r3);
              if (s2.node && !s2.error) return s2.node;
              if (i2.node) return this.state = i2.failState, i2.node;
              if (s2.node) return this.state = s2.failState, s2.node;
              throw i2.error || s2.error;
            }
            return super.parseSubscripts(e4, t3, n3);
          }
          parseSubscript(e4, t3, n3, r3) {
            if (this.match(18) && this.isLookaheadToken_lt()) {
              if (r3.optionalChainMember = true, n3) return r3.stop = true, e4;
              this.next();
              const i2 = this.startNodeAt(t3);
              return i2.callee = e4, i2.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(10), i2.arguments = this.parseCallExpressionArguments(11, false), i2.optional = true, this.finishCallExpression(i2, true);
            }
            if (!n3 && this.shouldParseTypes() && this.match(47)) {
              const n4 = this.startNodeAt(t3);
              n4.callee = e4;
              const i2 = this.tryParse(() => (n4.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), n4.arguments = super.parseCallExpressionArguments(11, false), r3.optionalChainMember && (n4.optional = false), this.finishCallExpression(n4, r3.optionalChainMember)));
              if (i2.node) return i2.error && (this.state = i2.failState), i2.node;
            }
            return super.parseSubscript(e4, t3, n3, r3);
          }
          parseNewCallee(e4) {
            super.parseNewCallee(e4);
            let t3 = null;
            this.shouldParseTypes() && this.match(47) && (t3 = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), e4.typeArguments = t3;
          }
          parseAsyncArrowWithTypeParameters(e4) {
            const t3 = this.startNodeAt(e4);
            if (this.parseFunctionParams(t3, false), this.parseArrow(t3)) return super.parseArrowExpression(t3, void 0, true);
          }
          readToken_mult_modulo(e4) {
            const t3 = this.input.charCodeAt(this.state.pos + 1);
            if (42 === e4 && 47 === t3 && this.state.hasFlowComment) return this.state.hasFlowComment = false, this.state.pos += 2, void this.nextToken();
            super.readToken_mult_modulo(e4);
          }
          readToken_pipe_amp(e4) {
            const t3 = this.input.charCodeAt(this.state.pos + 1);
            124 !== e4 || 125 !== t3 ? super.readToken_pipe_amp(e4) : this.finishOp(9, 2);
          }
          parseTopLevel(e4, t3) {
            const n3 = super.parseTopLevel(e4, t3);
            return this.state.hasFlowComment && this.raise(ct.UnterminatedFlowComment, { at: this.state.curPosition() }), n3;
          }
          skipBlockComment() {
            if (!this.hasPlugin("flowComments") || !this.skipFlowComment()) return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
            {
              if (this.state.hasFlowComment) throw this.raise(ct.NestedFlowComment, { at: this.state.startLoc });
              this.hasFlowCommentCompletion();
              const e4 = this.skipFlowComment();
              e4 && (this.state.pos += e4, this.state.hasFlowComment = true);
            }
          }
          skipFlowComment() {
            const { pos: e4 } = this.state;
            let t3 = 2;
            for (; [32, 9].includes(this.input.charCodeAt(e4 + t3)); ) t3++;
            const n3 = this.input.charCodeAt(t3 + e4), r3 = this.input.charCodeAt(t3 + e4 + 1);
            return 58 === n3 && 58 === r3 ? t3 + 2 : "flow-include" === this.input.slice(t3 + e4, t3 + e4 + 12) ? t3 + 12 : 58 === n3 && 58 !== r3 && t3;
          }
          hasFlowCommentCompletion() {
            if (-1 === this.input.indexOf("*/", this.state.pos)) throw this.raise(g.UnterminatedComment, { at: this.state.curPosition() });
          }
          flowEnumErrorBooleanMemberNotInitialized(e4, { enumName: t3, memberName: n3 }) {
            this.raise(ct.EnumBooleanMemberNotInitialized, { at: e4, memberName: n3, enumName: t3 });
          }
          flowEnumErrorInvalidMemberInitializer(e4, t3) {
            return this.raise(t3.explicitType ? "symbol" === t3.explicitType ? ct.EnumInvalidMemberInitializerSymbolType : ct.EnumInvalidMemberInitializerPrimaryType : ct.EnumInvalidMemberInitializerUnknownType, Object.assign({ at: e4 }, t3));
          }
          flowEnumErrorNumberMemberNotInitialized(e4, { enumName: t3, memberName: n3 }) {
            this.raise(ct.EnumNumberMemberNotInitialized, { at: e4, enumName: t3, memberName: n3 });
          }
          flowEnumErrorStringMemberInconsistentlyInitialized(e4, { enumName: t3 }) {
            this.raise(ct.EnumStringMemberInconsistentlyInitialized, { at: e4, enumName: t3 });
          }
          flowEnumMemberInit() {
            const e4 = this.state.startLoc, t3 = () => this.match(12) || this.match(8);
            switch (this.state.type) {
              case 132: {
                const n3 = this.parseNumericLiteral(this.state.value);
                return t3() ? { type: "number", loc: n3.loc.start, value: n3 } : { type: "invalid", loc: e4 };
              }
              case 131: {
                const n3 = this.parseStringLiteral(this.state.value);
                return t3() ? { type: "string", loc: n3.loc.start, value: n3 } : { type: "invalid", loc: e4 };
              }
              case 85:
              case 86: {
                const n3 = this.parseBooleanLiteral(this.match(85));
                return t3() ? { type: "boolean", loc: n3.loc.start, value: n3 } : { type: "invalid", loc: e4 };
              }
              default:
                return { type: "invalid", loc: e4 };
            }
          }
          flowEnumMemberRaw() {
            const e4 = this.state.startLoc;
            return { id: this.parseIdentifier(true), init: this.eat(29) ? this.flowEnumMemberInit() : { type: "none", loc: e4 } };
          }
          flowEnumCheckExplicitTypeMismatch(e4, t3, n3) {
            const { explicitType: r3 } = t3;
            null !== r3 && r3 !== n3 && this.flowEnumErrorInvalidMemberInitializer(e4, t3);
          }
          flowEnumMembers({ enumName: e4, explicitType: t3 }) {
            const n3 = /* @__PURE__ */ new Set(), r3 = { booleanMembers: [], numberMembers: [], stringMembers: [], defaultedMembers: [] };
            let i2 = false;
            for (; !this.match(8); ) {
              if (this.eat(21)) {
                i2 = true;
                break;
              }
              const s2 = this.startNode(), { id: a2, init: o2 } = this.flowEnumMemberRaw(), l2 = a2.name;
              if ("" === l2) continue;
              /^[a-z]/.test(l2) && this.raise(ct.EnumInvalidMemberName, { at: a2, memberName: l2, suggestion: l2[0].toUpperCase() + l2.slice(1), enumName: e4 }), n3.has(l2) && this.raise(ct.EnumDuplicateMemberName, { at: a2, memberName: l2, enumName: e4 }), n3.add(l2);
              const c2 = { enumName: e4, explicitType: t3, memberName: l2 };
              switch (s2.id = a2, o2.type) {
                case "boolean":
                  this.flowEnumCheckExplicitTypeMismatch(o2.loc, c2, "boolean"), s2.init = o2.value, r3.booleanMembers.push(this.finishNode(s2, "EnumBooleanMember"));
                  break;
                case "number":
                  this.flowEnumCheckExplicitTypeMismatch(o2.loc, c2, "number"), s2.init = o2.value, r3.numberMembers.push(this.finishNode(s2, "EnumNumberMember"));
                  break;
                case "string":
                  this.flowEnumCheckExplicitTypeMismatch(o2.loc, c2, "string"), s2.init = o2.value, r3.stringMembers.push(this.finishNode(s2, "EnumStringMember"));
                  break;
                case "invalid":
                  throw this.flowEnumErrorInvalidMemberInitializer(o2.loc, c2);
                case "none":
                  switch (t3) {
                    case "boolean":
                      this.flowEnumErrorBooleanMemberNotInitialized(o2.loc, c2);
                      break;
                    case "number":
                      this.flowEnumErrorNumberMemberNotInitialized(o2.loc, c2);
                      break;
                    default:
                      r3.defaultedMembers.push(this.finishNode(s2, "EnumDefaultedMember"));
                  }
              }
              this.match(8) || this.expect(12);
            }
            return { members: r3, hasUnknownMembers: i2 };
          }
          flowEnumStringMembers(e4, t3, { enumName: n3 }) {
            if (0 === e4.length) return t3;
            if (0 === t3.length) return e4;
            if (t3.length > e4.length) {
              for (const t4 of e4) this.flowEnumErrorStringMemberInconsistentlyInitialized(t4, { enumName: n3 });
              return t3;
            }
            for (const e5 of t3) this.flowEnumErrorStringMemberInconsistentlyInitialized(e5, { enumName: n3 });
            return e4;
          }
          flowEnumParseExplicitType({ enumName: e4 }) {
            if (!this.eatContextual(101)) return null;
            if (!W(this.state.type)) throw this.raise(ct.EnumInvalidExplicitTypeUnknownSupplied, { at: this.state.startLoc, enumName: e4 });
            const { value: t3 } = this.state;
            return this.next(), "boolean" !== t3 && "number" !== t3 && "string" !== t3 && "symbol" !== t3 && this.raise(ct.EnumInvalidExplicitType, { at: this.state.startLoc, enumName: e4, invalidEnumType: t3 }), t3;
          }
          flowEnumBody(e4, t3) {
            const n3 = t3.name, r3 = t3.loc.start, i2 = this.flowEnumParseExplicitType({ enumName: n3 });
            this.expect(5);
            const { members: s2, hasUnknownMembers: a2 } = this.flowEnumMembers({ enumName: n3, explicitType: i2 });
            switch (e4.hasUnknownMembers = a2, i2) {
              case "boolean":
                return e4.explicitType = true, e4.members = s2.booleanMembers, this.expect(8), this.finishNode(e4, "EnumBooleanBody");
              case "number":
                return e4.explicitType = true, e4.members = s2.numberMembers, this.expect(8), this.finishNode(e4, "EnumNumberBody");
              case "string":
                return e4.explicitType = true, e4.members = this.flowEnumStringMembers(s2.stringMembers, s2.defaultedMembers, { enumName: n3 }), this.expect(8), this.finishNode(e4, "EnumStringBody");
              case "symbol":
                return e4.members = s2.defaultedMembers, this.expect(8), this.finishNode(e4, "EnumSymbolBody");
              default: {
                const t4 = () => (e4.members = [], this.expect(8), this.finishNode(e4, "EnumStringBody"));
                e4.explicitType = false;
                const i3 = s2.booleanMembers.length, a3 = s2.numberMembers.length, o2 = s2.stringMembers.length, l2 = s2.defaultedMembers.length;
                if (i3 || a3 || o2 || l2) {
                  if (i3 || a3) {
                    if (!a3 && !o2 && i3 >= l2) {
                      for (const e5 of s2.defaultedMembers) this.flowEnumErrorBooleanMemberNotInitialized(e5.loc.start, { enumName: n3, memberName: e5.id.name });
                      return e4.members = s2.booleanMembers, this.expect(8), this.finishNode(e4, "EnumBooleanBody");
                    }
                    if (!i3 && !o2 && a3 >= l2) {
                      for (const e5 of s2.defaultedMembers) this.flowEnumErrorNumberMemberNotInitialized(e5.loc.start, { enumName: n3, memberName: e5.id.name });
                      return e4.members = s2.numberMembers, this.expect(8), this.finishNode(e4, "EnumNumberBody");
                    }
                    return this.raise(ct.EnumInconsistentMemberValues, { at: r3, enumName: n3 }), t4();
                  }
                  return e4.members = this.flowEnumStringMembers(s2.stringMembers, s2.defaultedMembers, { enumName: n3 }), this.expect(8), this.finishNode(e4, "EnumStringBody");
                }
                return t4();
              }
            }
          }
          flowParseEnumDeclaration(e4) {
            const t3 = this.parseIdentifier();
            return e4.id = t3, e4.body = this.flowEnumBody(this.startNode(), t3), this.finishNode(e4, "EnumDeclaration");
          }
          isLookaheadToken_lt() {
            const e4 = this.nextTokenStart();
            if (60 === this.input.charCodeAt(e4)) {
              const t3 = this.input.charCodeAt(e4 + 1);
              return 60 !== t3 && 61 !== t3;
            }
            return false;
          }
          maybeUnwrapTypeCastExpression(e4) {
            return "TypeCastExpression" === e4.type ? e4.expression : e4;
          }
        }, typescript: (e3) => class extends e3 {
          constructor(...e4) {
            super(...e4), this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, { allowedModifiers: ["in", "out"], disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"], errorTemplate: Pt.InvalidModifierOnTypeParameter }), this.tsParseConstModifier = this.tsParseModifiers.bind(this, { allowedModifiers: ["const"], disallowedModifiers: ["in", "out"], errorTemplate: Pt.InvalidModifierOnTypeParameterPositions }), this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, { allowedModifiers: ["in", "out", "const"], disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"], errorTemplate: Pt.InvalidModifierOnTypeParameter });
          }
          getScopeHandler() {
            return gt;
          }
          tsIsIdentifier() {
            return W(this.state.type);
          }
          tsTokenCanFollowModifier() {
            return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(136) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
          }
          tsNextTokenCanFollowModifier() {
            return this.next(), this.tsTokenCanFollowModifier();
          }
          tsParseModifier(e4, t3) {
            if (!W(this.state.type) && 58 !== this.state.type && 75 !== this.state.type) return;
            const n3 = this.state.value;
            if (-1 !== e4.indexOf(n3)) {
              if (t3 && this.tsIsStartOfStaticBlocks()) return;
              if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) return n3;
            }
          }
          tsParseModifiers({ allowedModifiers: e4, disallowedModifiers: t3, stopOnStartOfClassStaticBlock: n3, errorTemplate: r3 = Pt.InvalidModifierOnTypeMember }, i2) {
            const s2 = (e5, t4, n4, r4) => {
              t4 === n4 && i2[r4] && this.raise(Pt.InvalidModifiersOrder, { at: e5, orderedModifiers: [n4, r4] });
            }, a2 = (e5, t4, n4, r4) => {
              (i2[n4] && t4 === r4 || i2[r4] && t4 === n4) && this.raise(Pt.IncompatibleModifiers, { at: e5, modifiers: [n4, r4] });
            };
            for (; ; ) {
              const { startLoc: o2 } = this.state, l2 = this.tsParseModifier(e4.concat(null != t3 ? t3 : []), n3);
              if (!l2) break;
              xt(l2) ? i2.accessibility ? this.raise(Pt.DuplicateAccessibilityModifier, { at: o2, modifier: l2 }) : (s2(o2, l2, l2, "override"), s2(o2, l2, l2, "static"), s2(o2, l2, l2, "readonly"), i2.accessibility = l2) : Dt(l2) ? (i2[l2] && this.raise(Pt.DuplicateModifier, { at: o2, modifier: l2 }), i2[l2] = true, s2(o2, l2, "in", "out")) : (Object.hasOwnProperty.call(i2, l2) ? this.raise(Pt.DuplicateModifier, { at: o2, modifier: l2 }) : (s2(o2, l2, "static", "readonly"), s2(o2, l2, "static", "override"), s2(o2, l2, "override", "readonly"), s2(o2, l2, "abstract", "override"), a2(o2, l2, "declare", "override"), a2(o2, l2, "static", "abstract")), i2[l2] = true), null != t3 && t3.includes(l2) && this.raise(r3, { at: o2, modifier: l2 });
            }
          }
          tsIsListTerminator(e4) {
            switch (e4) {
              case "EnumMembers":
              case "TypeMembers":
                return this.match(8);
              case "HeritageClauseElement":
                return this.match(5);
              case "TupleElementTypes":
                return this.match(3);
              case "TypeParametersOrArguments":
                return this.match(48);
            }
          }
          tsParseList(e4, t3) {
            const n3 = [];
            for (; !this.tsIsListTerminator(e4); ) n3.push(t3());
            return n3;
          }
          tsParseDelimitedList(e4, t3, n3) {
            return function(e5) {
              if (null == e5) throw new Error(`Unexpected ${e5} value.`);
              return e5;
            }(this.tsParseDelimitedListWorker(e4, t3, true, n3));
          }
          tsParseDelimitedListWorker(e4, t3, n3, r3) {
            const i2 = [];
            let s2 = -1;
            for (; !this.tsIsListTerminator(e4); ) {
              s2 = -1;
              const r4 = t3();
              if (null == r4) return;
              if (i2.push(r4), !this.eat(12)) {
                if (this.tsIsListTerminator(e4)) break;
                return void (n3 && this.expect(12));
              }
              s2 = this.state.lastTokStart;
            }
            return r3 && (r3.value = s2), i2;
          }
          tsParseBracketedList(e4, t3, n3, r3, i2) {
            r3 || (n3 ? this.expect(0) : this.expect(47));
            const s2 = this.tsParseDelimitedList(e4, t3, i2);
            return n3 ? this.expect(3) : this.expect(48), s2;
          }
          tsParseImportType() {
            const e4 = this.startNode();
            return this.expect(83), this.expect(10), this.match(131) || this.raise(Pt.UnsupportedImportTypeArgument, { at: this.state.startLoc }), e4.argument = super.parseExprAtom(), this.expect(11), this.eat(16) && (e4.qualifier = this.tsParseEntityName()), this.match(47) && (e4.typeParameters = this.tsParseTypeArguments()), this.finishNode(e4, "TSImportType");
          }
          tsParseEntityName(e4 = true) {
            let t3 = this.parseIdentifier(e4);
            for (; this.eat(16); ) {
              const n3 = this.startNodeAtNode(t3);
              n3.left = t3, n3.right = this.parseIdentifier(e4), t3 = this.finishNode(n3, "TSQualifiedName");
            }
            return t3;
          }
          tsParseTypeReference() {
            const e4 = this.startNode();
            return e4.typeName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (e4.typeParameters = this.tsParseTypeArguments()), this.finishNode(e4, "TSTypeReference");
          }
          tsParseThisTypePredicate(e4) {
            this.next();
            const t3 = this.startNodeAtNode(e4);
            return t3.parameterName = e4, t3.typeAnnotation = this.tsParseTypeAnnotation(false), t3.asserts = false, this.finishNode(t3, "TSTypePredicate");
          }
          tsParseThisTypeNode() {
            const e4 = this.startNode();
            return this.next(), this.finishNode(e4, "TSThisType");
          }
          tsParseTypeQuery() {
            const e4 = this.startNode();
            return this.expect(87), this.match(83) ? e4.exprName = this.tsParseImportType() : e4.exprName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (e4.typeParameters = this.tsParseTypeArguments()), this.finishNode(e4, "TSTypeQuery");
          }
          tsParseTypeParameter(e4) {
            const t3 = this.startNode();
            return e4(t3), t3.name = this.tsParseTypeParameterName(), t3.constraint = this.tsEatThenParseType(81), t3.default = this.tsEatThenParseType(29), this.finishNode(t3, "TSTypeParameter");
          }
          tsTryParseTypeParameters(e4) {
            if (this.match(47)) return this.tsParseTypeParameters(e4);
          }
          tsParseTypeParameters(e4) {
            const t3 = this.startNode();
            this.match(47) || this.match(140) ? this.next() : this.unexpected();
            const n3 = { value: -1 };
            return t3.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, e4), false, true, n3), 0 === t3.params.length && this.raise(Pt.EmptyTypeParameters, { at: t3 }), -1 !== n3.value && this.addExtra(t3, "trailingComma", n3.value), this.finishNode(t3, "TSTypeParameterDeclaration");
          }
          tsFillSignature(e4, t3) {
            const n3 = 19 === e4;
            t3.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier), this.expect(10), t3.parameters = this.tsParseBindingListForSignature(), (n3 || this.match(e4)) && (t3.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(e4));
          }
          tsParseBindingListForSignature() {
            const e4 = super.parseBindingList(11, 41, 2);
            for (const t3 of e4) {
              const { type: e5 } = t3;
              "AssignmentPattern" !== e5 && "TSParameterProperty" !== e5 || this.raise(Pt.UnsupportedSignatureParameterKind, { at: t3, type: e5 });
            }
            return e4;
          }
          tsParseTypeMemberSemicolon() {
            this.eat(12) || this.isLineTerminator() || this.expect(13);
          }
          tsParseSignatureMember(e4, t3) {
            return this.tsFillSignature(14, t3), this.tsParseTypeMemberSemicolon(), this.finishNode(t3, e4);
          }
          tsIsUnambiguouslyIndexSignature() {
            return this.next(), !!W(this.state.type) && (this.next(), this.match(14));
          }
          tsTryParseIndexSignature(e4) {
            if (!this.match(0) || !this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))) return;
            this.expect(0);
            const t3 = this.parseIdentifier();
            t3.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(t3), this.expect(3), e4.parameters = [t3];
            const n3 = this.tsTryParseTypeAnnotation();
            return n3 && (e4.typeAnnotation = n3), this.tsParseTypeMemberSemicolon(), this.finishNode(e4, "TSIndexSignature");
          }
          tsParsePropertyOrMethodSignature(e4, t3) {
            this.eat(17) && (e4.optional = true);
            const n3 = e4;
            if (this.match(10) || this.match(47)) {
              t3 && this.raise(Pt.ReadonlyForMethodSignature, { at: e4 });
              const r3 = n3;
              r3.kind && this.match(47) && this.raise(Pt.AccesorCannotHaveTypeParameters, { at: this.state.curPosition() }), this.tsFillSignature(14, r3), this.tsParseTypeMemberSemicolon();
              const i2 = "parameters", s2 = "typeAnnotation";
              if ("get" === r3.kind) r3[i2].length > 0 && (this.raise(g.BadGetterArity, { at: this.state.curPosition() }), this.isThisParam(r3[i2][0]) && this.raise(Pt.AccesorCannotDeclareThisParameter, { at: this.state.curPosition() }));
              else if ("set" === r3.kind) {
                if (1 !== r3[i2].length) this.raise(g.BadSetterArity, { at: this.state.curPosition() });
                else {
                  const e5 = r3[i2][0];
                  this.isThisParam(e5) && this.raise(Pt.AccesorCannotDeclareThisParameter, { at: this.state.curPosition() }), "Identifier" === e5.type && e5.optional && this.raise(Pt.SetAccesorCannotHaveOptionalParameter, { at: this.state.curPosition() }), "RestElement" === e5.type && this.raise(Pt.SetAccesorCannotHaveRestParameter, { at: this.state.curPosition() });
                }
                r3[s2] && this.raise(Pt.SetAccesorCannotHaveReturnType, { at: r3[s2] });
              } else r3.kind = "method";
              return this.finishNode(r3, "TSMethodSignature");
            }
            {
              const e5 = n3;
              t3 && (e5.readonly = true);
              const r3 = this.tsTryParseTypeAnnotation();
              return r3 && (e5.typeAnnotation = r3), this.tsParseTypeMemberSemicolon(), this.finishNode(e5, "TSPropertySignature");
            }
          }
          tsParseTypeMember() {
            const e4 = this.startNode();
            if (this.match(10) || this.match(47)) return this.tsParseSignatureMember("TSCallSignatureDeclaration", e4);
            if (this.match(77)) {
              const t3 = this.startNode();
              return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", e4) : (e4.key = this.createIdentifier(t3, "new"), this.tsParsePropertyOrMethodSignature(e4, false));
            }
            this.tsParseModifiers({ allowedModifiers: ["readonly"], disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"] }, e4);
            return this.tsTryParseIndexSignature(e4) || (super.parsePropertyName(e4), e4.computed || "Identifier" !== e4.key.type || "get" !== e4.key.name && "set" !== e4.key.name || !this.tsTokenCanFollowModifier() || (e4.kind = e4.key.name, super.parsePropertyName(e4)), this.tsParsePropertyOrMethodSignature(e4, !!e4.readonly));
          }
          tsParseTypeLiteral() {
            const e4 = this.startNode();
            return e4.members = this.tsParseObjectTypeMembers(), this.finishNode(e4, "TSTypeLiteral");
          }
          tsParseObjectTypeMembers() {
            this.expect(5);
            const e4 = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
            return this.expect(8), e4;
          }
          tsIsStartOfMappedType() {
            return this.next(), this.eat(53) ? this.isContextual(120) : (this.isContextual(120) && this.next(), !!this.match(0) && (this.next(), !!this.tsIsIdentifier() && (this.next(), this.match(58))));
          }
          tsParseMappedTypeParameter() {
            const e4 = this.startNode();
            return e4.name = this.tsParseTypeParameterName(), e4.constraint = this.tsExpectThenParseType(58), this.finishNode(e4, "TSTypeParameter");
          }
          tsParseMappedType() {
            const e4 = this.startNode();
            return this.expect(5), this.match(53) ? (e4.readonly = this.state.value, this.next(), this.expectContextual(120)) : this.eatContextual(120) && (e4.readonly = true), this.expect(0), e4.typeParameter = this.tsParseMappedTypeParameter(), e4.nameType = this.eatContextual(93) ? this.tsParseType() : null, this.expect(3), this.match(53) ? (e4.optional = this.state.value, this.next(), this.expect(17)) : this.eat(17) && (e4.optional = true), e4.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(e4, "TSMappedType");
          }
          tsParseTupleType() {
            const e4 = this.startNode();
            e4.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
            let t3 = false, n3 = null;
            return e4.elementTypes.forEach((e5) => {
              const { type: r3 } = e5;
              !t3 || "TSRestType" === r3 || "TSOptionalType" === r3 || "TSNamedTupleMember" === r3 && e5.optional || this.raise(Pt.OptionalTypeBeforeRequired, { at: e5 }), t3 || (t3 = "TSNamedTupleMember" === r3 && e5.optional || "TSOptionalType" === r3);
              let i2 = r3;
              "TSRestType" === r3 && (i2 = (e5 = e5.typeAnnotation).type);
              const s2 = "TSNamedTupleMember" === i2;
              null != n3 || (n3 = s2), n3 !== s2 && this.raise(Pt.MixedLabeledAndUnlabeledElements, { at: e5 });
            }), this.finishNode(e4, "TSTupleType");
          }
          tsParseTupleElementType() {
            const { startLoc: e4 } = this.state, t3 = this.eat(21);
            let n3, r3, i2, s2;
            const a2 = X(this.state.type) ? this.lookaheadCharCode() : null;
            if (58 === a2) n3 = true, i2 = false, r3 = this.parseIdentifier(true), this.expect(14), s2 = this.tsParseType();
            else if (63 === a2) {
              i2 = true;
              const e5 = this.state.startLoc, t4 = this.state.value, a3 = this.tsParseNonArrayType();
              58 === this.lookaheadCharCode() ? (n3 = true, r3 = this.createIdentifier(this.startNodeAt(e5), t4), this.expect(17), this.expect(14), s2 = this.tsParseType()) : (n3 = false, s2 = a3, this.expect(17));
            } else s2 = this.tsParseType(), i2 = this.eat(17), n3 = this.eat(14);
            if (n3) {
              let e5;
              r3 ? (e5 = this.startNodeAtNode(r3), e5.optional = i2, e5.label = r3, e5.elementType = s2, this.eat(17) && (e5.optional = true, this.raise(Pt.TupleOptionalAfterType, { at: this.state.lastTokStartLoc }))) : (e5 = this.startNodeAtNode(s2), e5.optional = i2, this.raise(Pt.InvalidTupleMemberLabel, { at: s2 }), e5.label = s2, e5.elementType = this.tsParseType()), s2 = this.finishNode(e5, "TSNamedTupleMember");
            } else if (i2) {
              const e5 = this.startNodeAtNode(s2);
              e5.typeAnnotation = s2, s2 = this.finishNode(e5, "TSOptionalType");
            }
            if (t3) {
              const t4 = this.startNodeAt(e4);
              t4.typeAnnotation = s2, s2 = this.finishNode(t4, "TSRestType");
            }
            return s2;
          }
          tsParseParenthesizedType() {
            const e4 = this.startNode();
            return this.expect(10), e4.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(e4, "TSParenthesizedType");
          }
          tsParseFunctionOrConstructorType(e4, t3) {
            const n3 = this.startNode();
            return "TSConstructorType" === e4 && (n3.abstract = !!t3, t3 && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, n3)), this.finishNode(n3, e4);
          }
          tsParseLiteralTypeNode() {
            const e4 = this.startNode();
            switch (this.state.type) {
              case 132:
              case 133:
              case 131:
              case 85:
              case 86:
                e4.literal = super.parseExprAtom();
                break;
              default:
                this.unexpected();
            }
            return this.finishNode(e4, "TSLiteralType");
          }
          tsParseTemplateLiteralType() {
            const e4 = this.startNode();
            return e4.literal = super.parseTemplate(false), this.finishNode(e4, "TSLiteralType");
          }
          parseTemplateSubstitution() {
            return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
          }
          tsParseThisTypeOrThisTypePredicate() {
            const e4 = this.tsParseThisTypeNode();
            return this.isContextual(114) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(e4) : e4;
          }
          tsParseNonArrayType() {
            switch (this.state.type) {
              case 131:
              case 132:
              case 133:
              case 85:
              case 86:
                return this.tsParseLiteralTypeNode();
              case 53:
                if ("-" === this.state.value) {
                  const e4 = this.startNode(), t3 = this.lookahead();
                  return 132 !== t3.type && 133 !== t3.type && this.unexpected(), e4.literal = this.parseMaybeUnary(), this.finishNode(e4, "TSLiteralType");
                }
                break;
              case 78:
                return this.tsParseThisTypeOrThisTypePredicate();
              case 87:
                return this.tsParseTypeQuery();
              case 83:
                return this.tsParseImportType();
              case 5:
                return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
              case 0:
                return this.tsParseTupleType();
              case 10:
                return this.tsParseParenthesizedType();
              case 25:
              case 24:
                return this.tsParseTemplateLiteralType();
              default: {
                const { type: e4 } = this.state;
                if (W(e4) || 88 === e4 || 84 === e4) {
                  const t3 = 88 === e4 ? "TSVoidKeyword" : 84 === e4 ? "TSNullKeyword" : function(e5) {
                    switch (e5) {
                      case "any":
                        return "TSAnyKeyword";
                      case "boolean":
                        return "TSBooleanKeyword";
                      case "bigint":
                        return "TSBigIntKeyword";
                      case "never":
                        return "TSNeverKeyword";
                      case "number":
                        return "TSNumberKeyword";
                      case "object":
                        return "TSObjectKeyword";
                      case "string":
                        return "TSStringKeyword";
                      case "symbol":
                        return "TSSymbolKeyword";
                      case "undefined":
                        return "TSUndefinedKeyword";
                      case "unknown":
                        return "TSUnknownKeyword";
                      default:
                        return;
                    }
                  }(this.state.value);
                  if (void 0 !== t3 && 46 !== this.lookaheadCharCode()) {
                    const e5 = this.startNode();
                    return this.next(), this.finishNode(e5, t3);
                  }
                  return this.tsParseTypeReference();
                }
              }
            }
            this.unexpected();
          }
          tsParseArrayTypeOrHigher() {
            let e4 = this.tsParseNonArrayType();
            for (; !this.hasPrecedingLineBreak() && this.eat(0); ) if (this.match(3)) {
              const t3 = this.startNodeAtNode(e4);
              t3.elementType = e4, this.expect(3), e4 = this.finishNode(t3, "TSArrayType");
            } else {
              const t3 = this.startNodeAtNode(e4);
              t3.objectType = e4, t3.indexType = this.tsParseType(), this.expect(3), e4 = this.finishNode(t3, "TSIndexedAccessType");
            }
            return e4;
          }
          tsParseTypeOperator() {
            const e4 = this.startNode(), t3 = this.state.value;
            return this.next(), e4.operator = t3, e4.typeAnnotation = this.tsParseTypeOperatorOrHigher(), "readonly" === t3 && this.tsCheckTypeAnnotationForReadOnly(e4), this.finishNode(e4, "TSTypeOperator");
          }
          tsCheckTypeAnnotationForReadOnly(e4) {
            switch (e4.typeAnnotation.type) {
              case "TSTupleType":
              case "TSArrayType":
                return;
              default:
                this.raise(Pt.UnexpectedReadonly, { at: e4 });
            }
          }
          tsParseInferType() {
            const e4 = this.startNode();
            this.expectContextual(113);
            const t3 = this.startNode();
            return t3.name = this.tsParseTypeParameterName(), t3.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), e4.typeParameter = this.finishNode(t3, "TSTypeParameter"), this.finishNode(e4, "TSInferType");
          }
          tsParseConstraintForInferType() {
            if (this.eat(81)) {
              const e4 = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
              if (this.state.inDisallowConditionalTypesContext || !this.match(17)) return e4;
            }
          }
          tsParseTypeOperatorOrHigher() {
            var e4;
            return (e4 = this.state.type) >= 119 && e4 <= 121 && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(113) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
          }
          tsParseUnionOrIntersectionType(e4, t3, n3) {
            const r3 = this.startNode(), i2 = this.eat(n3), s2 = [];
            do {
              s2.push(t3());
            } while (this.eat(n3));
            return 1 !== s2.length || i2 ? (r3.types = s2, this.finishNode(r3, e4)) : s2[0];
          }
          tsParseIntersectionTypeOrHigher() {
            return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
          }
          tsParseUnionTypeOrHigher() {
            return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
          }
          tsIsStartOfFunctionType() {
            return !!this.match(47) || this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
          }
          tsSkipParameterStart() {
            if (W(this.state.type) || this.match(78)) return this.next(), true;
            if (this.match(5)) {
              const { errors: e4 } = this.state, t3 = e4.length;
              try {
                return this.parseObjectLike(8, true), e4.length === t3;
              } catch (e5) {
                return false;
              }
            }
            if (this.match(0)) {
              this.next();
              const { errors: e4 } = this.state, t3 = e4.length;
              try {
                return super.parseBindingList(3, 93, 1), e4.length === t3;
              } catch (e5) {
                return false;
              }
            }
            return false;
          }
          tsIsUnambiguouslyStartOfFunctionType() {
            if (this.next(), this.match(11) || this.match(21)) return true;
            if (this.tsSkipParameterStart()) {
              if (this.match(14) || this.match(12) || this.match(17) || this.match(29)) return true;
              if (this.match(11) && (this.next(), this.match(19))) return true;
            }
            return false;
          }
          tsParseTypeOrTypePredicateAnnotation(e4) {
            return this.tsInType(() => {
              const t3 = this.startNode();
              this.expect(e4);
              const n3 = this.startNode(), r3 = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
              if (r3 && this.match(78)) {
                let e5 = this.tsParseThisTypeOrThisTypePredicate();
                return "TSThisType" === e5.type ? (n3.parameterName = e5, n3.asserts = true, n3.typeAnnotation = null, e5 = this.finishNode(n3, "TSTypePredicate")) : (this.resetStartLocationFromNode(e5, n3), e5.asserts = true), t3.typeAnnotation = e5, this.finishNode(t3, "TSTypeAnnotation");
              }
              const i2 = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
              if (!i2) return r3 ? (n3.parameterName = this.parseIdentifier(), n3.asserts = r3, n3.typeAnnotation = null, t3.typeAnnotation = this.finishNode(n3, "TSTypePredicate"), this.finishNode(t3, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(false, t3);
              const s2 = this.tsParseTypeAnnotation(false);
              return n3.parameterName = i2, n3.typeAnnotation = s2, n3.asserts = r3, t3.typeAnnotation = this.finishNode(n3, "TSTypePredicate"), this.finishNode(t3, "TSTypeAnnotation");
            });
          }
          tsTryParseTypeOrTypePredicateAnnotation() {
            if (this.match(14)) return this.tsParseTypeOrTypePredicateAnnotation(14);
          }
          tsTryParseTypeAnnotation() {
            if (this.match(14)) return this.tsParseTypeAnnotation();
          }
          tsTryParseType() {
            return this.tsEatThenParseType(14);
          }
          tsParseTypePredicatePrefix() {
            const e4 = this.parseIdentifier();
            if (this.isContextual(114) && !this.hasPrecedingLineBreak()) return this.next(), e4;
          }
          tsParseTypePredicateAsserts() {
            if (107 !== this.state.type) return false;
            const e4 = this.state.containsEsc;
            return this.next(), !(!W(this.state.type) && !this.match(78) || (e4 && this.raise(g.InvalidEscapedReservedWord, { at: this.state.lastTokStartLoc, reservedWord: "asserts" }), 0));
          }
          tsParseTypeAnnotation(e4 = true, t3 = this.startNode()) {
            return this.tsInType(() => {
              e4 && this.expect(14), t3.typeAnnotation = this.tsParseType();
            }), this.finishNode(t3, "TSTypeAnnotation");
          }
          tsParseType() {
            St(this.state.inType);
            const e4 = this.tsParseNonConditionalType();
            if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) return e4;
            const t3 = this.startNodeAtNode(e4);
            return t3.checkType = e4, t3.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(17), t3.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), t3.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.finishNode(t3, "TSConditionalType");
          }
          isAbstractConstructorSignature() {
            return this.isContextual(122) && 77 === this.lookahead().type;
          }
          tsParseNonConditionalType() {
            return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", true) : this.tsParseUnionTypeOrHigher();
          }
          tsParseTypeAssertion() {
            this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(Pt.ReservedTypeAssertion, { at: this.state.startLoc });
            const e4 = this.startNode();
            return e4.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.expect(48), e4.expression = this.parseMaybeUnary(), this.finishNode(e4, "TSTypeAssertion");
          }
          tsParseHeritageClause(e4) {
            const t3 = this.state.startLoc, n3 = this.tsParseDelimitedList("HeritageClauseElement", () => {
              const e5 = this.startNode();
              return e5.expression = this.tsParseEntityName(), this.match(47) && (e5.typeParameters = this.tsParseTypeArguments()), this.finishNode(e5, "TSExpressionWithTypeArguments");
            });
            return n3.length || this.raise(Pt.EmptyHeritageClauseType, { at: t3, token: e4 }), n3;
          }
          tsParseInterfaceDeclaration(e4, t3 = {}) {
            if (this.hasFollowingLineBreak()) return null;
            this.expectContextual(127), t3.declare && (e4.declare = true), W(this.state.type) ? (e4.id = this.parseIdentifier(), this.checkIdentifier(e4.id, 130)) : (e4.id = null, this.raise(Pt.MissingInterfaceName, { at: this.state.startLoc })), e4.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers), this.eat(81) && (e4.extends = this.tsParseHeritageClause("extends"));
            const n3 = this.startNode();
            return n3.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), e4.body = this.finishNode(n3, "TSInterfaceBody"), this.finishNode(e4, "TSInterfaceDeclaration");
          }
          tsParseTypeAliasDeclaration(e4) {
            return e4.id = this.parseIdentifier(), this.checkIdentifier(e4.id, 2), e4.typeAnnotation = this.tsInType(() => {
              if (e4.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers), this.expect(29), this.isContextual(112) && 16 !== this.lookahead().type) {
                const e5 = this.startNode();
                return this.next(), this.finishNode(e5, "TSIntrinsicKeyword");
              }
              return this.tsParseType();
            }), this.semicolon(), this.finishNode(e4, "TSTypeAliasDeclaration");
          }
          tsInNoContext(e4) {
            const t3 = this.state.context;
            this.state.context = [t3[0]];
            try {
              return e4();
            } finally {
              this.state.context = t3;
            }
          }
          tsInType(e4) {
            const t3 = this.state.inType;
            this.state.inType = true;
            try {
              return e4();
            } finally {
              this.state.inType = t3;
            }
          }
          tsInDisallowConditionalTypesContext(e4) {
            const t3 = this.state.inDisallowConditionalTypesContext;
            this.state.inDisallowConditionalTypesContext = true;
            try {
              return e4();
            } finally {
              this.state.inDisallowConditionalTypesContext = t3;
            }
          }
          tsInAllowConditionalTypesContext(e4) {
            const t3 = this.state.inDisallowConditionalTypesContext;
            this.state.inDisallowConditionalTypesContext = false;
            try {
              return e4();
            } finally {
              this.state.inDisallowConditionalTypesContext = t3;
            }
          }
          tsEatThenParseType(e4) {
            if (this.match(e4)) return this.tsNextThenParseType();
          }
          tsExpectThenParseType(e4) {
            return this.tsInType(() => (this.expect(e4), this.tsParseType()));
          }
          tsNextThenParseType() {
            return this.tsInType(() => (this.next(), this.tsParseType()));
          }
          tsParseEnumMember() {
            const e4 = this.startNode();
            return e4.id = this.match(131) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(true), this.eat(29) && (e4.initializer = super.parseMaybeAssignAllowIn()), this.finishNode(e4, "TSEnumMember");
          }
          tsParseEnumDeclaration(e4, t3 = {}) {
            return t3.const && (e4.const = true), t3.declare && (e4.declare = true), this.expectContextual(124), e4.id = this.parseIdentifier(), this.checkIdentifier(e4.id, e4.const ? 8971 : 8459), this.expect(5), e4.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(e4, "TSEnumDeclaration");
          }
          tsParseModuleBlock() {
            const e4 = this.startNode();
            return this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody(e4.body = [], void 0, true, 8), this.scope.exit(), this.finishNode(e4, "TSModuleBlock");
          }
          tsParseModuleOrNamespaceDeclaration(e4, t3 = false) {
            if (e4.id = this.parseIdentifier(), t3 || this.checkIdentifier(e4.id, 1024), this.eat(16)) {
              const t4 = this.startNode();
              this.tsParseModuleOrNamespaceDeclaration(t4, true), e4.body = t4;
            } else this.scope.enter(256), this.prodParam.enter(0), e4.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
            return this.finishNode(e4, "TSModuleDeclaration");
          }
          tsParseAmbientExternalModuleDeclaration(e4) {
            return this.isContextual(110) ? (e4.global = true, e4.id = this.parseIdentifier()) : this.match(131) ? e4.id = super.parseStringLiteral(this.state.value) : this.unexpected(), this.match(5) ? (this.scope.enter(256), this.prodParam.enter(0), e4.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(e4, "TSModuleDeclaration");
          }
          tsParseImportEqualsDeclaration(e4, t3, n3) {
            e4.isExport = n3 || false, e4.id = t3 || this.parseIdentifier(), this.checkIdentifier(e4.id, 4096), this.expect(29);
            const r3 = this.tsParseModuleReference();
            return "type" === e4.importKind && "TSExternalModuleReference" !== r3.type && this.raise(Pt.ImportAliasHasImportType, { at: r3 }), e4.moduleReference = r3, this.semicolon(), this.finishNode(e4, "TSImportEqualsDeclaration");
          }
          tsIsExternalModuleReference() {
            return this.isContextual(117) && 40 === this.lookaheadCharCode();
          }
          tsParseModuleReference() {
            return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
          }
          tsParseExternalModuleReference() {
            const e4 = this.startNode();
            return this.expectContextual(117), this.expect(10), this.match(131) || this.unexpected(), e4.expression = super.parseExprAtom(), this.expect(11), this.sawUnambiguousESM = true, this.finishNode(e4, "TSExternalModuleReference");
          }
          tsLookAhead(e4) {
            const t3 = this.state.clone(), n3 = e4();
            return this.state = t3, n3;
          }
          tsTryParseAndCatch(e4) {
            const t3 = this.tryParse((t4) => e4() || t4());
            if (!t3.aborted && t3.node) return t3.error && (this.state = t3.failState), t3.node;
          }
          tsTryParse(e4) {
            const t3 = this.state.clone(), n3 = e4();
            if (void 0 !== n3 && false !== n3) return n3;
            this.state = t3;
          }
          tsTryParseDeclare(e4) {
            if (this.isLineTerminator()) return;
            let t3, n3 = this.state.type;
            return this.isContextual(99) && (n3 = 74, t3 = "let"), this.tsInAmbientContext(() => {
              switch (n3) {
                case 68:
                  return e4.declare = true, super.parseFunctionStatement(e4, false, false);
                case 80:
                  return e4.declare = true, this.parseClass(e4, true, false);
                case 124:
                  return this.tsParseEnumDeclaration(e4, { declare: true });
                case 110:
                  return this.tsParseAmbientExternalModuleDeclaration(e4);
                case 75:
                case 74:
                  return this.match(75) && this.isLookaheadContextual("enum") ? (this.expect(75), this.tsParseEnumDeclaration(e4, { const: true, declare: true })) : (e4.declare = true, this.parseVarStatement(e4, t3 || this.state.value, true));
                case 127: {
                  const t4 = this.tsParseInterfaceDeclaration(e4, { declare: true });
                  if (t4) return t4;
                }
                default:
                  if (W(n3)) return this.tsParseDeclaration(e4, this.state.value, true, null);
              }
            });
          }
          tsTryParseExportDeclaration() {
            return this.tsParseDeclaration(this.startNode(), this.state.value, true, null);
          }
          tsParseExpressionStatement(e4, t3, n3) {
            switch (t3.name) {
              case "declare": {
                const t4 = this.tsTryParseDeclare(e4);
                return t4 && (t4.declare = true), t4;
              }
              case "global":
                if (this.match(5)) {
                  this.scope.enter(256), this.prodParam.enter(0);
                  const n4 = e4;
                  return n4.global = true, n4.id = t3, n4.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(n4, "TSModuleDeclaration");
                }
                break;
              default:
                return this.tsParseDeclaration(e4, t3.name, false, n3);
            }
          }
          tsParseDeclaration(e4, t3, n3, r3) {
            switch (t3) {
              case "abstract":
                if (this.tsCheckLineTerminator(n3) && (this.match(80) || W(this.state.type))) return this.tsParseAbstractDeclaration(e4, r3);
                break;
              case "module":
                if (this.tsCheckLineTerminator(n3)) {
                  if (this.match(131)) return this.tsParseAmbientExternalModuleDeclaration(e4);
                  if (W(this.state.type)) return this.tsParseModuleOrNamespaceDeclaration(e4);
                }
                break;
              case "namespace":
                if (this.tsCheckLineTerminator(n3) && W(this.state.type)) return this.tsParseModuleOrNamespaceDeclaration(e4);
                break;
              case "type":
                if (this.tsCheckLineTerminator(n3) && W(this.state.type)) return this.tsParseTypeAliasDeclaration(e4);
            }
          }
          tsCheckLineTerminator(e4) {
            return e4 ? !this.hasFollowingLineBreak() && (this.next(), true) : !this.isLineTerminator();
          }
          tsTryParseGenericAsyncArrowFunction(e4) {
            if (!this.match(47)) return;
            const t3 = this.state.maybeInArrowParameters;
            this.state.maybeInArrowParameters = true;
            const n3 = this.tsTryParseAndCatch(() => {
              const t4 = this.startNodeAt(e4);
              return t4.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(t4), t4.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(19), t4;
            });
            return this.state.maybeInArrowParameters = t3, n3 ? super.parseArrowExpression(n3, null, true) : void 0;
          }
          tsParseTypeArgumentsInExpression() {
            if (47 === this.reScan_lt()) return this.tsParseTypeArguments();
          }
          tsParseTypeArguments() {
            const e4 = this.startNode();
            return e4.params = this.tsInType(() => this.tsInNoContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))), 0 === e4.params.length ? this.raise(Pt.EmptyTypeArguments, { at: e4 }) : this.state.inType || this.curContext() !== x.brace || this.reScan_lt_gt(), this.expect(48), this.finishNode(e4, "TSTypeParameterInstantiation");
          }
          tsIsDeclarationStart() {
            return (e4 = this.state.type) >= 122 && e4 <= 128;
            var e4;
          }
          isExportDefaultSpecifier() {
            return !this.tsIsDeclarationStart() && super.isExportDefaultSpecifier();
          }
          parseAssignableListItem(e4, t3) {
            const n3 = this.state.startLoc, r3 = {};
            this.tsParseModifiers({ allowedModifiers: ["public", "private", "protected", "override", "readonly"] }, r3);
            const i2 = r3.accessibility, s2 = r3.override, a2 = r3.readonly;
            4 & e4 || !(i2 || a2 || s2) || this.raise(Pt.UnexpectedParameterModifier, { at: n3 });
            const o2 = this.parseMaybeDefault();
            this.parseAssignableListItemTypes(o2, e4);
            const l2 = this.parseMaybeDefault(o2.loc.start, o2);
            if (i2 || a2 || s2) {
              const e5 = this.startNodeAt(n3);
              return t3.length && (e5.decorators = t3), i2 && (e5.accessibility = i2), a2 && (e5.readonly = a2), s2 && (e5.override = s2), "Identifier" !== l2.type && "AssignmentPattern" !== l2.type && this.raise(Pt.UnsupportedParameterPropertyKind, { at: e5 }), e5.parameter = l2, this.finishNode(e5, "TSParameterProperty");
            }
            return t3.length && (o2.decorators = t3), l2;
          }
          isSimpleParameter(e4) {
            return "TSParameterProperty" === e4.type && super.isSimpleParameter(e4.parameter) || super.isSimpleParameter(e4);
          }
          tsDisallowOptionalPattern(e4) {
            for (const t3 of e4.params) "Identifier" !== t3.type && t3.optional && !this.state.isAmbientContext && this.raise(Pt.PatternIsOptional, { at: t3 });
          }
          setArrowFunctionParameters(e4, t3, n3) {
            super.setArrowFunctionParameters(e4, t3, n3), this.tsDisallowOptionalPattern(e4);
          }
          parseFunctionBodyAndFinish(e4, t3, n3 = false) {
            this.match(14) && (e4.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
            const r3 = "FunctionDeclaration" === t3 ? "TSDeclareFunction" : "ClassMethod" === t3 || "ClassPrivateMethod" === t3 ? "TSDeclareMethod" : void 0;
            return r3 && !this.match(5) && this.isLineTerminator() ? this.finishNode(e4, r3) : "TSDeclareFunction" === r3 && this.state.isAmbientContext && (this.raise(Pt.DeclareFunctionHasImplementation, { at: e4 }), e4.declare) ? super.parseFunctionBodyAndFinish(e4, r3, n3) : (this.tsDisallowOptionalPattern(e4), super.parseFunctionBodyAndFinish(e4, t3, n3));
          }
          registerFunctionStatementId(e4) {
            !e4.body && e4.id ? this.checkIdentifier(e4.id, 1024) : super.registerFunctionStatementId(e4);
          }
          tsCheckForInvalidTypeCasts(e4) {
            e4.forEach((e5) => {
              "TSTypeCastExpression" === (null == e5 ? void 0 : e5.type) && this.raise(Pt.UnexpectedTypeAnnotation, { at: e5.typeAnnotation });
            });
          }
          toReferencedList(e4, t3) {
            return this.tsCheckForInvalidTypeCasts(e4), e4;
          }
          parseArrayLike(e4, t3, n3, r3) {
            const i2 = super.parseArrayLike(e4, t3, n3, r3);
            return "ArrayExpression" === i2.type && this.tsCheckForInvalidTypeCasts(i2.elements), i2;
          }
          parseSubscript(e4, t3, n3, r3) {
            if (!this.hasPrecedingLineBreak() && this.match(35)) {
              this.state.canStartJSXElement = false, this.next();
              const n4 = this.startNodeAt(t3);
              return n4.expression = e4, this.finishNode(n4, "TSNonNullExpression");
            }
            let i2 = false;
            if (this.match(18) && 60 === this.lookaheadCharCode()) {
              if (n3) return r3.stop = true, e4;
              r3.optionalChainMember = i2 = true, this.next();
            }
            if (this.match(47) || this.match(51)) {
              let s2;
              const a2 = this.tsTryParseAndCatch(() => {
                if (!n3 && this.atPossibleAsyncArrow(e4)) {
                  const e5 = this.tsTryParseGenericAsyncArrowFunction(t3);
                  if (e5) return e5;
                }
                const a3 = this.tsParseTypeArgumentsInExpression();
                if (!a3) return;
                if (i2 && !this.match(10)) return void (s2 = this.state.curPosition());
                if (z(this.state.type)) {
                  const n4 = super.parseTaggedTemplateExpression(e4, t3, r3);
                  return n4.typeParameters = a3, n4;
                }
                if (!n3 && this.eat(10)) {
                  const n4 = this.startNodeAt(t3);
                  return n4.callee = e4, n4.arguments = this.parseCallExpressionArguments(11, false), this.tsCheckForInvalidTypeCasts(n4.arguments), n4.typeParameters = a3, r3.optionalChainMember && (n4.optional = i2), this.finishCallExpression(n4, r3.optionalChainMember);
                }
                const o2 = this.state.type;
                if (48 === o2 || 52 === o2 || 10 !== o2 && q(o2) && !this.hasPrecedingLineBreak()) return;
                const l2 = this.startNodeAt(t3);
                return l2.expression = e4, l2.typeParameters = a3, this.finishNode(l2, "TSInstantiationExpression");
              });
              if (s2 && this.unexpected(s2, 10), a2) return "TSInstantiationExpression" === a2.type && (this.match(16) || this.match(18) && 40 !== this.lookaheadCharCode()) && this.raise(Pt.InvalidPropertyAccessAfterInstantiationExpression, { at: this.state.startLoc }), a2;
            }
            return super.parseSubscript(e4, t3, n3, r3);
          }
          parseNewCallee(e4) {
            var t3;
            super.parseNewCallee(e4);
            const { callee: n3 } = e4;
            "TSInstantiationExpression" !== n3.type || null != (t3 = n3.extra) && t3.parenthesized || (e4.typeParameters = n3.typeParameters, e4.callee = n3.expression);
          }
          parseExprOp(e4, t3, n3) {
            let r3;
            if (G(58) > n3 && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (r3 = this.isContextual(118)))) {
              const i2 = this.startNodeAt(t3);
              return i2.expression = e4, i2.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (r3 && this.raise(g.UnexpectedKeyword, { at: this.state.startLoc, keyword: "const" }), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(i2, r3 ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(i2, t3, n3);
            }
            return super.parseExprOp(e4, t3, n3);
          }
          checkReservedWord(e4, t3, n3, r3) {
            this.state.isAmbientContext || super.checkReservedWord(e4, t3, n3, r3);
          }
          checkImportReflection(e4) {
            super.checkImportReflection(e4), e4.module && "value" !== e4.importKind && this.raise(Pt.ImportReflectionHasImportType, { at: e4.specifiers[0].loc.start });
          }
          checkDuplicateExports() {
          }
          isPotentialImportPhase(e4) {
            if (super.isPotentialImportPhase(e4)) return true;
            if (this.isContextual(128)) {
              const t3 = this.lookaheadCharCode();
              return e4 ? 123 === t3 || 42 === t3 : 61 !== t3;
            }
            return !e4 && this.isContextual(87);
          }
          applyImportPhase(e4, t3, n3, r3) {
            super.applyImportPhase(e4, t3, n3, r3), t3 ? e4.exportKind = "type" === n3 ? "type" : "value" : e4.importKind = "type" === n3 || "typeof" === n3 ? n3 : "value";
          }
          parseImport(e4) {
            if (this.match(131)) return e4.importKind = "value", super.parseImport(e4);
            let t3;
            if (W(this.state.type) && 61 === this.lookaheadCharCode()) return e4.importKind = "value", this.tsParseImportEqualsDeclaration(e4);
            if (this.isContextual(128)) {
              const n3 = this.parseMaybeImportPhase(e4, false);
              if (61 === this.lookaheadCharCode()) return this.tsParseImportEqualsDeclaration(e4, n3);
              t3 = super.parseImportSpecifiersAndAfter(e4, n3);
            } else t3 = super.parseImport(e4);
            return "type" === t3.importKind && t3.specifiers.length > 1 && "ImportDefaultSpecifier" === t3.specifiers[0].type && this.raise(Pt.TypeImportCannotSpecifyDefaultAndNamed, { at: t3 }), t3;
          }
          parseExport(e4, t3) {
            if (this.match(83)) {
              this.next();
              let t4 = null;
              return this.isContextual(128) && this.isPotentialImportPhase(false) ? t4 = this.parseMaybeImportPhase(e4, false) : e4.importKind = "value", this.tsParseImportEqualsDeclaration(e4, t4, true);
            }
            if (this.eat(29)) {
              const t4 = e4;
              return t4.expression = super.parseExpression(), this.semicolon(), this.sawUnambiguousESM = true, this.finishNode(t4, "TSExportAssignment");
            }
            if (this.eatContextual(93)) {
              const t4 = e4;
              return this.expectContextual(126), t4.id = this.parseIdentifier(), this.semicolon(), this.finishNode(t4, "TSNamespaceExportDeclaration");
            }
            return super.parseExport(e4, t3);
          }
          isAbstractClass() {
            return this.isContextual(122) && 80 === this.lookahead().type;
          }
          parseExportDefaultExpression() {
            if (this.isAbstractClass()) {
              const e4 = this.startNode();
              return this.next(), e4.abstract = true, this.parseClass(e4, true, true);
            }
            if (this.match(127)) {
              const e4 = this.tsParseInterfaceDeclaration(this.startNode());
              if (e4) return e4;
            }
            return super.parseExportDefaultExpression();
          }
          parseVarStatement(e4, t3, n3 = false) {
            const { isAmbientContext: r3 } = this.state, i2 = super.parseVarStatement(e4, t3, n3 || r3);
            if (!r3) return i2;
            for (const { id: e5, init: n4 } of i2.declarations) n4 && ("const" !== t3 || e5.typeAnnotation ? this.raise(Pt.InitializerNotAllowedInAmbientContext, { at: n4 }) : vt(n4, this.hasPlugin("estree")) || this.raise(Pt.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, { at: n4 }));
            return i2;
          }
          parseStatementContent(e4, t3) {
            if (this.match(75) && this.isLookaheadContextual("enum")) {
              const e5 = this.startNode();
              return this.expect(75), this.tsParseEnumDeclaration(e5, { const: true });
            }
            if (this.isContextual(124)) return this.tsParseEnumDeclaration(this.startNode());
            if (this.isContextual(127)) {
              const e5 = this.tsParseInterfaceDeclaration(this.startNode());
              if (e5) return e5;
            }
            return super.parseStatementContent(e4, t3);
          }
          parseAccessModifier() {
            return this.tsParseModifier(["public", "protected", "private"]);
          }
          tsHasSomeModifiers(e4, t3) {
            return t3.some((t4) => xt(t4) ? e4.accessibility === t4 : !!e4[t4]);
          }
          tsIsStartOfStaticBlocks() {
            return this.isContextual(104) && 123 === this.lookaheadCharCode();
          }
          parseClassMember(e4, t3, n3) {
            const r3 = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
            this.tsParseModifiers({ allowedModifiers: r3, disallowedModifiers: ["in", "out"], stopOnStartOfClassStaticBlock: true, errorTemplate: Pt.InvalidModifierOnTypeParameterPositions }, t3);
            const i2 = () => {
              this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(t3, r3) && this.raise(Pt.StaticBlockCannotHaveModifier, { at: this.state.curPosition() }), super.parseClassStaticBlock(e4, t3)) : this.parseClassMemberWithIsStatic(e4, t3, n3, !!t3.static);
            };
            t3.declare ? this.tsInAmbientContext(i2) : i2();
          }
          parseClassMemberWithIsStatic(e4, t3, n3, r3) {
            const i2 = this.tsTryParseIndexSignature(t3);
            if (i2) return e4.body.push(i2), t3.abstract && this.raise(Pt.IndexSignatureHasAbstract, { at: t3 }), t3.accessibility && this.raise(Pt.IndexSignatureHasAccessibility, { at: t3, modifier: t3.accessibility }), t3.declare && this.raise(Pt.IndexSignatureHasDeclare, { at: t3 }), void (t3.override && this.raise(Pt.IndexSignatureHasOverride, { at: t3 }));
            !this.state.inAbstractClass && t3.abstract && this.raise(Pt.NonAbstractClassHasAbstractMethod, { at: t3 }), t3.override && (n3.hadSuperClass || this.raise(Pt.OverrideNotInSubClass, { at: t3 })), super.parseClassMemberWithIsStatic(e4, t3, n3, r3);
          }
          parsePostMemberNameModifiers(e4) {
            this.eat(17) && (e4.optional = true), e4.readonly && this.match(10) && this.raise(Pt.ClassMethodHasReadonly, { at: e4 }), e4.declare && this.match(10) && this.raise(Pt.ClassMethodHasDeclare, { at: e4 });
          }
          parseExpressionStatement(e4, t3, n3) {
            return ("Identifier" === t3.type ? this.tsParseExpressionStatement(e4, t3, n3) : void 0) || super.parseExpressionStatement(e4, t3, n3);
          }
          shouldParseExportDeclaration() {
            return !!this.tsIsDeclarationStart() || super.shouldParseExportDeclaration();
          }
          parseConditional(e4, t3, n3) {
            if (!this.state.maybeInArrowParameters || !this.match(17)) return super.parseConditional(e4, t3, n3);
            const r3 = this.tryParse(() => super.parseConditional(e4, t3));
            return r3.node ? (r3.error && (this.state = r3.failState), r3.node) : (r3.error && super.setOptionalParametersError(n3, r3.error), e4);
          }
          parseParenItem(e4, t3) {
            if (e4 = super.parseParenItem(e4, t3), this.eat(17) && (e4.optional = true, this.resetEndLocation(e4)), this.match(14)) {
              const n3 = this.startNodeAt(t3);
              return n3.expression = e4, n3.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(n3, "TSTypeCastExpression");
            }
            return e4;
          }
          parseExportDeclaration(e4) {
            if (!this.state.isAmbientContext && this.isContextual(123)) return this.tsInAmbientContext(() => this.parseExportDeclaration(e4));
            const t3 = this.state.startLoc, n3 = this.eatContextual(123);
            if (n3 && (this.isContextual(123) || !this.shouldParseExportDeclaration())) throw this.raise(Pt.ExpectedAmbientAfterExportDeclare, { at: this.state.startLoc });
            const r3 = W(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(e4);
            return r3 ? (("TSInterfaceDeclaration" === r3.type || "TSTypeAliasDeclaration" === r3.type || n3) && (e4.exportKind = "type"), n3 && (this.resetStartLocation(r3, t3), r3.declare = true), r3) : null;
          }
          parseClassId(e4, t3, n3, r3) {
            if ((!t3 || n3) && this.isContextual(111)) return;
            super.parseClassId(e4, t3, n3, e4.declare ? 1024 : 8331);
            const i2 = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
            i2 && (e4.typeParameters = i2);
          }
          parseClassPropertyAnnotation(e4) {
            e4.optional || (this.eat(35) ? e4.definite = true : this.eat(17) && (e4.optional = true));
            const t3 = this.tsTryParseTypeAnnotation();
            t3 && (e4.typeAnnotation = t3);
          }
          parseClassProperty(e4) {
            if (this.parseClassPropertyAnnotation(e4), this.state.isAmbientContext && (!e4.readonly || e4.typeAnnotation) && this.match(29) && this.raise(Pt.DeclareClassFieldHasInitializer, { at: this.state.startLoc }), e4.abstract && this.match(29)) {
              const { key: t3 } = e4;
              this.raise(Pt.AbstractPropertyHasInitializer, { at: this.state.startLoc, propertyName: "Identifier" !== t3.type || e4.computed ? `[${this.input.slice(t3.start, t3.end)}]` : t3.name });
            }
            return super.parseClassProperty(e4);
          }
          parseClassPrivateProperty(e4) {
            return e4.abstract && this.raise(Pt.PrivateElementHasAbstract, { at: e4 }), e4.accessibility && this.raise(Pt.PrivateElementHasAccessibility, { at: e4, modifier: e4.accessibility }), this.parseClassPropertyAnnotation(e4), super.parseClassPrivateProperty(e4);
          }
          parseClassAccessorProperty(e4) {
            return this.parseClassPropertyAnnotation(e4), e4.optional && this.raise(Pt.AccessorCannotBeOptional, { at: e4 }), super.parseClassAccessorProperty(e4);
          }
          pushClassMethod(e4, t3, n3, r3, i2, s2) {
            const a2 = this.tsTryParseTypeParameters(this.tsParseConstModifier);
            a2 && i2 && this.raise(Pt.ConstructorHasTypeParameters, { at: a2 });
            const { declare: o2 = false, kind: l2 } = t3;
            !o2 || "get" !== l2 && "set" !== l2 || this.raise(Pt.DeclareAccessor, { at: t3, kind: l2 }), a2 && (t3.typeParameters = a2), super.pushClassMethod(e4, t3, n3, r3, i2, s2);
          }
          pushClassPrivateMethod(e4, t3, n3, r3) {
            const i2 = this.tsTryParseTypeParameters(this.tsParseConstModifier);
            i2 && (t3.typeParameters = i2), super.pushClassPrivateMethod(e4, t3, n3, r3);
          }
          declareClassPrivateMethodInScope(e4, t3) {
            "TSDeclareMethod" !== e4.type && ("MethodDefinition" !== e4.type || e4.value.body) && super.declareClassPrivateMethodInScope(e4, t3);
          }
          parseClassSuper(e4) {
            super.parseClassSuper(e4), e4.superClass && (this.match(47) || this.match(51)) && (e4.superTypeParameters = this.tsParseTypeArgumentsInExpression()), this.eatContextual(111) && (e4.implements = this.tsParseHeritageClause("implements"));
          }
          parseObjPropValue(e4, t3, n3, r3, i2, s2, a2) {
            const o2 = this.tsTryParseTypeParameters(this.tsParseConstModifier);
            return o2 && (e4.typeParameters = o2), super.parseObjPropValue(e4, t3, n3, r3, i2, s2, a2);
          }
          parseFunctionParams(e4, t3) {
            const n3 = this.tsTryParseTypeParameters(this.tsParseConstModifier);
            n3 && (e4.typeParameters = n3), super.parseFunctionParams(e4, t3);
          }
          parseVarId(e4, t3) {
            super.parseVarId(e4, t3), "Identifier" === e4.id.type && !this.hasPrecedingLineBreak() && this.eat(35) && (e4.definite = true);
            const n3 = this.tsTryParseTypeAnnotation();
            n3 && (e4.id.typeAnnotation = n3, this.resetEndLocation(e4.id));
          }
          parseAsyncArrowFromCallExpression(e4, t3) {
            return this.match(14) && (e4.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(e4, t3);
          }
          parseMaybeAssign(e4, t3) {
            var n3, r3, i2, s2, a2;
            let o2, l2, c2, u2;
            if (this.hasPlugin("jsx") && (this.match(140) || this.match(47))) {
              if (o2 = this.state.clone(), l2 = this.tryParse(() => super.parseMaybeAssign(e4, t3), o2), !l2.error) return l2.node;
              const { context: n4 } = this.state, r4 = n4[n4.length - 1];
              r4 !== x.j_oTag && r4 !== x.j_expr || n4.pop();
            }
            if (!(null != (n3 = l2) && n3.error || this.match(47))) return super.parseMaybeAssign(e4, t3);
            o2 && o2 !== this.state || (o2 = this.state.clone());
            const p2 = this.tryParse((n4) => {
              var r4, i3;
              u2 = this.tsParseTypeParameters(this.tsParseConstModifier);
              const s3 = super.parseMaybeAssign(e4, t3);
              return ("ArrowFunctionExpression" !== s3.type || null != (r4 = s3.extra) && r4.parenthesized) && n4(), 0 !== (null == (i3 = u2) ? void 0 : i3.params.length) && this.resetStartLocationFromNode(s3, u2), s3.typeParameters = u2, s3;
            }, o2);
            if (!p2.error && !p2.aborted) return u2 && this.reportReservedArrowTypeParam(u2), p2.node;
            if (!l2 && (St(!this.hasPlugin("jsx")), c2 = this.tryParse(() => super.parseMaybeAssign(e4, t3), o2), !c2.error)) return c2.node;
            if (null != (r3 = l2) && r3.node) return this.state = l2.failState, l2.node;
            if (p2.node) return this.state = p2.failState, u2 && this.reportReservedArrowTypeParam(u2), p2.node;
            if (null != (i2 = c2) && i2.node) return this.state = c2.failState, c2.node;
            throw (null == (s2 = l2) ? void 0 : s2.error) || p2.error || (null == (a2 = c2) ? void 0 : a2.error);
          }
          reportReservedArrowTypeParam(e4) {
            var t3;
            1 !== e4.params.length || e4.params[0].constraint || null != (t3 = e4.extra) && t3.trailingComma || !this.getPluginOption("typescript", "disallowAmbiguousJSXLike") || this.raise(Pt.ReservedArrowTypeParam, { at: e4 });
          }
          parseMaybeUnary(e4, t3) {
            return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(e4, t3);
          }
          parseArrow(e4) {
            if (this.match(14)) {
              const t3 = this.tryParse((e5) => {
                const t4 = this.tsParseTypeOrTypePredicateAnnotation(14);
                return !this.canInsertSemicolon() && this.match(19) || e5(), t4;
              });
              if (t3.aborted) return;
              t3.thrown || (t3.error && (this.state = t3.failState), e4.returnType = t3.node);
            }
            return super.parseArrow(e4);
          }
          parseAssignableListItemTypes(e4, t3) {
            if (!(2 & t3)) return e4;
            this.eat(17) && (e4.optional = true);
            const n3 = this.tsTryParseTypeAnnotation();
            return n3 && (e4.typeAnnotation = n3), this.resetEndLocation(e4), e4;
          }
          isAssignable(e4, t3) {
            switch (e4.type) {
              case "TSTypeCastExpression":
                return this.isAssignable(e4.expression, t3);
              case "TSParameterProperty":
                return true;
              default:
                return super.isAssignable(e4, t3);
            }
          }
          toAssignable(e4, t3 = false) {
            switch (e4.type) {
              case "ParenthesizedExpression":
                this.toAssignableParenthesizedExpression(e4, t3);
                break;
              case "TSAsExpression":
              case "TSSatisfiesExpression":
              case "TSNonNullExpression":
              case "TSTypeAssertion":
                t3 ? this.expressionScope.recordArrowParameterBindingError(Pt.UnexpectedTypeCastInParameter, { at: e4 }) : this.raise(Pt.UnexpectedTypeCastInParameter, { at: e4 }), this.toAssignable(e4.expression, t3);
                break;
              case "AssignmentExpression":
                t3 || "TSTypeCastExpression" !== e4.left.type || (e4.left = this.typeCastToParameter(e4.left));
              default:
                super.toAssignable(e4, t3);
            }
          }
          toAssignableParenthesizedExpression(e4, t3) {
            switch (e4.expression.type) {
              case "TSAsExpression":
              case "TSSatisfiesExpression":
              case "TSNonNullExpression":
              case "TSTypeAssertion":
              case "ParenthesizedExpression":
                this.toAssignable(e4.expression, t3);
                break;
              default:
                super.toAssignable(e4, t3);
            }
          }
          checkToRestConversion(e4, t3) {
            switch (e4.type) {
              case "TSAsExpression":
              case "TSSatisfiesExpression":
              case "TSTypeAssertion":
              case "TSNonNullExpression":
                this.checkToRestConversion(e4.expression, false);
                break;
              default:
                super.checkToRestConversion(e4, t3);
            }
          }
          isValidLVal(e4, t3, n3) {
            return r3 = { TSTypeCastExpression: true, TSParameterProperty: "parameter", TSNonNullExpression: "expression", TSAsExpression: (64 !== n3 || !t3) && ["expression", true], TSSatisfiesExpression: (64 !== n3 || !t3) && ["expression", true], TSTypeAssertion: (64 !== n3 || !t3) && ["expression", true] }, i2 = e4, Object.hasOwnProperty.call(r3, i2) && r3[i2] || super.isValidLVal(e4, t3, n3);
            var r3, i2;
          }
          parseBindingAtom() {
            return 78 === this.state.type ? this.parseIdentifier(true) : super.parseBindingAtom();
          }
          parseMaybeDecoratorArguments(e4) {
            if (this.match(47) || this.match(51)) {
              const t3 = this.tsParseTypeArgumentsInExpression();
              if (this.match(10)) {
                const n3 = super.parseMaybeDecoratorArguments(e4);
                return n3.typeParameters = t3, n3;
              }
              this.unexpected(null, 10);
            }
            return super.parseMaybeDecoratorArguments(e4);
          }
          checkCommaAfterRest(e4) {
            return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === e4 ? (this.next(), false) : super.checkCommaAfterRest(e4);
          }
          isClassMethod() {
            return this.match(47) || super.isClassMethod();
          }
          isClassProperty() {
            return this.match(35) || this.match(14) || super.isClassProperty();
          }
          parseMaybeDefault(e4, t3) {
            const n3 = super.parseMaybeDefault(e4, t3);
            return "AssignmentPattern" === n3.type && n3.typeAnnotation && n3.right.start < n3.typeAnnotation.start && this.raise(Pt.TypeAnnotationAfterAssign, { at: n3.typeAnnotation }), n3;
          }
          getTokenFromCode(e4) {
            if (this.state.inType) {
              if (62 === e4) return void this.finishOp(48, 1);
              if (60 === e4) return void this.finishOp(47, 1);
            }
            super.getTokenFromCode(e4);
          }
          reScan_lt_gt() {
            const { type: e4 } = this.state;
            47 === e4 ? (this.state.pos -= 1, this.readToken_lt()) : 48 === e4 && (this.state.pos -= 1, this.readToken_gt());
          }
          reScan_lt() {
            const { type: e4 } = this.state;
            return 51 === e4 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : e4;
          }
          toAssignableList(e4, t3, n3) {
            for (let t4 = 0; t4 < e4.length; t4++) {
              const n4 = e4[t4];
              "TSTypeCastExpression" === (null == n4 ? void 0 : n4.type) && (e4[t4] = this.typeCastToParameter(n4));
            }
            super.toAssignableList(e4, t3, n3);
          }
          typeCastToParameter(e4) {
            return e4.expression.typeAnnotation = e4.typeAnnotation, this.resetEndLocation(e4.expression, e4.typeAnnotation.loc.end), e4.expression;
          }
          shouldParseArrow(e4) {
            return this.match(14) ? e4.every((e5) => this.isAssignable(e5, true)) : super.shouldParseArrow(e4);
          }
          shouldParseAsyncArrow() {
            return this.match(14) || super.shouldParseAsyncArrow();
          }
          canHaveLeadingDecorator() {
            return super.canHaveLeadingDecorator() || this.isAbstractClass();
          }
          jsxParseOpeningElementAfterName(e4) {
            if (this.match(47) || this.match(51)) {
              const t3 = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
              t3 && (e4.typeParameters = t3);
            }
            return super.jsxParseOpeningElementAfterName(e4);
          }
          getGetterSetterExpectedParamCount(e4) {
            const t3 = super.getGetterSetterExpectedParamCount(e4), n3 = this.getObjectOrClassMethodParams(e4)[0];
            return n3 && this.isThisParam(n3) ? t3 + 1 : t3;
          }
          parseCatchClauseParam() {
            const e4 = super.parseCatchClauseParam(), t3 = this.tsTryParseTypeAnnotation();
            return t3 && (e4.typeAnnotation = t3, this.resetEndLocation(e4)), e4;
          }
          tsInAmbientContext(e4) {
            const t3 = this.state.isAmbientContext;
            this.state.isAmbientContext = true;
            try {
              return e4();
            } finally {
              this.state.isAmbientContext = t3;
            }
          }
          parseClass(e4, t3, n3) {
            const r3 = this.state.inAbstractClass;
            this.state.inAbstractClass = !!e4.abstract;
            try {
              return super.parseClass(e4, t3, n3);
            } finally {
              this.state.inAbstractClass = r3;
            }
          }
          tsParseAbstractDeclaration(e4, t3) {
            if (this.match(80)) return e4.abstract = true, this.maybeTakeDecorators(t3, this.parseClass(e4, true, false));
            if (this.isContextual(127)) {
              if (!this.hasFollowingLineBreak()) return e4.abstract = true, this.raise(Pt.NonClassMethodPropertyHasAbstractModifer, { at: e4 }), this.tsParseInterfaceDeclaration(e4);
            } else this.unexpected(null, 80);
          }
          parseMethod(e4, t3, n3, r3, i2, s2, a2) {
            const o2 = super.parseMethod(e4, t3, n3, r3, i2, s2, a2);
            if (o2.abstract && (this.hasPlugin("estree") ? o2.value.body : o2.body)) {
              const { key: e5 } = o2;
              this.raise(Pt.AbstractMethodHasImplementation, { at: o2, methodName: "Identifier" !== e5.type || o2.computed ? `[${this.input.slice(e5.start, e5.end)}]` : e5.name });
            }
            return o2;
          }
          tsParseTypeParameterName() {
            return this.parseIdentifier().name;
          }
          shouldParseAsAmbientContext() {
            return !!this.getPluginOption("typescript", "dts");
          }
          parse() {
            return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.parse();
          }
          getExpression() {
            return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.getExpression();
          }
          parseExportSpecifier(e4, t3, n3, r3) {
            return !t3 && r3 ? (this.parseTypeOnlyImportExportSpecifier(e4, false, n3), this.finishNode(e4, "ExportSpecifier")) : (e4.exportKind = "value", super.parseExportSpecifier(e4, t3, n3, r3));
          }
          parseImportSpecifier(e4, t3, n3, r3, i2) {
            return !t3 && r3 ? (this.parseTypeOnlyImportExportSpecifier(e4, true, n3), this.finishNode(e4, "ImportSpecifier")) : (e4.importKind = "value", super.parseImportSpecifier(e4, t3, n3, r3, n3 ? 4098 : 4096));
          }
          parseTypeOnlyImportExportSpecifier(e4, t3, n3) {
            const r3 = t3 ? "imported" : "local", i2 = t3 ? "local" : "exported";
            let s2, a2 = e4[r3], o2 = false, l2 = true;
            const c2 = a2.loc.start;
            if (this.isContextual(93)) {
              const e5 = this.parseIdentifier();
              if (this.isContextual(93)) {
                const n4 = this.parseIdentifier();
                X(this.state.type) ? (o2 = true, a2 = e5, s2 = t3 ? this.parseIdentifier() : this.parseModuleExportName(), l2 = false) : (s2 = n4, l2 = false);
              } else X(this.state.type) ? (l2 = false, s2 = t3 ? this.parseIdentifier() : this.parseModuleExportName()) : (o2 = true, a2 = e5);
            } else X(this.state.type) && (o2 = true, t3 ? (a2 = this.parseIdentifier(true), this.isContextual(93) || this.checkReservedWord(a2.name, a2.loc.start, true, true)) : a2 = this.parseModuleExportName());
            o2 && n3 && this.raise(t3 ? Pt.TypeModifierIsUsedInTypeImports : Pt.TypeModifierIsUsedInTypeExports, { at: c2 }), e4[r3] = a2, e4[i2] = s2, e4[t3 ? "importKind" : "exportKind"] = o2 ? "type" : "value", l2 && this.eatContextual(93) && (e4[i2] = t3 ? this.parseIdentifier() : this.parseModuleExportName()), e4[i2] || (e4[i2] = at(e4[r3])), t3 && this.checkIdentifier(e4[i2], o2 ? 4098 : 4096);
          }
        }, v8intrinsic: (e3) => class extends e3 {
          parseV8Intrinsic() {
            if (this.match(54)) {
              const e4 = this.state.startLoc, t3 = this.startNode();
              if (this.next(), W(this.state.type)) {
                const e5 = this.parseIdentifierName(), n3 = this.createIdentifier(t3, e5);
                if (n3.type = "V8IntrinsicIdentifier", this.match(10)) return n3;
              }
              this.unexpected(e4);
            }
          }
          parseExprAtom(e4) {
            return this.parseV8Intrinsic() || super.parseExprAtom(e4);
          }
        }, placeholders: (e3) => class extends e3 {
          parsePlaceholder(e4) {
            if (this.match(142)) {
              const t3 = this.startNode();
              return this.next(), this.assertNoSpace(), t3.name = super.parseIdentifier(true), this.assertNoSpace(), this.expect(142), this.finishPlaceholder(t3, e4);
            }
          }
          finishPlaceholder(e4, t3) {
            const n3 = !(!e4.expectedNode || "Placeholder" !== e4.type);
            return e4.expectedNode = t3, n3 ? e4 : this.finishNode(e4, "Placeholder");
          }
          getTokenFromCode(e4) {
            37 === e4 && 37 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(142, 2) : super.getTokenFromCode(e4);
          }
          parseExprAtom(e4) {
            return this.parsePlaceholder("Expression") || super.parseExprAtom(e4);
          }
          parseIdentifier(e4) {
            return this.parsePlaceholder("Identifier") || super.parseIdentifier(e4);
          }
          checkReservedWord(e4, t3, n3, r3) {
            void 0 !== e4 && super.checkReservedWord(e4, t3, n3, r3);
          }
          parseBindingAtom() {
            return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
          }
          isValidLVal(e4, t3, n3) {
            return "Placeholder" === e4 || super.isValidLVal(e4, t3, n3);
          }
          toAssignable(e4, t3) {
            e4 && "Placeholder" === e4.type && "Expression" === e4.expectedNode ? e4.expectedNode = "Pattern" : super.toAssignable(e4, t3);
          }
          chStartsBindingIdentifier(e4, t3) {
            return !!super.chStartsBindingIdentifier(e4, t3) || 142 === this.lookahead().type;
          }
          verifyBreakContinue(e4, t3) {
            e4.label && "Placeholder" === e4.label.type || super.verifyBreakContinue(e4, t3);
          }
          parseExpressionStatement(e4, t3) {
            var n3;
            if ("Placeholder" !== t3.type || null != (n3 = t3.extra) && n3.parenthesized) return super.parseExpressionStatement(e4, t3);
            if (this.match(14)) {
              const n4 = e4;
              return n4.label = this.finishPlaceholder(t3, "Identifier"), this.next(), n4.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration(), this.finishNode(n4, "LabeledStatement");
            }
            return this.semicolon(), e4.name = t3.name, this.finishPlaceholder(e4, "Statement");
          }
          parseBlock(e4, t3, n3) {
            return this.parsePlaceholder("BlockStatement") || super.parseBlock(e4, t3, n3);
          }
          parseFunctionId(e4) {
            return this.parsePlaceholder("Identifier") || super.parseFunctionId(e4);
          }
          parseClass(e4, t3, n3) {
            const r3 = t3 ? "ClassDeclaration" : "ClassExpression";
            this.next();
            const i2 = this.state.strict, s2 = this.parsePlaceholder("Identifier");
            if (s2) {
              if (!(this.match(81) || this.match(142) || this.match(5))) {
                if (n3 || !t3) return e4.id = null, e4.body = this.finishPlaceholder(s2, "ClassBody"), this.finishNode(e4, r3);
                throw this.raise(Ot.ClassNameIsRequired, { at: this.state.startLoc });
              }
              e4.id = s2;
            } else this.parseClassId(e4, t3, n3);
            return super.parseClassSuper(e4), e4.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!e4.superClass, i2), this.finishNode(e4, r3);
          }
          parseExport(e4, t3) {
            const n3 = this.parsePlaceholder("Identifier");
            if (!n3) return super.parseExport(e4, t3);
            if (!this.isContextual(97) && !this.match(12)) return e4.specifiers = [], e4.source = null, e4.declaration = this.finishPlaceholder(n3, "Declaration"), this.finishNode(e4, "ExportNamedDeclaration");
            this.expectPlugin("exportDefaultFrom");
            const r3 = this.startNode();
            return r3.exported = n3, e4.specifiers = [this.finishNode(r3, "ExportDefaultSpecifier")], super.parseExport(e4, t3);
          }
          isExportDefaultSpecifier() {
            if (this.match(65)) {
              const e4 = this.nextTokenStart();
              if (this.isUnparsedContextual(e4, "from") && this.input.startsWith($(142), this.nextTokenStartSince(e4 + 4))) return true;
            }
            return super.isExportDefaultSpecifier();
          }
          maybeParseExportDefaultSpecifier(e4, t3) {
            var n3;
            return !(null == (n3 = e4.specifiers) || !n3.length) || super.maybeParseExportDefaultSpecifier(e4, t3);
          }
          checkExport(e4) {
            const { specifiers: t3 } = e4;
            null != t3 && t3.length && (e4.specifiers = t3.filter((e5) => "Placeholder" === e5.exported.type)), super.checkExport(e4), e4.specifiers = t3;
          }
          parseImport(e4) {
            const t3 = this.parsePlaceholder("Identifier");
            if (!t3) return super.parseImport(e4);
            if (e4.specifiers = [], !this.isContextual(97) && !this.match(12)) return e4.source = this.finishPlaceholder(t3, "StringLiteral"), this.semicolon(), this.finishNode(e4, "ImportDeclaration");
            const n3 = this.startNodeAtNode(t3);
            return n3.local = t3, e4.specifiers.push(this.finishNode(n3, "ImportDefaultSpecifier")), this.eat(12) && (this.maybeParseStarImportSpecifier(e4) || this.parseNamedImportSpecifiers(e4)), this.expectContextual(97), e4.source = this.parseImportSource(), this.semicolon(), this.finishNode(e4, "ImportDeclaration");
          }
          parseImportSource() {
            return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
          }
          assertNoSpace() {
            this.state.start > this.state.lastTokEndLoc.index && this.raise(Ot.UnexpectedSpace, { at: this.state.lastTokEndLoc });
          }
        } }, Mt = Object.keys(_t), Bt = { sourceType: "script", sourceFilename: void 0, startColumn: 0, startLine: 1, allowAwaitOutsideFunction: false, allowReturnOutsideFunction: false, allowNewTargetOutsideFunction: false, allowImportExportEverywhere: false, allowSuperOutsideMethod: false, allowUndeclaredExports: false, plugins: [], strictMode: null, ranges: false, tokens: false, createParenthesizedExpressions: false, errorRecovery: false, attachComment: true, annexB: true };
        class jt extends Et {
          checkProto(e3, t3, n3, r3) {
            if ("SpreadElement" === e3.type || this.isObjectMethod(e3) || e3.computed || e3.shorthand) return;
            const i2 = e3.key;
            if ("__proto__" === ("Identifier" === i2.type ? i2.name : i2.value)) {
              if (t3) return void this.raise(g.RecordNoProto, { at: i2 });
              n3.used && (r3 ? null === r3.doubleProtoLoc && (r3.doubleProtoLoc = i2.loc.start) : this.raise(g.DuplicateProto, { at: i2 })), n3.used = true;
            }
          }
          shouldExitDescending(e3, t3) {
            return "ArrowFunctionExpression" === e3.type && e3.start === t3;
          }
          getExpression() {
            this.enterInitialScopes(), this.nextToken();
            const e3 = this.parseExpression();
            return this.match(137) || this.unexpected(), this.finalizeRemainingComments(), e3.comments = this.state.comments, e3.errors = this.state.errors, this.options.tokens && (e3.tokens = this.tokens), e3;
          }
          parseExpression(e3, t3) {
            return e3 ? this.disallowInAnd(() => this.parseExpressionBase(t3)) : this.allowInAnd(() => this.parseExpressionBase(t3));
          }
          parseExpressionBase(e3) {
            const t3 = this.state.startLoc, n3 = this.parseMaybeAssign(e3);
            if (this.match(12)) {
              const r3 = this.startNodeAt(t3);
              for (r3.expressions = [n3]; this.eat(12); ) r3.expressions.push(this.parseMaybeAssign(e3));
              return this.toReferencedList(r3.expressions), this.finishNode(r3, "SequenceExpression");
            }
            return n3;
          }
          parseMaybeAssignDisallowIn(e3, t3) {
            return this.disallowInAnd(() => this.parseMaybeAssign(e3, t3));
          }
          parseMaybeAssignAllowIn(e3, t3) {
            return this.allowInAnd(() => this.parseMaybeAssign(e3, t3));
          }
          setOptionalParametersError(e3, t3) {
            var n3;
            e3.optionalParametersLoc = null != (n3 = null == t3 ? void 0 : t3.loc) ? n3 : this.state.startLoc;
          }
          parseMaybeAssign(e3, t3) {
            const n3 = this.state.startLoc;
            if (this.isContextual(106) && this.prodParam.hasYield) {
              let e4 = this.parseYield();
              return t3 && (e4 = t3.call(this, e4, n3)), e4;
            }
            let r3;
            e3 ? r3 = false : (e3 = new rt(), r3 = true);
            const { type: i2 } = this.state;
            (10 === i2 || W(i2)) && (this.state.potentialArrowAt = this.state.start);
            let s2 = this.parseMaybeConditional(e3);
            if (t3 && (s2 = t3.call(this, s2, n3)), (a2 = this.state.type) >= 29 && a2 <= 33) {
              const t4 = this.startNodeAt(n3), r4 = this.state.value;
              if (t4.operator = r4, this.match(29)) {
                this.toAssignable(s2, true), t4.left = s2;
                const r5 = n3.index;
                null != e3.doubleProtoLoc && e3.doubleProtoLoc.index >= r5 && (e3.doubleProtoLoc = null), null != e3.shorthandAssignLoc && e3.shorthandAssignLoc.index >= r5 && (e3.shorthandAssignLoc = null), null != e3.privateKeyLoc && e3.privateKeyLoc.index >= r5 && (this.checkDestructuringPrivate(e3), e3.privateKeyLoc = null);
              } else t4.left = s2;
              return this.next(), t4.right = this.parseMaybeAssign(), this.checkLVal(s2, { in: this.finishNode(t4, "AssignmentExpression") }), t4;
            }
            var a2;
            return r3 && this.checkExpressionErrors(e3, true), s2;
          }
          parseMaybeConditional(e3) {
            const t3 = this.state.startLoc, n3 = this.state.potentialArrowAt, r3 = this.parseExprOps(e3);
            return this.shouldExitDescending(r3, n3) ? r3 : this.parseConditional(r3, t3, e3);
          }
          parseConditional(e3, t3, n3) {
            if (this.eat(17)) {
              const n4 = this.startNodeAt(t3);
              return n4.test = e3, n4.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), n4.alternate = this.parseMaybeAssign(), this.finishNode(n4, "ConditionalExpression");
            }
            return e3;
          }
          parseMaybeUnaryOrPrivate(e3) {
            return this.match(136) ? this.parsePrivateName() : this.parseMaybeUnary(e3);
          }
          parseExprOps(e3) {
            const t3 = this.state.startLoc, n3 = this.state.potentialArrowAt, r3 = this.parseMaybeUnaryOrPrivate(e3);
            return this.shouldExitDescending(r3, n3) ? r3 : this.parseExprOp(r3, t3, -1);
          }
          parseExprOp(e3, t3, n3) {
            if (this.isPrivateName(e3)) {
              const t4 = this.getPrivateNameSV(e3);
              (n3 >= G(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(g.PrivateInExpectedIn, { at: e3, identifierName: t4 }), this.classScope.usePrivateName(t4, e3.loc.start);
            }
            const r3 = this.state.type;
            if ((i2 = r3) >= 39 && i2 <= 59 && (this.prodParam.hasIn || !this.match(58))) {
              let i3 = G(r3);
              if (i3 > n3) {
                if (39 === r3) {
                  if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody) return e3;
                  this.checkPipelineAtInfixOperator(e3, t3);
                }
                const s2 = this.startNodeAt(t3);
                s2.left = e3, s2.operator = this.state.value;
                const a2 = 41 === r3 || 42 === r3, o2 = 40 === r3;
                if (o2 && (i3 = G(42)), this.next(), 39 === r3 && this.hasPlugin(["pipelineOperator", { proposal: "minimal" }]) && 96 === this.state.type && this.prodParam.hasAwait) throw this.raise(g.UnexpectedAwaitAfterPipelineBody, { at: this.state.startLoc });
                s2.right = this.parseExprOpRightExpr(r3, i3);
                const l2 = this.finishNode(s2, a2 || o2 ? "LogicalExpression" : "BinaryExpression"), c2 = this.state.type;
                if (o2 && (41 === c2 || 42 === c2) || a2 && 40 === c2) throw this.raise(g.MixingCoalesceWithLogical, { at: this.state.startLoc });
                return this.parseExprOp(l2, t3, n3);
              }
            }
            var i2;
            return e3;
          }
          parseExprOpRightExpr(e3, t3) {
            const n3 = this.state.startLoc;
            if (39 === e3) switch (this.getPluginOption("pipelineOperator", "proposal")) {
              case "hack":
                return this.withTopicBindingContext(() => this.parseHackPipeBody());
              case "smart":
                return this.withTopicBindingContext(() => {
                  if (this.prodParam.hasYield && this.isContextual(106)) throw this.raise(g.PipeBodyIsTighter, { at: this.state.startLoc });
                  return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(e3, t3), n3);
                });
              case "fsharp":
                return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(t3));
            }
            return this.parseExprOpBaseRightExpr(e3, t3);
          }
          parseExprOpBaseRightExpr(e3, t3) {
            const n3 = this.state.startLoc;
            return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), n3, 57 === e3 ? t3 - 1 : t3);
          }
          parseHackPipeBody() {
            var e3;
            const { startLoc: t3 } = this.state, n3 = this.parseMaybeAssign();
            return !p.has(n3.type) || null != (e3 = n3.extra) && e3.parenthesized || this.raise(g.PipeUnparenthesizedBody, { at: t3, type: n3.type }), this.topicReferenceWasUsedInCurrentContext() || this.raise(g.PipeTopicUnused, { at: t3 }), n3;
          }
          checkExponentialAfterUnary(e3) {
            this.match(57) && this.raise(g.UnexpectedTokenUnaryExponentiation, { at: e3.argument });
          }
          parseMaybeUnary(e3, t3) {
            const n3 = this.state.startLoc, r3 = this.isContextual(96);
            if (r3 && this.isAwaitAllowed()) {
              this.next();
              const e4 = this.parseAwait(n3);
              return t3 || this.checkExponentialAfterUnary(e4), e4;
            }
            const i2 = this.match(34), s2 = this.startNode();
            if (a2 = this.state.type, R[a2]) {
              s2.operator = this.state.value, s2.prefix = true, this.match(72) && this.expectPlugin("throwExpressions");
              const n4 = this.match(89);
              if (this.next(), s2.argument = this.parseMaybeUnary(null, true), this.checkExpressionErrors(e3, true), this.state.strict && n4) {
                const e4 = s2.argument;
                "Identifier" === e4.type ? this.raise(g.StrictDelete, { at: s2 }) : this.hasPropertyAsPrivateName(e4) && this.raise(g.DeletePrivateField, { at: s2 });
              }
              if (!i2) return t3 || this.checkExponentialAfterUnary(s2), this.finishNode(s2, "UnaryExpression");
            }
            var a2;
            const o2 = this.parseUpdate(s2, i2, e3);
            if (r3) {
              const { type: e4 } = this.state;
              if ((this.hasPlugin("v8intrinsic") ? q(e4) : q(e4) && !this.match(54)) && !this.isAmbiguousAwait()) return this.raiseOverwrite(g.AwaitNotInAsyncContext, { at: n3 }), this.parseAwait(n3);
            }
            return o2;
          }
          parseUpdate(e3, t3, n3) {
            if (t3) {
              const t4 = e3;
              return this.checkLVal(t4.argument, { in: this.finishNode(t4, "UpdateExpression") }), e3;
            }
            const r3 = this.state.startLoc;
            let i2 = this.parseExprSubscripts(n3);
            if (this.checkExpressionErrors(n3, false)) return i2;
            for (; 34 === this.state.type && !this.canInsertSemicolon(); ) {
              const e4 = this.startNodeAt(r3);
              e4.operator = this.state.value, e4.prefix = false, e4.argument = i2, this.next(), this.checkLVal(i2, { in: i2 = this.finishNode(e4, "UpdateExpression") });
            }
            return i2;
          }
          parseExprSubscripts(e3) {
            const t3 = this.state.startLoc, n3 = this.state.potentialArrowAt, r3 = this.parseExprAtom(e3);
            return this.shouldExitDescending(r3, n3) ? r3 : this.parseSubscripts(r3, t3);
          }
          parseSubscripts(e3, t3, n3) {
            const r3 = { optionalChainMember: false, maybeAsyncArrow: this.atPossibleAsyncArrow(e3), stop: false };
            do {
              e3 = this.parseSubscript(e3, t3, n3, r3), r3.maybeAsyncArrow = false;
            } while (!r3.stop);
            return e3;
          }
          parseSubscript(e3, t3, n3, r3) {
            const { type: i2 } = this.state;
            if (!n3 && 15 === i2) return this.parseBind(e3, t3, n3, r3);
            if (z(i2)) return this.parseTaggedTemplateExpression(e3, t3, r3);
            let s2 = false;
            if (18 === i2) {
              if (n3 && (this.raise(g.OptionalChainingNoNew, { at: this.state.startLoc }), 40 === this.lookaheadCharCode())) return r3.stop = true, e3;
              r3.optionalChainMember = s2 = true, this.next();
            }
            if (!n3 && this.match(10)) return this.parseCoverCallAndAsyncArrowHead(e3, t3, r3, s2);
            {
              const n4 = this.eat(0);
              return n4 || s2 || this.eat(16) ? this.parseMember(e3, t3, r3, n4, s2) : (r3.stop = true, e3);
            }
          }
          parseMember(e3, t3, n3, r3, i2) {
            const s2 = this.startNodeAt(t3);
            return s2.object = e3, s2.computed = r3, r3 ? (s2.property = this.parseExpression(), this.expect(3)) : this.match(136) ? ("Super" === e3.type && this.raise(g.SuperPrivateField, { at: t3 }), this.classScope.usePrivateName(this.state.value, this.state.startLoc), s2.property = this.parsePrivateName()) : s2.property = this.parseIdentifier(true), n3.optionalChainMember ? (s2.optional = i2, this.finishNode(s2, "OptionalMemberExpression")) : this.finishNode(s2, "MemberExpression");
          }
          parseBind(e3, t3, n3, r3) {
            const i2 = this.startNodeAt(t3);
            return i2.object = e3, this.next(), i2.callee = this.parseNoCallExpr(), r3.stop = true, this.parseSubscripts(this.finishNode(i2, "BindExpression"), t3, n3);
          }
          parseCoverCallAndAsyncArrowHead(e3, t3, n3, r3) {
            const i2 = this.state.maybeInArrowParameters;
            let s2 = null;
            this.state.maybeInArrowParameters = true, this.next();
            const a2 = this.startNodeAt(t3);
            a2.callee = e3;
            const { maybeAsyncArrow: o2, optionalChainMember: l2 } = n3;
            o2 && (this.expressionScope.enter(new ze(2)), s2 = new rt()), l2 && (a2.optional = r3), a2.arguments = r3 ? this.parseCallExpressionArguments(11) : this.parseCallExpressionArguments(11, "Import" === e3.type, "Super" !== e3.type, a2, s2);
            let c2 = this.finishCallExpression(a2, l2);
            return o2 && this.shouldParseAsyncArrow() && !r3 ? (n3.stop = true, this.checkDestructuringPrivate(s2), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), c2 = this.parseAsyncArrowFromCallExpression(this.startNodeAt(t3), c2)) : (o2 && (this.checkExpressionErrors(s2, true), this.expressionScope.exit()), this.toReferencedArguments(c2)), this.state.maybeInArrowParameters = i2, c2;
          }
          toReferencedArguments(e3, t3) {
            this.toReferencedListDeep(e3.arguments, t3);
          }
          parseTaggedTemplateExpression(e3, t3, n3) {
            const r3 = this.startNodeAt(t3);
            return r3.tag = e3, r3.quasi = this.parseTemplate(true), n3.optionalChainMember && this.raise(g.OptionalChainingNoTemplate, { at: t3 }), this.finishNode(r3, "TaggedTemplateExpression");
          }
          atPossibleAsyncArrow(e3) {
            return "Identifier" === e3.type && "async" === e3.name && this.state.lastTokEndLoc.index === e3.end && !this.canInsertSemicolon() && e3.end - e3.start == 5 && e3.start === this.state.potentialArrowAt;
          }
          expectImportAttributesPlugin() {
            this.hasPlugin("importAssertions") || this.expectPlugin("importAttributes");
          }
          finishCallExpression(e3, t3) {
            if ("Import" === e3.callee.type) if (2 === e3.arguments.length && (this.hasPlugin("moduleAttributes") || this.expectImportAttributesPlugin()), 0 === e3.arguments.length || e3.arguments.length > 2) this.raise(g.ImportCallArity, { at: e3, maxArgumentCount: this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? 2 : 1 });
            else for (const t4 of e3.arguments) "SpreadElement" === t4.type && this.raise(g.ImportCallSpreadArgument, { at: t4 });
            return this.finishNode(e3, t3 ? "OptionalCallExpression" : "CallExpression");
          }
          parseCallExpressionArguments(e3, t3, n3, r3, i2) {
            const s2 = [];
            let a2 = true;
            const o2 = this.state.inFSharpPipelineDirectBody;
            for (this.state.inFSharpPipelineDirectBody = false; !this.eat(e3); ) {
              if (a2) a2 = false;
              else if (this.expect(12), this.match(e3)) {
                !t3 || this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") || this.raise(g.ImportCallArgumentTrailingComma, { at: this.state.lastTokStartLoc }), r3 && this.addTrailingCommaExtraToNode(r3), this.next();
                break;
              }
              s2.push(this.parseExprListItem(false, i2, n3));
            }
            return this.state.inFSharpPipelineDirectBody = o2, s2;
          }
          shouldParseAsyncArrow() {
            return this.match(19) && !this.canInsertSemicolon();
          }
          parseAsyncArrowFromCallExpression(e3, t3) {
            var n3;
            return this.resetPreviousNodeTrailingComments(t3), this.expect(19), this.parseArrowExpression(e3, t3.arguments, true, null == (n3 = t3.extra) ? void 0 : n3.trailingCommaLoc), t3.innerComments && Pe(e3, t3.innerComments), t3.callee.trailingComments && Pe(e3, t3.callee.trailingComments), e3;
          }
          parseNoCallExpr() {
            const e3 = this.state.startLoc;
            return this.parseSubscripts(this.parseExprAtom(), e3, true);
          }
          parseExprAtom(e3) {
            let t3, n3 = null;
            const { type: r3 } = this.state;
            switch (r3) {
              case 79:
                return this.parseSuper();
              case 83:
                return t3 = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaProperty(t3) : (this.match(10) || this.raise(g.UnsupportedImport, { at: this.state.lastTokStartLoc }), this.finishNode(t3, "Import"));
              case 78:
                return t3 = this.startNode(), this.next(), this.finishNode(t3, "ThisExpression");
              case 90:
                return this.parseDo(this.startNode(), false);
              case 56:
              case 31:
                return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
              case 132:
                return this.parseNumericLiteral(this.state.value);
              case 133:
                return this.parseBigIntLiteral(this.state.value);
              case 134:
                return this.parseDecimalLiteral(this.state.value);
              case 131:
                return this.parseStringLiteral(this.state.value);
              case 84:
                return this.parseNullLiteral();
              case 85:
                return this.parseBooleanLiteral(true);
              case 86:
                return this.parseBooleanLiteral(false);
              case 10: {
                const e4 = this.state.potentialArrowAt === this.state.start;
                return this.parseParenAndDistinguishExpression(e4);
              }
              case 2:
              case 1:
                return this.parseArrayLike(2 === this.state.type ? 4 : 3, false, true);
              case 0:
                return this.parseArrayLike(3, true, false, e3);
              case 6:
              case 7:
                return this.parseObjectLike(6 === this.state.type ? 9 : 8, false, true);
              case 5:
                return this.parseObjectLike(8, false, false, e3);
              case 68:
                return this.parseFunctionOrFunctionSent();
              case 26:
                n3 = this.parseDecorators();
              case 80:
                return this.parseClass(this.maybeTakeDecorators(n3, this.startNode()), false);
              case 77:
                return this.parseNewOrNewTarget();
              case 25:
              case 24:
                return this.parseTemplate(false);
              case 15: {
                t3 = this.startNode(), this.next(), t3.object = null;
                const e4 = t3.callee = this.parseNoCallExpr();
                if ("MemberExpression" === e4.type) return this.finishNode(t3, "BindExpression");
                throw this.raise(g.UnsupportedBind, { at: e4 });
              }
              case 136:
                return this.raise(g.PrivateInExpectedIn, { at: this.state.startLoc, identifierName: this.state.value }), this.parsePrivateName();
              case 33:
                return this.parseTopicReferenceThenEqualsSign(54, "%");
              case 32:
                return this.parseTopicReferenceThenEqualsSign(44, "^");
              case 37:
              case 38:
                return this.parseTopicReference("hack");
              case 44:
              case 54:
              case 27: {
                const e4 = this.getPluginOption("pipelineOperator", "proposal");
                if (e4) return this.parseTopicReference(e4);
                this.unexpected();
                break;
              }
              case 47: {
                const e4 = this.input.codePointAt(this.nextTokenStart());
                ae(e4) || 62 === e4 ? this.expectOnePlugin(["jsx", "flow", "typescript"]) : this.unexpected();
                break;
              }
              default:
                if (W(r3)) {
                  if (this.isContextual(125) && 123 === this.lookaheadInLineCharCode()) return this.parseModuleExpression();
                  const e4 = this.state.potentialArrowAt === this.state.start, t4 = this.state.containsEsc, n4 = this.parseIdentifier();
                  if (!t4 && "async" === n4.name && !this.canInsertSemicolon()) {
                    const { type: e5 } = this.state;
                    if (68 === e5) return this.resetPreviousNodeTrailingComments(n4), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(n4));
                    if (W(e5)) return 61 === this.lookaheadCharCode() ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(n4)) : n4;
                    if (90 === e5) return this.resetPreviousNodeTrailingComments(n4), this.parseDo(this.startNodeAtNode(n4), true);
                  }
                  return e4 && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(n4), [n4], false)) : n4;
                }
                this.unexpected();
            }
          }
          parseTopicReferenceThenEqualsSign(e3, t3) {
            const n3 = this.getPluginOption("pipelineOperator", "proposal");
            if (n3) return this.state.type = e3, this.state.value = t3, this.state.pos--, this.state.end--, this.state.endLoc = s(this.state.endLoc, -1), this.parseTopicReference(n3);
            this.unexpected();
          }
          parseTopicReference(e3) {
            const t3 = this.startNode(), n3 = this.state.startLoc, r3 = this.state.type;
            return this.next(), this.finishTopicReference(t3, n3, e3, r3);
          }
          finishTopicReference(e3, t3, n3, r3) {
            if (this.testTopicReferenceConfiguration(n3, t3, r3)) {
              const r4 = "smart" === n3 ? "PipelinePrimaryTopicReference" : "TopicReference";
              return this.topicReferenceIsAllowedInCurrentContext() || this.raise("smart" === n3 ? g.PrimaryTopicNotAllowed : g.PipeTopicUnbound, { at: t3 }), this.registerTopicReference(), this.finishNode(e3, r4);
            }
            throw this.raise(g.PipeTopicUnconfiguredToken, { at: t3, token: $(r3) });
          }
          testTopicReferenceConfiguration(e3, t3, n3) {
            switch (e3) {
              case "hack":
                return this.hasPlugin(["pipelineOperator", { topicToken: $(n3) }]);
              case "smart":
                return 27 === n3;
              default:
                throw this.raise(g.PipeTopicRequiresHackPipes, { at: t3 });
            }
          }
          parseAsyncArrowUnaryFunction(e3) {
            this.prodParam.enter(tt(true, this.prodParam.hasYield));
            const t3 = [this.parseIdentifier()];
            return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(g.LineTerminatorBeforeArrow, { at: this.state.curPosition() }), this.expect(19), this.parseArrowExpression(e3, t3, true);
          }
          parseDo(e3, t3) {
            this.expectPlugin("doExpressions"), t3 && this.expectPlugin("asyncDoExpressions"), e3.async = t3, this.next();
            const n3 = this.state.labels;
            return this.state.labels = [], t3 ? (this.prodParam.enter(2), e3.body = this.parseBlock(), this.prodParam.exit()) : e3.body = this.parseBlock(), this.state.labels = n3, this.finishNode(e3, "DoExpression");
          }
          parseSuper() {
            const e3 = this.startNode();
            return this.next(), !this.match(10) || this.scope.allowDirectSuper || this.options.allowSuperOutsideMethod ? this.scope.allowSuper || this.options.allowSuperOutsideMethod || this.raise(g.UnexpectedSuper, { at: e3 }) : this.raise(g.SuperNotAllowed, { at: e3 }), this.match(10) || this.match(0) || this.match(16) || this.raise(g.UnsupportedSuper, { at: e3 }), this.finishNode(e3, "Super");
          }
          parsePrivateName() {
            const e3 = this.startNode(), t3 = this.startNodeAt(s(this.state.startLoc, 1)), n3 = this.state.value;
            return this.next(), e3.id = this.createIdentifier(t3, n3), this.finishNode(e3, "PrivateName");
          }
          parseFunctionOrFunctionSent() {
            const e3 = this.startNode();
            if (this.next(), this.prodParam.hasYield && this.match(16)) {
              const t3 = this.createIdentifier(this.startNodeAtNode(e3), "function");
              return this.next(), this.match(102) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.parseMetaProperty(e3, t3, "sent");
            }
            return this.parseFunction(e3);
          }
          parseMetaProperty(e3, t3, n3) {
            e3.meta = t3;
            const r3 = this.state.containsEsc;
            return e3.property = this.parseIdentifier(true), (e3.property.name !== n3 || r3) && this.raise(g.UnsupportedMetaProperty, { at: e3.property, target: t3.name, onlyValidPropertyName: n3 }), this.finishNode(e3, "MetaProperty");
          }
          parseImportMetaProperty(e3) {
            const t3 = this.createIdentifier(this.startNodeAtNode(e3), "import");
            return this.next(), this.isContextual(100) && (this.inModule || this.raise(g.ImportMetaOutsideModule, { at: t3 }), this.sawUnambiguousESM = true), this.parseMetaProperty(e3, t3, "meta");
          }
          parseLiteralAtNode(e3, t3, n3) {
            return this.addExtra(n3, "rawValue", e3), this.addExtra(n3, "raw", this.input.slice(n3.start, this.state.end)), n3.value = e3, this.next(), this.finishNode(n3, t3);
          }
          parseLiteral(e3, t3) {
            const n3 = this.startNode();
            return this.parseLiteralAtNode(e3, t3, n3);
          }
          parseStringLiteral(e3) {
            return this.parseLiteral(e3, "StringLiteral");
          }
          parseNumericLiteral(e3) {
            return this.parseLiteral(e3, "NumericLiteral");
          }
          parseBigIntLiteral(e3) {
            return this.parseLiteral(e3, "BigIntLiteral");
          }
          parseDecimalLiteral(e3) {
            return this.parseLiteral(e3, "DecimalLiteral");
          }
          parseRegExpLiteral(e3) {
            const t3 = this.parseLiteral(e3.value, "RegExpLiteral");
            return t3.pattern = e3.pattern, t3.flags = e3.flags, t3;
          }
          parseBooleanLiteral(e3) {
            const t3 = this.startNode();
            return t3.value = e3, this.next(), this.finishNode(t3, "BooleanLiteral");
          }
          parseNullLiteral() {
            const e3 = this.startNode();
            return this.next(), this.finishNode(e3, "NullLiteral");
          }
          parseParenAndDistinguishExpression(e3) {
            const t3 = this.state.startLoc;
            let n3;
            this.next(), this.expressionScope.enter(new ze(1));
            const r3 = this.state.maybeInArrowParameters, i2 = this.state.inFSharpPipelineDirectBody;
            this.state.maybeInArrowParameters = true, this.state.inFSharpPipelineDirectBody = false;
            const s2 = this.state.startLoc, a2 = [], o2 = new rt();
            let l2, c2, u2 = true;
            for (; !this.match(11); ) {
              if (u2) u2 = false;
              else if (this.expect(12, null === o2.optionalParametersLoc ? null : o2.optionalParametersLoc), this.match(11)) {
                c2 = this.state.startLoc;
                break;
              }
              if (this.match(21)) {
                const e4 = this.state.startLoc;
                if (l2 = this.state.startLoc, a2.push(this.parseParenItem(this.parseRestBinding(), e4)), !this.checkCommaAfterRest(41)) break;
              } else a2.push(this.parseMaybeAssignAllowIn(o2, this.parseParenItem));
            }
            const p2 = this.state.lastTokEndLoc;
            this.expect(11), this.state.maybeInArrowParameters = r3, this.state.inFSharpPipelineDirectBody = i2;
            let h2 = this.startNodeAt(t3);
            return e3 && this.shouldParseArrow(a2) && (h2 = this.parseArrow(h2)) ? (this.checkDestructuringPrivate(o2), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(h2, a2, false), h2) : (this.expressionScope.exit(), a2.length || this.unexpected(this.state.lastTokStartLoc), c2 && this.unexpected(c2), l2 && this.unexpected(l2), this.checkExpressionErrors(o2, true), this.toReferencedListDeep(a2, true), a2.length > 1 ? (n3 = this.startNodeAt(s2), n3.expressions = a2, this.finishNode(n3, "SequenceExpression"), this.resetEndLocation(n3, p2)) : n3 = a2[0], this.wrapParenthesis(t3, n3));
          }
          wrapParenthesis(e3, t3) {
            if (!this.options.createParenthesizedExpressions) return this.addExtra(t3, "parenthesized", true), this.addExtra(t3, "parenStart", e3.index), this.takeSurroundingComments(t3, e3.index, this.state.lastTokEndLoc.index), t3;
            const n3 = this.startNodeAt(e3);
            return n3.expression = t3, this.finishNode(n3, "ParenthesizedExpression");
          }
          shouldParseArrow(e3) {
            return !this.canInsertSemicolon();
          }
          parseArrow(e3) {
            if (this.eat(19)) return e3;
          }
          parseParenItem(e3, t3) {
            return e3;
          }
          parseNewOrNewTarget() {
            const e3 = this.startNode();
            if (this.next(), this.match(16)) {
              const t3 = this.createIdentifier(this.startNodeAtNode(e3), "new");
              this.next();
              const n3 = this.parseMetaProperty(e3, t3, "target");
              return this.scope.inNonArrowFunction || this.scope.inClass || this.options.allowNewTargetOutsideFunction || this.raise(g.UnexpectedNewTarget, { at: n3 }), n3;
            }
            return this.parseNew(e3);
          }
          parseNew(e3) {
            if (this.parseNewCallee(e3), this.eat(10)) {
              const t3 = this.parseExprList(11);
              this.toReferencedList(t3), e3.arguments = t3;
            } else e3.arguments = [];
            return this.finishNode(e3, "NewExpression");
          }
          parseNewCallee(e3) {
            e3.callee = this.parseNoCallExpr(), "Import" === e3.callee.type && this.raise(g.ImportCallNotNewExpression, { at: e3.callee });
          }
          parseTemplateElement(e3) {
            const { start: t3, startLoc: n3, end: r3, value: i2 } = this.state, a2 = t3 + 1, o2 = this.startNodeAt(s(n3, 1));
            null === i2 && (e3 || this.raise(g.InvalidEscapeSequenceTemplate, { at: s(this.state.firstInvalidTemplateEscapePos, 1) }));
            const l2 = this.match(24), c2 = l2 ? -1 : -2, u2 = r3 + c2;
            o2.value = { raw: this.input.slice(a2, u2).replace(/\r\n?/g, "\n"), cooked: null === i2 ? null : i2.slice(1, c2) }, o2.tail = l2, this.next();
            const p2 = this.finishNode(o2, "TemplateElement");
            return this.resetEndLocation(p2, s(this.state.lastTokEndLoc, c2)), p2;
          }
          parseTemplate(e3) {
            const t3 = this.startNode();
            t3.expressions = [];
            let n3 = this.parseTemplateElement(e3);
            for (t3.quasis = [n3]; !n3.tail; ) t3.expressions.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), t3.quasis.push(n3 = this.parseTemplateElement(e3));
            return this.finishNode(t3, "TemplateLiteral");
          }
          parseTemplateSubstitution() {
            return this.parseExpression();
          }
          parseObjectLike(e3, t3, n3, r3) {
            n3 && this.expectPlugin("recordAndTuple");
            const i2 = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = false;
            const s2 = /* @__PURE__ */ Object.create(null);
            let a2 = true;
            const o2 = this.startNode();
            for (o2.properties = [], this.next(); !this.match(e3); ) {
              if (a2) a2 = false;
              else if (this.expect(12), this.match(e3)) {
                this.addTrailingCommaExtraToNode(o2);
                break;
              }
              let i3;
              t3 ? i3 = this.parseBindingProperty() : (i3 = this.parsePropertyDefinition(r3), this.checkProto(i3, n3, s2, r3)), n3 && !this.isObjectProperty(i3) && "SpreadElement" !== i3.type && this.raise(g.InvalidRecordProperty, { at: i3 }), i3.shorthand && this.addExtra(i3, "shorthand", true), o2.properties.push(i3);
            }
            this.next(), this.state.inFSharpPipelineDirectBody = i2;
            let l2 = "ObjectExpression";
            return t3 ? l2 = "ObjectPattern" : n3 && (l2 = "RecordExpression"), this.finishNode(o2, l2);
          }
          addTrailingCommaExtraToNode(e3) {
            this.addExtra(e3, "trailingComma", this.state.lastTokStart), this.addExtra(e3, "trailingCommaLoc", this.state.lastTokStartLoc, false);
          }
          maybeAsyncOrAccessorProp(e3) {
            return !e3.computed && "Identifier" === e3.key.type && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
          }
          parsePropertyDefinition(e3) {
            let t3 = [];
            if (this.match(26)) for (this.hasPlugin("decorators") && this.raise(g.UnsupportedPropertyDecorator, { at: this.state.startLoc }); this.match(26); ) t3.push(this.parseDecorator());
            const n3 = this.startNode();
            let r3, i2 = false, s2 = false;
            if (this.match(21)) return t3.length && this.unexpected(), this.parseSpread();
            t3.length && (n3.decorators = t3, t3 = []), n3.method = false, e3 && (r3 = this.state.startLoc);
            let a2 = this.eat(55);
            this.parsePropertyNamePrefixOperator(n3);
            const o2 = this.state.containsEsc, l2 = this.parsePropertyName(n3, e3);
            if (!a2 && !o2 && this.maybeAsyncOrAccessorProp(n3)) {
              const e4 = l2.name;
              "async" !== e4 || this.hasPrecedingLineBreak() || (i2 = true, this.resetPreviousNodeTrailingComments(l2), a2 = this.eat(55), this.parsePropertyName(n3)), "get" !== e4 && "set" !== e4 || (s2 = true, this.resetPreviousNodeTrailingComments(l2), n3.kind = e4, this.match(55) && (a2 = true, this.raise(g.AccessorIsGenerator, { at: this.state.curPosition(), kind: e4 }), this.next()), this.parsePropertyName(n3));
            }
            return this.parseObjPropValue(n3, r3, a2, i2, false, s2, e3);
          }
          getGetterSetterExpectedParamCount(e3) {
            return "get" === e3.kind ? 0 : 1;
          }
          getObjectOrClassMethodParams(e3) {
            return e3.params;
          }
          checkGetterSetterParams(e3) {
            var t3;
            const n3 = this.getGetterSetterExpectedParamCount(e3), r3 = this.getObjectOrClassMethodParams(e3);
            r3.length !== n3 && this.raise("get" === e3.kind ? g.BadGetterArity : g.BadSetterArity, { at: e3 }), "set" === e3.kind && "RestElement" === (null == (t3 = r3[r3.length - 1]) ? void 0 : t3.type) && this.raise(g.BadSetterRestParameter, { at: e3 });
          }
          parseObjectMethod(e3, t3, n3, r3, i2) {
            if (i2) {
              const n4 = this.parseMethod(e3, t3, false, false, false, "ObjectMethod");
              return this.checkGetterSetterParams(n4), n4;
            }
            if (n3 || t3 || this.match(10)) return r3 && this.unexpected(), e3.kind = "method", e3.method = true, this.parseMethod(e3, t3, n3, false, false, "ObjectMethod");
          }
          parseObjectProperty(e3, t3, n3, r3) {
            if (e3.shorthand = false, this.eat(14)) return e3.value = n3 ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(r3), this.finishNode(e3, "ObjectProperty");
            if (!e3.computed && "Identifier" === e3.key.type) {
              if (this.checkReservedWord(e3.key.name, e3.key.loc.start, true, false), n3) e3.value = this.parseMaybeDefault(t3, at(e3.key));
              else if (this.match(29)) {
                const n4 = this.state.startLoc;
                null != r3 ? null === r3.shorthandAssignLoc && (r3.shorthandAssignLoc = n4) : this.raise(g.InvalidCoverInitializedName, { at: n4 }), e3.value = this.parseMaybeDefault(t3, at(e3.key));
              } else e3.value = at(e3.key);
              return e3.shorthand = true, this.finishNode(e3, "ObjectProperty");
            }
          }
          parseObjPropValue(e3, t3, n3, r3, i2, s2, a2) {
            const o2 = this.parseObjectMethod(e3, n3, r3, i2, s2) || this.parseObjectProperty(e3, t3, i2, a2);
            return o2 || this.unexpected(), o2;
          }
          parsePropertyName(e3, t3) {
            if (this.eat(0)) e3.computed = true, e3.key = this.parseMaybeAssignAllowIn(), this.expect(3);
            else {
              const { type: n3, value: r3 } = this.state;
              let i2;
              if (X(n3)) i2 = this.parseIdentifier(true);
              else switch (n3) {
                case 132:
                  i2 = this.parseNumericLiteral(r3);
                  break;
                case 131:
                  i2 = this.parseStringLiteral(r3);
                  break;
                case 133:
                  i2 = this.parseBigIntLiteral(r3);
                  break;
                case 134:
                  i2 = this.parseDecimalLiteral(r3);
                  break;
                case 136: {
                  const e4 = this.state.startLoc;
                  null != t3 ? null === t3.privateKeyLoc && (t3.privateKeyLoc = e4) : this.raise(g.UnexpectedPrivateField, { at: e4 }), i2 = this.parsePrivateName();
                  break;
                }
                default:
                  this.unexpected();
              }
              e3.key = i2, 136 !== n3 && (e3.computed = false);
            }
            return e3.key;
          }
          initFunction(e3, t3) {
            e3.id = null, e3.generator = false, e3.async = t3;
          }
          parseMethod(e3, t3, n3, r3, i2, s2, a2 = false) {
            this.initFunction(e3, n3), e3.generator = t3, this.scope.enter(18 | (a2 ? 64 : 0) | (i2 ? 32 : 0)), this.prodParam.enter(tt(n3, e3.generator)), this.parseFunctionParams(e3, r3);
            const o2 = this.parseFunctionBodyAndFinish(e3, s2, true);
            return this.prodParam.exit(), this.scope.exit(), o2;
          }
          parseArrayLike(e3, t3, n3, r3) {
            n3 && this.expectPlugin("recordAndTuple");
            const i2 = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = false;
            const s2 = this.startNode();
            return this.next(), s2.elements = this.parseExprList(e3, !n3, r3, s2), this.state.inFSharpPipelineDirectBody = i2, this.finishNode(s2, n3 ? "TupleExpression" : "ArrayExpression");
          }
          parseArrowExpression(e3, t3, n3, r3) {
            this.scope.enter(6);
            let i2 = tt(n3, false);
            !this.match(5) && this.prodParam.hasIn && (i2 |= 8), this.prodParam.enter(i2), this.initFunction(e3, n3);
            const s2 = this.state.maybeInArrowParameters;
            return t3 && (this.state.maybeInArrowParameters = true, this.setArrowFunctionParameters(e3, t3, r3)), this.state.maybeInArrowParameters = false, this.parseFunctionBody(e3, true), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = s2, this.finishNode(e3, "ArrowFunctionExpression");
          }
          setArrowFunctionParameters(e3, t3, n3) {
            this.toAssignableList(t3, n3, false), e3.params = t3;
          }
          parseFunctionBodyAndFinish(e3, t3, n3 = false) {
            return this.parseFunctionBody(e3, false, n3), this.finishNode(e3, t3);
          }
          parseFunctionBody(e3, t3, n3 = false) {
            const r3 = t3 && !this.match(5);
            if (this.expressionScope.enter(Ze()), r3) e3.body = this.parseMaybeAssign(), this.checkParams(e3, false, t3, false);
            else {
              const r4 = this.state.strict, i2 = this.state.labels;
              this.state.labels = [], this.prodParam.enter(4 | this.prodParam.currentFlags()), e3.body = this.parseBlock(true, false, (i3) => {
                const s2 = !this.isSimpleParamList(e3.params);
                i3 && s2 && this.raise(g.IllegalLanguageModeDirective, { at: "method" !== e3.kind && "constructor" !== e3.kind || !e3.key ? e3 : e3.key.loc.end });
                const a2 = !r4 && this.state.strict;
                this.checkParams(e3, !(this.state.strict || t3 || n3 || s2), t3, a2), this.state.strict && e3.id && this.checkIdentifier(e3.id, 65, a2);
              }), this.prodParam.exit(), this.state.labels = i2;
            }
            this.expressionScope.exit();
          }
          isSimpleParameter(e3) {
            return "Identifier" === e3.type;
          }
          isSimpleParamList(e3) {
            for (let t3 = 0, n3 = e3.length; t3 < n3; t3++) if (!this.isSimpleParameter(e3[t3])) return false;
            return true;
          }
          checkParams(e3, t3, n3, r3 = true) {
            const i2 = !t3 && /* @__PURE__ */ new Set(), s2 = { type: "FormalParameters" };
            for (const t4 of e3.params) this.checkLVal(t4, { in: s2, binding: 5, checkClashes: i2, strictModeChanged: r3 });
          }
          parseExprList(e3, t3, n3, r3) {
            const i2 = [];
            let s2 = true;
            for (; !this.eat(e3); ) {
              if (s2) s2 = false;
              else if (this.expect(12), this.match(e3)) {
                r3 && this.addTrailingCommaExtraToNode(r3), this.next();
                break;
              }
              i2.push(this.parseExprListItem(t3, n3));
            }
            return i2;
          }
          parseExprListItem(e3, t3, n3) {
            let r3;
            if (this.match(12)) e3 || this.raise(g.UnexpectedToken, { at: this.state.curPosition(), unexpected: "," }), r3 = null;
            else if (this.match(21)) {
              const e4 = this.state.startLoc;
              r3 = this.parseParenItem(this.parseSpread(t3), e4);
            } else if (this.match(17)) {
              this.expectPlugin("partialApplication"), n3 || this.raise(g.UnexpectedArgumentPlaceholder, { at: this.state.startLoc });
              const e4 = this.startNode();
              this.next(), r3 = this.finishNode(e4, "ArgumentPlaceholder");
            } else r3 = this.parseMaybeAssignAllowIn(t3, this.parseParenItem);
            return r3;
          }
          parseIdentifier(e3) {
            const t3 = this.startNode(), n3 = this.parseIdentifierName(e3);
            return this.createIdentifier(t3, n3);
          }
          createIdentifier(e3, t3) {
            return e3.name = t3, e3.loc.identifierName = t3, this.finishNode(e3, "Identifier");
          }
          parseIdentifierName(e3) {
            let t3;
            const { startLoc: n3, type: r3 } = this.state;
            X(r3) ? t3 = this.state.value : this.unexpected();
            const i2 = r3 <= 92;
            return e3 ? i2 && this.replaceToken(130) : this.checkReservedWord(t3, n3, i2, false), this.next(), t3;
          }
          checkReservedWord(e3, t3, n3, r3) {
            if (!(e3.length > 10) && function(e4) {
              return ye.has(e4);
            }(e3)) {
              if (n3 && function(e4) {
                return le.has(e4);
              }(e3)) this.raise(g.UnexpectedKeyword, { at: t3, keyword: e3 });
              else if ((this.state.strict ? r3 ? fe : he : pe)(e3, this.inModule)) this.raise(g.UnexpectedReservedWord, { at: t3, reservedWord: e3 });
              else if ("yield" === e3) {
                if (this.prodParam.hasYield) return void this.raise(g.YieldBindingIdentifier, { at: t3 });
              } else if ("await" === e3) {
                if (this.prodParam.hasAwait) return void this.raise(g.AwaitBindingIdentifier, { at: t3 });
                if (this.scope.inStaticBlock) return void this.raise(g.AwaitBindingIdentifierInStaticBlock, { at: t3 });
                this.expressionScope.recordAsyncArrowParametersError({ at: t3 });
              } else if ("arguments" === e3 && this.scope.inClassAndNotInNonArrowFunction) return void this.raise(g.ArgumentsInClass, { at: t3 });
            }
          }
          isAwaitAllowed() {
            return !!this.prodParam.hasAwait || !(!this.options.allowAwaitOutsideFunction || this.scope.inFunction);
          }
          parseAwait(e3) {
            const t3 = this.startNodeAt(e3);
            return this.expressionScope.recordParameterInitializerError(g.AwaitExpressionFormalParameter, { at: t3 }), this.eat(55) && this.raise(g.ObsoleteAwaitStar, { at: t3 }), this.scope.inFunction || this.options.allowAwaitOutsideFunction || (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst = true : this.sawUnambiguousESM = true), this.state.soloAwait || (t3.argument = this.parseMaybeUnary(null, true)), this.finishNode(t3, "AwaitExpression");
          }
          isAmbiguousAwait() {
            if (this.hasPrecedingLineBreak()) return true;
            const { type: e3 } = this.state;
            return 53 === e3 || 10 === e3 || 0 === e3 || z(e3) || 101 === e3 && !this.state.containsEsc || 135 === e3 || 56 === e3 || this.hasPlugin("v8intrinsic") && 54 === e3;
          }
          parseYield() {
            const e3 = this.startNode();
            this.expressionScope.recordParameterInitializerError(g.YieldInParameter, { at: e3 }), this.next();
            let t3 = false, n3 = null;
            if (!this.hasPrecedingLineBreak()) switch (t3 = this.eat(55), this.state.type) {
              case 13:
              case 137:
              case 8:
              case 11:
              case 3:
              case 9:
              case 14:
              case 12:
                if (!t3) break;
              default:
                n3 = this.parseMaybeAssign();
            }
            return e3.delegate = t3, e3.argument = n3, this.finishNode(e3, "YieldExpression");
          }
          checkPipelineAtInfixOperator(e3, t3) {
            this.hasPlugin(["pipelineOperator", { proposal: "smart" }]) && "SequenceExpression" === e3.type && this.raise(g.PipelineHeadSequenceExpression, { at: t3 });
          }
          parseSmartPipelineBodyInStyle(e3, t3) {
            if (this.isSimpleReference(e3)) {
              const n3 = this.startNodeAt(t3);
              return n3.callee = e3, this.finishNode(n3, "PipelineBareFunction");
            }
            {
              const n3 = this.startNodeAt(t3);
              return this.checkSmartPipeTopicBodyEarlyErrors(t3), n3.expression = e3, this.finishNode(n3, "PipelineTopicExpression");
            }
          }
          isSimpleReference(e3) {
            switch (e3.type) {
              case "MemberExpression":
                return !e3.computed && this.isSimpleReference(e3.object);
              case "Identifier":
                return true;
              default:
                return false;
            }
          }
          checkSmartPipeTopicBodyEarlyErrors(e3) {
            if (this.match(19)) throw this.raise(g.PipelineBodyNoArrow, { at: this.state.startLoc });
            this.topicReferenceWasUsedInCurrentContext() || this.raise(g.PipelineTopicUnused, { at: e3 });
          }
          withTopicBindingContext(e3) {
            const t3 = this.state.topicContext;
            this.state.topicContext = { maxNumOfResolvableTopics: 1, maxTopicIndex: null };
            try {
              return e3();
            } finally {
              this.state.topicContext = t3;
            }
          }
          withSmartMixTopicForbiddingContext(e3) {
            if (!this.hasPlugin(["pipelineOperator", { proposal: "smart" }])) return e3();
            {
              const t3 = this.state.topicContext;
              this.state.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null };
              try {
                return e3();
              } finally {
                this.state.topicContext = t3;
              }
            }
          }
          withSoloAwaitPermittingContext(e3) {
            const t3 = this.state.soloAwait;
            this.state.soloAwait = true;
            try {
              return e3();
            } finally {
              this.state.soloAwait = t3;
            }
          }
          allowInAnd(e3) {
            const t3 = this.prodParam.currentFlags();
            if (8 & ~t3) {
              this.prodParam.enter(8 | t3);
              try {
                return e3();
              } finally {
                this.prodParam.exit();
              }
            }
            return e3();
          }
          disallowInAnd(e3) {
            const t3 = this.prodParam.currentFlags();
            if (8 & t3) {
              this.prodParam.enter(-9 & t3);
              try {
                return e3();
              } finally {
                this.prodParam.exit();
              }
            }
            return e3();
          }
          registerTopicReference() {
            this.state.topicContext.maxTopicIndex = 0;
          }
          topicReferenceIsAllowedInCurrentContext() {
            return this.state.topicContext.maxNumOfResolvableTopics >= 1;
          }
          topicReferenceWasUsedInCurrentContext() {
            return null != this.state.topicContext.maxTopicIndex && this.state.topicContext.maxTopicIndex >= 0;
          }
          parseFSharpPipelineBody(e3) {
            const t3 = this.state.startLoc;
            this.state.potentialArrowAt = this.state.start;
            const n3 = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = true;
            const r3 = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), t3, e3);
            return this.state.inFSharpPipelineDirectBody = n3, r3;
          }
          parseModuleExpression() {
            this.expectPlugin("moduleBlocks");
            const e3 = this.startNode();
            this.next(), this.match(5) || this.unexpected(null, 5);
            const t3 = this.startNodeAt(this.state.endLoc);
            this.next();
            const n3 = this.initializeScopes(true);
            this.enterInitialScopes();
            try {
              e3.body = this.parseProgram(t3, 8, "module");
            } finally {
              n3();
            }
            return this.finishNode(e3, "ModuleExpression");
          }
          parsePropertyNamePrefixOperator(e3) {
          }
        }
        const Rt = { kind: "loop" }, Ut = { kind: "switch" }, Vt = /[\uD800-\uDFFF]/u, Kt = /in(?:stanceof)?/y;
        class Wt extends jt {
          parseTopLevel(e3, t3) {
            return e3.program = this.parseProgram(t3), e3.comments = this.state.comments, this.options.tokens && (e3.tokens = function(e4, t4) {
              for (let n3 = 0; n3 < e4.length; n3++) {
                const r3 = e4[n3], { type: i2 } = r3;
                if ("number" == typeof i2) {
                  if (136 === i2) {
                    const { loc: t5, start: i3, value: a2, end: o2 } = r3, l2 = i3 + 1, c2 = s(t5.start, 1);
                    e4.splice(n3, 1, new qe({ type: Q(27), value: "#", start: i3, end: l2, startLoc: t5.start, endLoc: c2 }), new qe({ type: Q(130), value: a2, start: l2, end: o2, startLoc: c2, endLoc: t5.end })), n3++;
                    continue;
                  }
                  if (z(i2)) {
                    const { loc: a2, start: o2, value: l2, end: c2 } = r3, u2 = o2 + 1, p2 = s(a2.start, 1);
                    let h2, d2, f2, y2, m2;
                    h2 = 96 === t4.charCodeAt(o2) ? new qe({ type: Q(22), value: "`", start: o2, end: u2, startLoc: a2.start, endLoc: p2 }) : new qe({ type: Q(8), value: "}", start: o2, end: u2, startLoc: a2.start, endLoc: p2 }), 24 === i2 ? (f2 = c2 - 1, y2 = s(a2.end, -1), d2 = null === l2 ? null : l2.slice(1, -1), m2 = new qe({ type: Q(22), value: "`", start: f2, end: c2, startLoc: y2, endLoc: a2.end })) : (f2 = c2 - 2, y2 = s(a2.end, -2), d2 = null === l2 ? null : l2.slice(1, -2), m2 = new qe({ type: Q(23), value: "${", start: f2, end: c2, startLoc: y2, endLoc: a2.end })), e4.splice(n3, 1, h2, new qe({ type: Q(20), value: d2, start: u2, end: f2, startLoc: p2, endLoc: y2 }), m2), n3 += 2;
                    continue;
                  }
                  r3.type = Q(i2);
                }
              }
              return e4;
            }(this.tokens, this.input)), this.finishNode(e3, "File");
          }
          parseProgram(e3, t3 = 137, n3 = this.options.sourceType) {
            if (e3.sourceType = n3, e3.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(e3, true, true, t3), this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) for (const [e4, t4] of Array.from(this.scope.undefinedExports)) this.raise(g.ModuleExportUndefined, { at: t4, localName: e4 });
            let r3;
            return r3 = 137 === t3 ? this.finishNode(e3, "Program") : this.finishNodeAt(e3, "Program", s(this.state.startLoc, -1)), r3;
          }
          stmtToDirective(e3) {
            const t3 = e3;
            t3.type = "Directive", t3.value = t3.expression, delete t3.expression;
            const n3 = t3.value, r3 = n3.value, i2 = this.input.slice(n3.start, n3.end), s2 = n3.value = i2.slice(1, -1);
            return this.addExtra(n3, "raw", i2), this.addExtra(n3, "rawValue", s2), this.addExtra(n3, "expressionValue", r3), n3.type = "DirectiveLiteral", t3;
          }
          parseInterpreterDirective() {
            if (!this.match(28)) return null;
            const e3 = this.startNode();
            return e3.value = this.state.value, this.next(), this.finishNode(e3, "InterpreterDirective");
          }
          isLet() {
            return !!this.isContextual(99) && this.hasFollowingBindingAtom();
          }
          chStartsBindingIdentifier(e3, t3) {
            if (ae(e3)) {
              if (Kt.lastIndex = t3, Kt.test(this.input)) {
                const e4 = this.codePointAtPos(Kt.lastIndex);
                if (!oe(e4) && 92 !== e4) return false;
              }
              return true;
            }
            return 92 === e3;
          }
          chStartsBindingPattern(e3) {
            return 91 === e3 || 123 === e3;
          }
          hasFollowingBindingAtom() {
            const e3 = this.nextTokenStart(), t3 = this.codePointAtPos(e3);
            return this.chStartsBindingPattern(t3) || this.chStartsBindingIdentifier(t3, e3);
          }
          hasInLineFollowingBindingIdentifier() {
            const e3 = this.nextTokenInLineStart(), t3 = this.codePointAtPos(e3);
            return this.chStartsBindingIdentifier(t3, e3);
          }
          startsUsingForOf() {
            const { type: e3, containsEsc: t3 } = this.lookahead();
            return !(101 === e3 && !t3) && (W(e3) && !this.hasFollowingLineBreak() ? (this.expectPlugin("explicitResourceManagement"), true) : void 0);
          }
          startsAwaitUsing() {
            let e3 = this.nextTokenInLineStart();
            if (this.isUnparsedContextual(e3, "using")) {
              e3 = this.nextTokenInLineStartSince(e3 + 5);
              const t3 = this.codePointAtPos(e3);
              if (this.chStartsBindingIdentifier(t3, e3)) return this.expectPlugin("explicitResourceManagement"), true;
            }
            return false;
          }
          parseModuleItem() {
            return this.parseStatementLike(15);
          }
          parseStatementListItem() {
            return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
          }
          parseStatementOrSloppyAnnexBFunctionDeclaration(e3 = false) {
            let t3 = 0;
            return this.options.annexB && !this.state.strict && (t3 |= 4, e3 && (t3 |= 8)), this.parseStatementLike(t3);
          }
          parseStatement() {
            return this.parseStatementLike(0);
          }
          parseStatementLike(e3) {
            let t3 = null;
            return this.match(26) && (t3 = this.parseDecorators(true)), this.parseStatementContent(e3, t3);
          }
          parseStatementContent(e3, t3) {
            const n3 = this.state.type, r3 = this.startNode(), i2 = !!(2 & e3), s2 = !!(4 & e3), a2 = 1 & e3;
            switch (n3) {
              case 60:
                return this.parseBreakContinueStatement(r3, true);
              case 63:
                return this.parseBreakContinueStatement(r3, false);
              case 64:
                return this.parseDebuggerStatement(r3);
              case 90:
                return this.parseDoWhileStatement(r3);
              case 91:
                return this.parseForStatement(r3);
              case 68:
                if (46 === this.lookaheadCharCode()) break;
                return s2 || this.raise(this.state.strict ? g.StrictFunction : this.options.annexB ? g.SloppyFunctionAnnexB : g.SloppyFunction, { at: this.state.startLoc }), this.parseFunctionStatement(r3, false, !i2 && s2);
              case 80:
                return i2 || this.unexpected(), this.parseClass(this.maybeTakeDecorators(t3, r3), true);
              case 69:
                return this.parseIfStatement(r3);
              case 70:
                return this.parseReturnStatement(r3);
              case 71:
                return this.parseSwitchStatement(r3);
              case 72:
                return this.parseThrowStatement(r3);
              case 73:
                return this.parseTryStatement(r3);
              case 96:
                if (!this.state.containsEsc && this.startsAwaitUsing()) return this.isAwaitAllowed() ? i2 || this.raise(g.UnexpectedLexicalDeclaration, { at: r3 }) : this.raise(g.AwaitUsingNotInAsyncContext, { at: r3 }), this.next(), this.parseVarStatement(r3, "await using");
                break;
              case 105:
                if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifier()) break;
                return this.expectPlugin("explicitResourceManagement"), !this.scope.inModule && this.scope.inTopLevel ? this.raise(g.UnexpectedUsingDeclaration, { at: this.state.startLoc }) : i2 || this.raise(g.UnexpectedLexicalDeclaration, { at: this.state.startLoc }), this.parseVarStatement(r3, "using");
              case 99: {
                if (this.state.containsEsc) break;
                const e4 = this.nextTokenStart(), t4 = this.codePointAtPos(e4);
                if (91 !== t4) {
                  if (!i2 && this.hasFollowingLineBreak()) break;
                  if (!this.chStartsBindingIdentifier(t4, e4) && 123 !== t4) break;
                }
              }
              case 75:
                i2 || this.raise(g.UnexpectedLexicalDeclaration, { at: this.state.startLoc });
              case 74: {
                const e4 = this.state.value;
                return this.parseVarStatement(r3, e4);
              }
              case 92:
                return this.parseWhileStatement(r3);
              case 76:
                return this.parseWithStatement(r3);
              case 5:
                return this.parseBlock();
              case 13:
                return this.parseEmptyStatement(r3);
              case 83: {
                const e4 = this.lookaheadCharCode();
                if (40 === e4 || 46 === e4) break;
              }
              case 82: {
                let e4;
                return this.options.allowImportExportEverywhere || a2 || this.raise(g.UnexpectedImportExport, { at: this.state.startLoc }), this.next(), 83 === n3 ? (e4 = this.parseImport(r3), "ImportDeclaration" !== e4.type || e4.importKind && "value" !== e4.importKind || (this.sawUnambiguousESM = true)) : (e4 = this.parseExport(r3, t3), ("ExportNamedDeclaration" !== e4.type || e4.exportKind && "value" !== e4.exportKind) && ("ExportAllDeclaration" !== e4.type || e4.exportKind && "value" !== e4.exportKind) && "ExportDefaultDeclaration" !== e4.type || (this.sawUnambiguousESM = true)), this.assertModuleNodeAllowed(e4), e4;
              }
              default:
                if (this.isAsyncFunction()) return i2 || this.raise(g.AsyncFunctionInSingleStatementContext, { at: this.state.startLoc }), this.next(), this.parseFunctionStatement(r3, true, !i2 && s2);
            }
            const o2 = this.state.value, l2 = this.parseExpression();
            return W(n3) && "Identifier" === l2.type && this.eat(14) ? this.parseLabeledStatement(r3, o2, l2, e3) : this.parseExpressionStatement(r3, l2, t3);
          }
          assertModuleNodeAllowed(e3) {
            this.options.allowImportExportEverywhere || this.inModule || this.raise(g.ImportOutsideModule, { at: e3 });
          }
          decoratorsEnabledBeforeExport() {
            return !!this.hasPlugin("decorators-legacy") || this.hasPlugin("decorators") && false !== this.getPluginOption("decorators", "decoratorsBeforeExport");
          }
          maybeTakeDecorators(e3, t3, n3) {
            return e3 && (t3.decorators && t3.decorators.length > 0 ? ("boolean" != typeof this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(g.DecoratorsBeforeAfterExport, { at: t3.decorators[0] }), t3.decorators.unshift(...e3)) : t3.decorators = e3, this.resetStartLocationFromNode(t3, e3[0]), n3 && this.resetStartLocationFromNode(n3, t3)), t3;
          }
          canHaveLeadingDecorator() {
            return this.match(80);
          }
          parseDecorators(e3) {
            const t3 = [];
            do {
              t3.push(this.parseDecorator());
            } while (this.match(26));
            if (this.match(82)) e3 || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(g.DecoratorExportClass, { at: this.state.startLoc });
            else if (!this.canHaveLeadingDecorator()) throw this.raise(g.UnexpectedLeadingDecorator, { at: this.state.startLoc });
            return t3;
          }
          parseDecorator() {
            this.expectOnePlugin(["decorators", "decorators-legacy"]);
            const e3 = this.startNode();
            if (this.next(), this.hasPlugin("decorators")) {
              const t3 = this.state.startLoc;
              let n3;
              if (this.match(10)) {
                const t4 = this.state.startLoc;
                this.next(), n3 = this.parseExpression(), this.expect(11), n3 = this.wrapParenthesis(t4, n3);
                const r3 = this.state.startLoc;
                e3.expression = this.parseMaybeDecoratorArguments(n3), false === this.getPluginOption("decorators", "allowCallParenthesized") && e3.expression !== n3 && this.raise(g.DecoratorArgumentsOutsideParentheses, { at: r3 });
              } else {
                for (n3 = this.parseIdentifier(false); this.eat(16); ) {
                  const e4 = this.startNodeAt(t3);
                  e4.object = n3, this.match(136) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), e4.property = this.parsePrivateName()) : e4.property = this.parseIdentifier(true), e4.computed = false, n3 = this.finishNode(e4, "MemberExpression");
                }
                e3.expression = this.parseMaybeDecoratorArguments(n3);
              }
            } else e3.expression = this.parseExprSubscripts();
            return this.finishNode(e3, "Decorator");
          }
          parseMaybeDecoratorArguments(e3) {
            if (this.eat(10)) {
              const t3 = this.startNodeAtNode(e3);
              return t3.callee = e3, t3.arguments = this.parseCallExpressionArguments(11, false), this.toReferencedList(t3.arguments), this.finishNode(t3, "CallExpression");
            }
            return e3;
          }
          parseBreakContinueStatement(e3, t3) {
            return this.next(), this.isLineTerminator() ? e3.label = null : (e3.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(e3, t3), this.finishNode(e3, t3 ? "BreakStatement" : "ContinueStatement");
          }
          verifyBreakContinue(e3, t3) {
            let n3;
            for (n3 = 0; n3 < this.state.labels.length; ++n3) {
              const r3 = this.state.labels[n3];
              if (null == e3.label || r3.name === e3.label.name) {
                if (null != r3.kind && (t3 || "loop" === r3.kind)) break;
                if (e3.label && t3) break;
              }
            }
            if (n3 === this.state.labels.length) {
              const n4 = t3 ? "BreakStatement" : "ContinueStatement";
              this.raise(g.IllegalBreakContinue, { at: e3, type: n4 });
            }
          }
          parseDebuggerStatement(e3) {
            return this.next(), this.semicolon(), this.finishNode(e3, "DebuggerStatement");
          }
          parseHeaderExpression() {
            this.expect(10);
            const e3 = this.parseExpression();
            return this.expect(11), e3;
          }
          parseDoWhileStatement(e3) {
            return this.next(), this.state.labels.push(Rt), e3.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.expect(92), e3.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(e3, "DoWhileStatement");
          }
          parseForStatement(e3) {
            this.next(), this.state.labels.push(Rt);
            let t3 = null;
            if (this.isAwaitAllowed() && this.eatContextual(96) && (t3 = this.state.lastTokStartLoc), this.scope.enter(0), this.expect(10), this.match(13)) return null !== t3 && this.unexpected(t3), this.parseFor(e3, null);
            const n3 = this.isContextual(99);
            {
              const r4 = this.isContextual(96) && this.startsAwaitUsing(), i3 = r4 || this.isContextual(105) && this.startsUsingForOf(), s3 = n3 && this.hasFollowingBindingAtom() || i3;
              if (this.match(74) || this.match(75) || s3) {
                const n4 = this.startNode();
                let s4;
                r4 ? (s4 = "await using", this.isAwaitAllowed() || this.raise(g.AwaitUsingNotInAsyncContext, { at: this.state.startLoc }), this.next()) : s4 = this.state.value, this.next(), this.parseVar(n4, true, s4);
                const a3 = this.finishNode(n4, "VariableDeclaration"), o2 = this.match(58);
                return o2 && i3 && this.raise(g.ForInUsing, { at: a3 }), (o2 || this.isContextual(101)) && 1 === a3.declarations.length ? this.parseForIn(e3, a3, t3) : (null !== t3 && this.unexpected(t3), this.parseFor(e3, a3));
              }
            }
            const r3 = this.isContextual(95), i2 = new rt(), s2 = this.parseExpression(true, i2), a2 = this.isContextual(101);
            if (a2 && (n3 && this.raise(g.ForOfLet, { at: s2 }), null === t3 && r3 && "Identifier" === s2.type && this.raise(g.ForOfAsync, { at: s2 })), a2 || this.match(58)) {
              this.checkDestructuringPrivate(i2), this.toAssignable(s2, true);
              const n4 = a2 ? "ForOfStatement" : "ForInStatement";
              return this.checkLVal(s2, { in: { type: n4 } }), this.parseForIn(e3, s2, t3);
            }
            return this.checkExpressionErrors(i2, true), null !== t3 && this.unexpected(t3), this.parseFor(e3, s2);
          }
          parseFunctionStatement(e3, t3, n3) {
            return this.next(), this.parseFunction(e3, 1 | (n3 ? 2 : 0) | (t3 ? 8 : 0));
          }
          parseIfStatement(e3) {
            return this.next(), e3.test = this.parseHeaderExpression(), e3.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration(), e3.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null, this.finishNode(e3, "IfStatement");
          }
          parseReturnStatement(e3) {
            return this.prodParam.hasReturn || this.options.allowReturnOutsideFunction || this.raise(g.IllegalReturn, { at: this.state.startLoc }), this.next(), this.isLineTerminator() ? e3.argument = null : (e3.argument = this.parseExpression(), this.semicolon()), this.finishNode(e3, "ReturnStatement");
          }
          parseSwitchStatement(e3) {
            this.next(), e3.discriminant = this.parseHeaderExpression();
            const t3 = e3.cases = [];
            let n3;
            this.expect(5), this.state.labels.push(Ut), this.scope.enter(0);
            for (let e4; !this.match(8); ) if (this.match(61) || this.match(65)) {
              const r3 = this.match(61);
              n3 && this.finishNode(n3, "SwitchCase"), t3.push(n3 = this.startNode()), n3.consequent = [], this.next(), r3 ? n3.test = this.parseExpression() : (e4 && this.raise(g.MultipleDefaultsInSwitch, { at: this.state.lastTokStartLoc }), e4 = true, n3.test = null), this.expect(14);
            } else n3 ? n3.consequent.push(this.parseStatementListItem()) : this.unexpected();
            return this.scope.exit(), n3 && this.finishNode(n3, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(e3, "SwitchStatement");
          }
          parseThrowStatement(e3) {
            return this.next(), this.hasPrecedingLineBreak() && this.raise(g.NewlineAfterThrow, { at: this.state.lastTokEndLoc }), e3.argument = this.parseExpression(), this.semicolon(), this.finishNode(e3, "ThrowStatement");
          }
          parseCatchClauseParam() {
            const e3 = this.parseBindingAtom();
            return this.scope.enter(this.options.annexB && "Identifier" === e3.type ? 8 : 0), this.checkLVal(e3, { in: { type: "CatchClause" }, binding: 9 }), e3;
          }
          parseTryStatement(e3) {
            if (this.next(), e3.block = this.parseBlock(), e3.handler = null, this.match(62)) {
              const t3 = this.startNode();
              this.next(), this.match(10) ? (this.expect(10), t3.param = this.parseCatchClauseParam(), this.expect(11)) : (t3.param = null, this.scope.enter(0)), t3.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false)), this.scope.exit(), e3.handler = this.finishNode(t3, "CatchClause");
            }
            return e3.finalizer = this.eat(67) ? this.parseBlock() : null, e3.handler || e3.finalizer || this.raise(g.NoCatchOrFinally, { at: e3 }), this.finishNode(e3, "TryStatement");
          }
          parseVarStatement(e3, t3, n3 = false) {
            return this.next(), this.parseVar(e3, false, t3, n3), this.semicolon(), this.finishNode(e3, "VariableDeclaration");
          }
          parseWhileStatement(e3) {
            return this.next(), e3.test = this.parseHeaderExpression(), this.state.labels.push(Rt), e3.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.finishNode(e3, "WhileStatement");
          }
          parseWithStatement(e3) {
            return this.state.strict && this.raise(g.StrictWith, { at: this.state.startLoc }), this.next(), e3.object = this.parseHeaderExpression(), e3.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.finishNode(e3, "WithStatement");
          }
          parseEmptyStatement(e3) {
            return this.next(), this.finishNode(e3, "EmptyStatement");
          }
          parseLabeledStatement(e3, t3, n3, r3) {
            for (const e4 of this.state.labels) e4.name === t3 && this.raise(g.LabelRedeclaration, { at: n3, labelName: t3 });
            const i2 = (s2 = this.state.type) >= 90 && s2 <= 92 ? "loop" : this.match(71) ? "switch" : null;
            var s2;
            for (let t4 = this.state.labels.length - 1; t4 >= 0; t4--) {
              const n4 = this.state.labels[t4];
              if (n4.statementStart !== e3.start) break;
              n4.statementStart = this.state.start, n4.kind = i2;
            }
            return this.state.labels.push({ name: t3, kind: i2, statementStart: this.state.start }), e3.body = 8 & r3 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(true) : this.parseStatement(), this.state.labels.pop(), e3.label = n3, this.finishNode(e3, "LabeledStatement");
          }
          parseExpressionStatement(e3, t3, n3) {
            return e3.expression = t3, this.semicolon(), this.finishNode(e3, "ExpressionStatement");
          }
          parseBlock(e3 = false, t3 = true, n3) {
            const r3 = this.startNode();
            return e3 && this.state.strictErrors.clear(), this.expect(5), t3 && this.scope.enter(0), this.parseBlockBody(r3, e3, false, 8, n3), t3 && this.scope.exit(), this.finishNode(r3, "BlockStatement");
          }
          isValidDirective(e3) {
            return "ExpressionStatement" === e3.type && "StringLiteral" === e3.expression.type && !e3.expression.extra.parenthesized;
          }
          parseBlockBody(e3, t3, n3, r3, i2) {
            const s2 = e3.body = [], a2 = e3.directives = [];
            this.parseBlockOrModuleBlockBody(s2, t3 ? a2 : void 0, n3, r3, i2);
          }
          parseBlockOrModuleBlockBody(e3, t3, n3, r3, i2) {
            const s2 = this.state.strict;
            let a2 = false, o2 = false;
            for (; !this.match(r3); ) {
              const r4 = n3 ? this.parseModuleItem() : this.parseStatementListItem();
              if (t3 && !o2) {
                if (this.isValidDirective(r4)) {
                  const e4 = this.stmtToDirective(r4);
                  t3.push(e4), a2 || "use strict" !== e4.value.value || (a2 = true, this.setStrict(true));
                  continue;
                }
                o2 = true, this.state.strictErrors.clear();
              }
              e3.push(r4);
            }
            null == i2 || i2.call(this, a2), s2 || this.setStrict(false), this.next();
          }
          parseFor(e3, t3) {
            return e3.init = t3, this.semicolon(false), e3.test = this.match(13) ? null : this.parseExpression(), this.semicolon(false), e3.update = this.match(11) ? null : this.parseExpression(), this.expect(11), e3.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(e3, "ForStatement");
          }
          parseForIn(e3, t3, n3) {
            const r3 = this.match(58);
            return this.next(), r3 ? null !== n3 && this.unexpected(n3) : e3.await = null !== n3, "VariableDeclaration" !== t3.type || null == t3.declarations[0].init || r3 && this.options.annexB && !this.state.strict && "var" === t3.kind && "Identifier" === t3.declarations[0].id.type || this.raise(g.ForInOfLoopInitializer, { at: t3, type: r3 ? "ForInStatement" : "ForOfStatement" }), "AssignmentPattern" === t3.type && this.raise(g.InvalidLhs, { at: t3, ancestor: { type: "ForStatement" } }), e3.left = t3, e3.right = r3 ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), e3.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(e3, r3 ? "ForInStatement" : "ForOfStatement");
          }
          parseVar(e3, t3, n3, r3 = false) {
            const i2 = e3.declarations = [];
            for (e3.kind = n3; ; ) {
              const e4 = this.startNode();
              if (this.parseVarId(e4, n3), e4.init = this.eat(29) ? t3 ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, null !== e4.init || r3 || ("Identifier" === e4.id.type || t3 && (this.match(58) || this.isContextual(101)) ? "const" !== n3 || this.match(58) || this.isContextual(101) || this.raise(g.DeclarationMissingInitializer, { at: this.state.lastTokEndLoc, kind: "const" }) : this.raise(g.DeclarationMissingInitializer, { at: this.state.lastTokEndLoc, kind: "destructuring" })), i2.push(this.finishNode(e4, "VariableDeclarator")), !this.eat(12)) break;
            }
            return e3;
          }
          parseVarId(e3, t3) {
            const n3 = this.parseBindingAtom();
            this.checkLVal(n3, { in: { type: "VariableDeclarator" }, binding: "var" === t3 ? 5 : 8201 }), e3.id = n3;
          }
          parseAsyncFunctionExpression(e3) {
            return this.parseFunction(e3, 8);
          }
          parseFunction(e3, t3 = 0) {
            const n3 = 2 & t3, r3 = !!(1 & t3), i2 = r3 && !(4 & t3), s2 = !!(8 & t3);
            this.initFunction(e3, s2), this.match(55) && (n3 && this.raise(g.GeneratorInSingleStatementContext, { at: this.state.startLoc }), this.next(), e3.generator = true), r3 && (e3.id = this.parseFunctionId(i2));
            const a2 = this.state.maybeInArrowParameters;
            return this.state.maybeInArrowParameters = false, this.scope.enter(2), this.prodParam.enter(tt(s2, e3.generator)), r3 || (e3.id = this.parseFunctionId()), this.parseFunctionParams(e3, false), this.withSmartMixTopicForbiddingContext(() => {
              this.parseFunctionBodyAndFinish(e3, r3 ? "FunctionDeclaration" : "FunctionExpression");
            }), this.prodParam.exit(), this.scope.exit(), r3 && !n3 && this.registerFunctionStatementId(e3), this.state.maybeInArrowParameters = a2, e3;
          }
          parseFunctionId(e3) {
            return e3 || W(this.state.type) ? this.parseIdentifier() : null;
          }
          parseFunctionParams(e3, t3) {
            this.expect(10), this.expressionScope.enter(new Ge(3)), e3.params = this.parseBindingList(11, 41, 2 | (t3 ? 4 : 0)), this.expressionScope.exit();
          }
          registerFunctionStatementId(e3) {
            e3.id && this.scope.declareName(e3.id.name, !this.options.annexB || this.state.strict || e3.generator || e3.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, e3.id.loc.start);
          }
          parseClass(e3, t3, n3) {
            this.next();
            const r3 = this.state.strict;
            return this.state.strict = true, this.parseClassId(e3, t3, n3), this.parseClassSuper(e3), e3.body = this.parseClassBody(!!e3.superClass, r3), this.finishNode(e3, t3 ? "ClassDeclaration" : "ClassExpression");
          }
          isClassProperty() {
            return this.match(29) || this.match(13) || this.match(8);
          }
          isClassMethod() {
            return this.match(10);
          }
          isNonstaticConstructor(e3) {
            return !(e3.computed || e3.static || "constructor" !== e3.key.name && "constructor" !== e3.key.value);
          }
          parseClassBody(e3, t3) {
            this.classScope.enter();
            const n3 = { hadConstructor: false, hadSuperClass: e3 };
            let r3 = [];
            const i2 = this.startNode();
            if (i2.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
              for (; !this.match(8); ) {
                if (this.eat(13)) {
                  if (r3.length > 0) throw this.raise(g.DecoratorSemicolon, { at: this.state.lastTokEndLoc });
                  continue;
                }
                if (this.match(26)) {
                  r3.push(this.parseDecorator());
                  continue;
                }
                const e4 = this.startNode();
                r3.length && (e4.decorators = r3, this.resetStartLocationFromNode(e4, r3[0]), r3 = []), this.parseClassMember(i2, e4, n3), "constructor" === e4.kind && e4.decorators && e4.decorators.length > 0 && this.raise(g.DecoratorConstructor, { at: e4 });
              }
            }), this.state.strict = t3, this.next(), r3.length) throw this.raise(g.TrailingDecorator, { at: this.state.startLoc });
            return this.classScope.exit(), this.finishNode(i2, "ClassBody");
          }
          parseClassMemberFromModifier(e3, t3) {
            const n3 = this.parseIdentifier(true);
            if (this.isClassMethod()) {
              const r3 = t3;
              return r3.kind = "method", r3.computed = false, r3.key = n3, r3.static = false, this.pushClassMethod(e3, r3, false, false, false, false), true;
            }
            if (this.isClassProperty()) {
              const r3 = t3;
              return r3.computed = false, r3.key = n3, r3.static = false, e3.body.push(this.parseClassProperty(r3)), true;
            }
            return this.resetPreviousNodeTrailingComments(n3), false;
          }
          parseClassMember(e3, t3, n3) {
            const r3 = this.isContextual(104);
            if (r3) {
              if (this.parseClassMemberFromModifier(e3, t3)) return;
              if (this.eat(5)) return void this.parseClassStaticBlock(e3, t3);
            }
            this.parseClassMemberWithIsStatic(e3, t3, n3, r3);
          }
          parseClassMemberWithIsStatic(e3, t3, n3, r3) {
            const i2 = t3, s2 = t3, a2 = t3, o2 = t3, l2 = t3, c2 = i2, u2 = i2;
            if (t3.static = r3, this.parsePropertyNamePrefixOperator(t3), this.eat(55)) {
              c2.kind = "method";
              const t4 = this.match(136);
              return this.parseClassElementName(c2), t4 ? void this.pushClassPrivateMethod(e3, s2, true, false) : (this.isNonstaticConstructor(i2) && this.raise(g.ConstructorIsGenerator, { at: i2.key }), void this.pushClassMethod(e3, i2, true, false, false, false));
            }
            const p2 = W(this.state.type) && !this.state.containsEsc, h2 = this.match(136), d2 = this.parseClassElementName(t3), f2 = this.state.startLoc;
            if (this.parsePostMemberNameModifiers(u2), this.isClassMethod()) {
              if (c2.kind = "method", h2) return void this.pushClassPrivateMethod(e3, s2, false, false);
              const r4 = this.isNonstaticConstructor(i2);
              let a3 = false;
              r4 && (i2.kind = "constructor", n3.hadConstructor && !this.hasPlugin("typescript") && this.raise(g.DuplicateConstructor, { at: d2 }), r4 && this.hasPlugin("typescript") && t3.override && this.raise(g.OverrideOnConstructor, { at: d2 }), n3.hadConstructor = true, a3 = n3.hadSuperClass), this.pushClassMethod(e3, i2, false, false, r4, a3);
            } else if (this.isClassProperty()) h2 ? this.pushClassPrivateProperty(e3, o2) : this.pushClassProperty(e3, a2);
            else if (p2 && "async" === d2.name && !this.isLineTerminator()) {
              this.resetPreviousNodeTrailingComments(d2);
              const t4 = this.eat(55);
              u2.optional && this.unexpected(f2), c2.kind = "method";
              const n4 = this.match(136);
              this.parseClassElementName(c2), this.parsePostMemberNameModifiers(u2), n4 ? this.pushClassPrivateMethod(e3, s2, t4, true) : (this.isNonstaticConstructor(i2) && this.raise(g.ConstructorIsAsync, { at: i2.key }), this.pushClassMethod(e3, i2, t4, true, false, false));
            } else if (!p2 || "get" !== d2.name && "set" !== d2.name || this.match(55) && this.isLineTerminator()) if (p2 && "accessor" === d2.name && !this.isLineTerminator()) {
              this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(d2);
              const t4 = this.match(136);
              this.parseClassElementName(a2), this.pushClassAccessorProperty(e3, l2, t4);
            } else this.isLineTerminator() ? h2 ? this.pushClassPrivateProperty(e3, o2) : this.pushClassProperty(e3, a2) : this.unexpected();
            else {
              this.resetPreviousNodeTrailingComments(d2), c2.kind = d2.name;
              const t4 = this.match(136);
              this.parseClassElementName(i2), t4 ? this.pushClassPrivateMethod(e3, s2, false, false) : (this.isNonstaticConstructor(i2) && this.raise(g.ConstructorIsAccessor, { at: i2.key }), this.pushClassMethod(e3, i2, false, false, false, false)), this.checkGetterSetterParams(i2);
            }
          }
          parseClassElementName(e3) {
            const { type: t3, value: n3 } = this.state;
            if (130 !== t3 && 131 !== t3 || !e3.static || "prototype" !== n3 || this.raise(g.StaticPrototype, { at: this.state.startLoc }), 136 === t3) {
              "constructor" === n3 && this.raise(g.ConstructorClassPrivateField, { at: this.state.startLoc });
              const t4 = this.parsePrivateName();
              return e3.key = t4, t4;
            }
            return this.parsePropertyName(e3);
          }
          parseClassStaticBlock(e3, t3) {
            var n3;
            this.scope.enter(208);
            const r3 = this.state.labels;
            this.state.labels = [], this.prodParam.enter(0);
            const i2 = t3.body = [];
            this.parseBlockOrModuleBlockBody(i2, void 0, false, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = r3, e3.body.push(this.finishNode(t3, "StaticBlock")), null != (n3 = t3.decorators) && n3.length && this.raise(g.DecoratorStaticBlock, { at: t3 });
          }
          pushClassProperty(e3, t3) {
            t3.computed || "constructor" !== t3.key.name && "constructor" !== t3.key.value || this.raise(g.ConstructorClassField, { at: t3.key }), e3.body.push(this.parseClassProperty(t3));
          }
          pushClassPrivateProperty(e3, t3) {
            const n3 = this.parseClassPrivateProperty(t3);
            e3.body.push(n3), this.classScope.declarePrivateName(this.getPrivateNameSV(n3.key), 0, n3.key.loc.start);
          }
          pushClassAccessorProperty(e3, t3, n3) {
            if (!n3 && !t3.computed) {
              const e4 = t3.key;
              "constructor" !== e4.name && "constructor" !== e4.value || this.raise(g.ConstructorClassField, { at: e4 });
            }
            const r3 = this.parseClassAccessorProperty(t3);
            e3.body.push(r3), n3 && this.classScope.declarePrivateName(this.getPrivateNameSV(r3.key), 0, r3.key.loc.start);
          }
          pushClassMethod(e3, t3, n3, r3, i2, s2) {
            e3.body.push(this.parseMethod(t3, n3, r3, i2, s2, "ClassMethod", true));
          }
          pushClassPrivateMethod(e3, t3, n3, r3) {
            const i2 = this.parseMethod(t3, n3, r3, false, false, "ClassPrivateMethod", true);
            e3.body.push(i2);
            const s2 = "get" === i2.kind ? i2.static ? 6 : 2 : "set" === i2.kind ? i2.static ? 5 : 1 : 0;
            this.declareClassPrivateMethodInScope(i2, s2);
          }
          declareClassPrivateMethodInScope(e3, t3) {
            this.classScope.declarePrivateName(this.getPrivateNameSV(e3.key), t3, e3.key.loc.start);
          }
          parsePostMemberNameModifiers(e3) {
          }
          parseClassPrivateProperty(e3) {
            return this.parseInitializer(e3), this.semicolon(), this.finishNode(e3, "ClassPrivateProperty");
          }
          parseClassProperty(e3) {
            return this.parseInitializer(e3), this.semicolon(), this.finishNode(e3, "ClassProperty");
          }
          parseClassAccessorProperty(e3) {
            return this.parseInitializer(e3), this.semicolon(), this.finishNode(e3, "ClassAccessorProperty");
          }
          parseInitializer(e3) {
            this.scope.enter(80), this.expressionScope.enter(Ze()), this.prodParam.enter(0), e3.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
          }
          parseClassId(e3, t3, n3, r3 = 8331) {
            if (W(this.state.type)) e3.id = this.parseIdentifier(), t3 && this.declareNameFromIdentifier(e3.id, r3);
            else {
              if (!n3 && t3) throw this.raise(g.MissingClassName, { at: this.state.startLoc });
              e3.id = null;
            }
          }
          parseClassSuper(e3) {
            e3.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
          }
          parseExport(e3, t3) {
            const n3 = this.parseMaybeImportPhase(e3, true), r3 = this.maybeParseExportDefaultSpecifier(e3, n3), i2 = !r3 || this.eat(12), s2 = i2 && this.eatExportStar(e3), a2 = s2 && this.maybeParseExportNamespaceSpecifier(e3), o2 = i2 && (!a2 || this.eat(12)), l2 = r3 || s2;
            if (s2 && !a2) {
              if (r3 && this.unexpected(), t3) throw this.raise(g.UnsupportedDecoratorExport, { at: e3 });
              return this.parseExportFrom(e3, true), this.finishNode(e3, "ExportAllDeclaration");
            }
            const c2 = this.maybeParseExportNamedSpecifiers(e3);
            let u2;
            if (r3 && i2 && !s2 && !c2 && this.unexpected(null, 5), a2 && o2 && this.unexpected(null, 97), l2 || c2) {
              if (u2 = false, t3) throw this.raise(g.UnsupportedDecoratorExport, { at: e3 });
              this.parseExportFrom(e3, l2);
            } else u2 = this.maybeParseExportDeclaration(e3);
            if (l2 || c2 || u2) {
              var p2;
              const n4 = e3;
              if (this.checkExport(n4, true, false, !!n4.source), "ClassDeclaration" === (null == (p2 = n4.declaration) ? void 0 : p2.type)) this.maybeTakeDecorators(t3, n4.declaration, n4);
              else if (t3) throw this.raise(g.UnsupportedDecoratorExport, { at: e3 });
              return this.finishNode(n4, "ExportNamedDeclaration");
            }
            if (this.eat(65)) {
              const n4 = e3, r4 = this.parseExportDefaultExpression();
              if (n4.declaration = r4, "ClassDeclaration" === r4.type) this.maybeTakeDecorators(t3, r4, n4);
              else if (t3) throw this.raise(g.UnsupportedDecoratorExport, { at: e3 });
              return this.checkExport(n4, true, true), this.finishNode(n4, "ExportDefaultDeclaration");
            }
            this.unexpected(null, 5);
          }
          eatExportStar(e3) {
            return this.eat(55);
          }
          maybeParseExportDefaultSpecifier(e3, t3) {
            if (t3 || this.isExportDefaultSpecifier()) {
              this.expectPlugin("exportDefaultFrom", null == t3 ? void 0 : t3.loc.start);
              const n3 = t3 || this.parseIdentifier(true), r3 = this.startNodeAtNode(n3);
              return r3.exported = n3, e3.specifiers = [this.finishNode(r3, "ExportDefaultSpecifier")], true;
            }
            return false;
          }
          maybeParseExportNamespaceSpecifier(e3) {
            if (this.isContextual(93)) {
              e3.specifiers || (e3.specifiers = []);
              const t3 = this.startNodeAt(this.state.lastTokStartLoc);
              return this.next(), t3.exported = this.parseModuleExportName(), e3.specifiers.push(this.finishNode(t3, "ExportNamespaceSpecifier")), true;
            }
            return false;
          }
          maybeParseExportNamedSpecifiers(e3) {
            if (this.match(5)) {
              e3.specifiers || (e3.specifiers = []);
              const t3 = "type" === e3.exportKind;
              return e3.specifiers.push(...this.parseExportSpecifiers(t3)), e3.source = null, e3.declaration = null, this.hasPlugin("importAssertions") && (e3.assertions = []), true;
            }
            return false;
          }
          maybeParseExportDeclaration(e3) {
            return !!this.shouldParseExportDeclaration() && (e3.specifiers = [], e3.source = null, this.hasPlugin("importAssertions") && (e3.assertions = []), e3.declaration = this.parseExportDeclaration(e3), true);
          }
          isAsyncFunction() {
            if (!this.isContextual(95)) return false;
            const e3 = this.nextTokenInLineStart();
            return this.isUnparsedContextual(e3, "function");
          }
          parseExportDefaultExpression() {
            const e3 = this.startNode();
            if (this.match(68)) return this.next(), this.parseFunction(e3, 5);
            if (this.isAsyncFunction()) return this.next(), this.next(), this.parseFunction(e3, 13);
            if (this.match(80)) return this.parseClass(e3, true, true);
            if (this.match(26)) return this.hasPlugin("decorators") && true === this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(g.DecoratorBeforeExport, { at: this.state.startLoc }), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false), this.startNode()), true, true);
            if (this.match(75) || this.match(74) || this.isLet()) throw this.raise(g.UnsupportedDefaultExport, { at: this.state.startLoc });
            const t3 = this.parseMaybeAssignAllowIn();
            return this.semicolon(), t3;
          }
          parseExportDeclaration(e3) {
            return this.match(80) ? this.parseClass(this.startNode(), true, false) : this.parseStatementListItem();
          }
          isExportDefaultSpecifier() {
            const { type: e3 } = this.state;
            if (W(e3)) {
              if (95 === e3 && !this.state.containsEsc || 99 === e3) return false;
              if ((128 === e3 || 127 === e3) && !this.state.containsEsc) {
                const { type: e4 } = this.lookahead();
                if (W(e4) && 97 !== e4 || 5 === e4) return this.expectOnePlugin(["flow", "typescript"]), false;
              }
            } else if (!this.match(65)) return false;
            const t3 = this.nextTokenStart(), n3 = this.isUnparsedContextual(t3, "from");
            if (44 === this.input.charCodeAt(t3) || W(this.state.type) && n3) return true;
            if (this.match(65) && n3) {
              const e4 = this.input.charCodeAt(this.nextTokenStartSince(t3 + 4));
              return 34 === e4 || 39 === e4;
            }
            return false;
          }
          parseExportFrom(e3, t3) {
            this.eatContextual(97) ? (e3.source = this.parseImportSource(), this.checkExport(e3), this.maybeParseImportAttributes(e3), this.checkJSONModuleImport(e3)) : t3 && this.unexpected(), this.semicolon();
          }
          shouldParseExportDeclaration() {
            const { type: e3 } = this.state;
            return 26 === e3 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators")) ? (true === this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(g.DecoratorBeforeExport, { at: this.state.startLoc }), true) : 74 === e3 || 75 === e3 || 68 === e3 || 80 === e3 || this.isLet() || this.isAsyncFunction();
          }
          checkExport(e3, t3, n3, r3) {
            var i2;
            if (t3) {
              if (n3) {
                if (this.checkDuplicateExports(e3, "default"), this.hasPlugin("exportDefaultFrom")) {
                  var s2;
                  const t4 = e3.declaration;
                  "Identifier" !== t4.type || "from" !== t4.name || t4.end - t4.start != 4 || null != (s2 = t4.extra) && s2.parenthesized || this.raise(g.ExportDefaultFromAsIdentifier, { at: t4 });
                }
              } else if (null != (i2 = e3.specifiers) && i2.length) for (const t4 of e3.specifiers) {
                const { exported: e4 } = t4, n4 = "Identifier" === e4.type ? e4.name : e4.value;
                if (this.checkDuplicateExports(t4, n4), !r3 && t4.local) {
                  const { local: e5 } = t4;
                  "Identifier" !== e5.type ? this.raise(g.ExportBindingIsString, { at: t4, localName: e5.value, exportName: n4 }) : (this.checkReservedWord(e5.name, e5.loc.start, true, false), this.scope.checkLocalExport(e5));
                }
              }
              else if (e3.declaration) {
                if ("FunctionDeclaration" === e3.declaration.type || "ClassDeclaration" === e3.declaration.type) {
                  const t4 = e3.declaration.id;
                  if (!t4) throw new Error("Assertion failure");
                  this.checkDuplicateExports(e3, t4.name);
                } else if ("VariableDeclaration" === e3.declaration.type) for (const t4 of e3.declaration.declarations) this.checkDeclaration(t4.id);
              }
            }
          }
          checkDeclaration(e3) {
            if ("Identifier" === e3.type) this.checkDuplicateExports(e3, e3.name);
            else if ("ObjectPattern" === e3.type) for (const t3 of e3.properties) this.checkDeclaration(t3);
            else if ("ArrayPattern" === e3.type) for (const t3 of e3.elements) t3 && this.checkDeclaration(t3);
            else "ObjectProperty" === e3.type ? this.checkDeclaration(e3.value) : "RestElement" === e3.type ? this.checkDeclaration(e3.argument) : "AssignmentPattern" === e3.type && this.checkDeclaration(e3.left);
          }
          checkDuplicateExports(e3, t3) {
            this.exportedIdentifiers.has(t3) && ("default" === t3 ? this.raise(g.DuplicateDefaultExport, { at: e3 }) : this.raise(g.DuplicateExport, { at: e3, exportName: t3 })), this.exportedIdentifiers.add(t3);
          }
          parseExportSpecifiers(e3) {
            const t3 = [];
            let n3 = true;
            for (this.expect(5); !this.eat(8); ) {
              if (n3) n3 = false;
              else if (this.expect(12), this.eat(8)) break;
              const r3 = this.isContextual(128), i2 = this.match(131), s2 = this.startNode();
              s2.local = this.parseModuleExportName(), t3.push(this.parseExportSpecifier(s2, i2, e3, r3));
            }
            return t3;
          }
          parseExportSpecifier(e3, t3, n3, r3) {
            return this.eatContextual(93) ? e3.exported = this.parseModuleExportName() : t3 ? e3.exported = function(e4) {
              const { type: t4, start: n4, end: r4, loc: i2, range: s2, extra: a2 } = e4;
              if ("Placeholder" === t4) return function(e5) {
                return at(e5);
              }(e4);
              const o2 = Object.create(st);
              return o2.type = t4, o2.start = n4, o2.end = r4, o2.loc = i2, o2.range = s2, void 0 !== e4.raw ? o2.raw = e4.raw : o2.extra = a2, o2.value = e4.value, o2;
            }(e3.local) : e3.exported || (e3.exported = at(e3.local)), this.finishNode(e3, "ExportSpecifier");
          }
          parseModuleExportName() {
            if (this.match(131)) {
              const e3 = this.parseStringLiteral(this.state.value), t3 = e3.value.match(Vt);
              return t3 && this.raise(g.ModuleExportNameHasLoneSurrogate, { at: e3, surrogateCharCode: t3[0].charCodeAt(0) }), e3;
            }
            return this.parseIdentifier(true);
          }
          isJSONModuleImport(e3) {
            return null != e3.assertions && e3.assertions.some(({ key: e4, value: t3 }) => "json" === t3.value && ("Identifier" === e4.type ? "type" === e4.name : "type" === e4.value));
          }
          checkImportReflection(e3) {
            var t3;
            e3.module && (1 === e3.specifiers.length && "ImportDefaultSpecifier" === e3.specifiers[0].type || this.raise(g.ImportReflectionNotBinding, { at: e3.specifiers[0].loc.start }), (null == (t3 = e3.assertions) ? void 0 : t3.length) > 0 && this.raise(g.ImportReflectionHasAssertion, { at: e3.specifiers[0].loc.start }));
          }
          checkJSONModuleImport(e3) {
            if (this.isJSONModuleImport(e3) && "ExportAllDeclaration" !== e3.type) {
              const { specifiers: t3 } = e3;
              if (null != t3) {
                const e4 = t3.find((e5) => {
                  let t4;
                  if ("ExportSpecifier" === e5.type ? t4 = e5.local : "ImportSpecifier" === e5.type && (t4 = e5.imported), void 0 !== t4) return "Identifier" === t4.type ? "default" !== t4.name : "default" !== t4.value;
                });
                void 0 !== e4 && this.raise(g.ImportJSONBindingNotDefault, { at: e4.loc.start });
              }
            }
          }
          isPotentialImportPhase(e3) {
            return !e3 && this.isContextual(125);
          }
          applyImportPhase(e3, t3, n3, r3) {
            t3 || ("module" === n3 ? (this.expectPlugin("importReflection", r3), e3.module = true) : this.hasPlugin("importReflection") && (e3.module = false));
          }
          parseMaybeImportPhase(e3, t3) {
            if (!this.isPotentialImportPhase(t3)) return this.applyImportPhase(e3, t3, null), null;
            const n3 = this.parseIdentifier(true), { type: r3 } = this.state;
            return (X(r3) ? 97 !== r3 || 102 === this.lookaheadCharCode() : 12 !== r3) ? (this.resetPreviousIdentifierLeadingComments(n3), this.applyImportPhase(e3, t3, n3.name, n3.loc.start), null) : (this.applyImportPhase(e3, t3, null), n3);
          }
          isPrecedingIdImportPhase(e3) {
            const { type: t3 } = this.state;
            return W(t3) ? 97 !== t3 || 102 === this.lookaheadCharCode() : 12 !== t3;
          }
          parseImport(e3) {
            return this.match(131) ? this.parseImportSourceAndAttributes(e3) : this.parseImportSpecifiersAndAfter(e3, this.parseMaybeImportPhase(e3, false));
          }
          parseImportSpecifiersAndAfter(e3, t3) {
            e3.specifiers = [];
            const n3 = !this.maybeParseDefaultImportSpecifier(e3, t3) || this.eat(12), r3 = n3 && this.maybeParseStarImportSpecifier(e3);
            return n3 && !r3 && this.parseNamedImportSpecifiers(e3), this.expectContextual(97), this.parseImportSourceAndAttributes(e3);
          }
          parseImportSourceAndAttributes(e3) {
            return null != e3.specifiers || (e3.specifiers = []), e3.source = this.parseImportSource(), this.maybeParseImportAttributes(e3), this.checkImportReflection(e3), this.checkJSONModuleImport(e3), this.semicolon(), this.finishNode(e3, "ImportDeclaration");
          }
          parseImportSource() {
            return this.match(131) || this.unexpected(), this.parseExprAtom();
          }
          parseImportSpecifierLocal(e3, t3, n3) {
            t3.local = this.parseIdentifier(), e3.specifiers.push(this.finishImportSpecifier(t3, n3));
          }
          finishImportSpecifier(e3, t3, n3 = 8201) {
            return this.checkLVal(e3.local, { in: { type: t3 }, binding: n3 }), this.finishNode(e3, t3);
          }
          parseImportAttributes() {
            this.expect(5);
            const e3 = [], t3 = /* @__PURE__ */ new Set();
            do {
              if (this.match(8)) break;
              const n3 = this.startNode(), r3 = this.state.value;
              if (t3.has(r3) && this.raise(g.ModuleAttributesWithDuplicateKeys, { at: this.state.startLoc, key: r3 }), t3.add(r3), this.match(131) ? n3.key = this.parseStringLiteral(r3) : n3.key = this.parseIdentifier(true), this.expect(14), !this.match(131)) throw this.raise(g.ModuleAttributeInvalidValue, { at: this.state.startLoc });
              n3.value = this.parseStringLiteral(this.state.value), e3.push(this.finishNode(n3, "ImportAttribute"));
            } while (this.eat(12));
            return this.expect(8), e3;
          }
          parseModuleAttributes() {
            const e3 = [], t3 = /* @__PURE__ */ new Set();
            do {
              const n3 = this.startNode();
              if (n3.key = this.parseIdentifier(true), "type" !== n3.key.name && this.raise(g.ModuleAttributeDifferentFromType, { at: n3.key }), t3.has(n3.key.name) && this.raise(g.ModuleAttributesWithDuplicateKeys, { at: n3.key, key: n3.key.name }), t3.add(n3.key.name), this.expect(14), !this.match(131)) throw this.raise(g.ModuleAttributeInvalidValue, { at: this.state.startLoc });
              n3.value = this.parseStringLiteral(this.state.value), e3.push(this.finishNode(n3, "ImportAttribute"));
            } while (this.eat(12));
            return e3;
          }
          maybeParseImportAttributes(e3) {
            let t3, n3 = false;
            if (this.match(76)) {
              if (this.hasPrecedingLineBreak() && 40 === this.lookaheadCharCode()) return;
              this.next(), this.hasPlugin("moduleAttributes") ? t3 = this.parseModuleAttributes() : (this.expectImportAttributesPlugin(), t3 = this.parseImportAttributes()), n3 = true;
            } else if (this.isContextual(94) && !this.hasPrecedingLineBreak()) this.hasPlugin("importAttributes") ? (true !== this.getPluginOption("importAttributes", "deprecatedAssertSyntax") && this.raise(g.ImportAttributesUseAssert, { at: this.state.startLoc }), this.addExtra(e3, "deprecatedAssertSyntax", true)) : this.expectOnePlugin(["importAttributes", "importAssertions"]), this.next(), t3 = this.parseImportAttributes();
            else if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) t3 = [];
            else {
              if (!this.hasPlugin("moduleAttributes")) return;
              t3 = [];
            }
            !n3 && this.hasPlugin("importAssertions") ? e3.assertions = t3 : e3.attributes = t3;
          }
          maybeParseDefaultImportSpecifier(e3, t3) {
            if (t3) {
              const n3 = this.startNodeAtNode(t3);
              return n3.local = t3, e3.specifiers.push(this.finishImportSpecifier(n3, "ImportDefaultSpecifier")), true;
            }
            return !!X(this.state.type) && (this.parseImportSpecifierLocal(e3, this.startNode(), "ImportDefaultSpecifier"), true);
          }
          maybeParseStarImportSpecifier(e3) {
            if (this.match(55)) {
              const t3 = this.startNode();
              return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(e3, t3, "ImportNamespaceSpecifier"), true;
            }
            return false;
          }
          parseNamedImportSpecifiers(e3) {
            let t3 = true;
            for (this.expect(5); !this.eat(8); ) {
              if (t3) t3 = false;
              else {
                if (this.eat(14)) throw this.raise(g.DestructureNamedImport, { at: this.state.startLoc });
                if (this.expect(12), this.eat(8)) break;
              }
              const n3 = this.startNode(), r3 = this.match(131), i2 = this.isContextual(128);
              n3.imported = this.parseModuleExportName();
              const s2 = this.parseImportSpecifier(n3, r3, "type" === e3.importKind || "typeof" === e3.importKind, i2, void 0);
              e3.specifiers.push(s2);
            }
          }
          parseImportSpecifier(e3, t3, n3, r3, i2) {
            if (this.eatContextual(93)) e3.local = this.parseIdentifier();
            else {
              const { imported: n4 } = e3;
              if (t3) throw this.raise(g.ImportBindingIsString, { at: e3, importName: n4.value });
              this.checkReservedWord(n4.name, e3.loc.start, true, true), e3.local || (e3.local = at(n4));
            }
            return this.finishImportSpecifier(e3, "ImportSpecifier", i2);
          }
          isThisParam(e3) {
            return "Identifier" === e3.type && "this" === e3.name;
          }
        }
        class Xt extends Wt {
          constructor(e3, t3) {
            super(e3 = function(e4) {
              if (null == e4) return Object.assign({}, Bt);
              if (null != e4.annexB && false !== e4.annexB) throw new Error("The `annexB` option can only be set to `false`.");
              const t4 = {};
              for (const r3 of Object.keys(Bt)) {
                var n3;
                t4[r3] = null != (n3 = e4[r3]) ? n3 : Bt[r3];
              }
              return t4;
            }(e3), t3), this.options = e3, this.initializeScopes(), this.plugins = function(e4) {
              const t4 = /* @__PURE__ */ new Map();
              for (const n3 of e4) {
                const [e5, r3] = Array.isArray(n3) ? n3 : [n3, {}];
                t4.has(e5) || t4.set(e5, r3 || {});
              }
              return t4;
            }(this.options.plugins), this.filename = e3.sourceFilename;
          }
          getScopeHandler() {
            return Te;
          }
          parse() {
            this.enterInitialScopes();
            const e3 = this.startNode(), t3 = this.startNode();
            return this.nextToken(), e3.errors = null, this.parseTopLevel(e3, t3), e3.errors = this.state.errors, e3;
          }
        }
        const Yt = function(e3) {
          const t3 = {};
          for (const n3 of Object.keys(e3)) t3[n3] = Q(e3[n3]);
          return t3;
        }(K);
        function qt(e3, t3) {
          let n3 = Xt;
          return null != e3 && e3.plugins && (function(e4) {
            if (It(e4, "decorators")) {
              if (It(e4, "decorators-legacy")) throw new Error("Cannot use the decorators and decorators-legacy plugin together");
              const t4 = Nt(e4, "decorators", "decoratorsBeforeExport");
              if (null != t4 && "boolean" != typeof t4) throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
              const n4 = Nt(e4, "decorators", "allowCallParenthesized");
              if (null != n4 && "boolean" != typeof n4) throw new Error("'allowCallParenthesized' must be a boolean.");
            }
            if (It(e4, "flow") && It(e4, "typescript")) throw new Error("Cannot combine flow and typescript plugins.");
            if (It(e4, "placeholders") && It(e4, "v8intrinsic")) throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
            if (It(e4, "pipelineOperator")) {
              const t4 = Nt(e4, "pipelineOperator", "proposal");
              if (!Ft.includes(t4)) {
                const e5 = Ft.map((e6) => `"${e6}"`).join(", ");
                throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${e5}.`);
              }
              const n4 = It(e4, ["recordAndTuple", { syntaxType: "hash" }]);
              if ("hack" === t4) {
                if (It(e4, "placeholders")) throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
                if (It(e4, "v8intrinsic")) throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
                const t5 = Nt(e4, "pipelineOperator", "topicToken");
                if (!kt.includes(t5)) {
                  const e5 = kt.map((e6) => `"${e6}"`).join(", ");
                  throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${e5}.`);
                }
                if ("#" === t5 && n4) throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
              } else if ("smart" === t4 && n4) throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
            }
            if (It(e4, "moduleAttributes")) {
              if (It(e4, "importAssertions") || It(e4, "importAttributes")) throw new Error("Cannot combine importAssertions, importAttributes and moduleAttributes plugins.");
              if ("may-2020" !== Nt(e4, "moduleAttributes", "version")) throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
            }
            if (It(e4, "importAssertions") && It(e4, "importAttributes")) throw new Error("Cannot combine importAssertions and importAttributes plugins.");
            if (It(e4, "recordAndTuple") && null != Nt(e4, "recordAndTuple", "syntaxType") && !Lt.includes(Nt(e4, "recordAndTuple", "syntaxType"))) throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + Lt.map((e5) => `'${e5}'`).join(", "));
            if (It(e4, "asyncDoExpressions") && !It(e4, "doExpressions")) {
              const e5 = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
              throw e5.missingPlugins = "doExpressions", e5;
            }
          }(e3.plugins), n3 = function(e4) {
            const t4 = Mt.filter((t5) => It(e4, t5)), n4 = t4.join("/");
            let r3 = Ht[n4];
            if (!r3) {
              r3 = Xt;
              for (const e5 of t4) r3 = _t[e5](r3);
              Ht[n4] = r3;
            }
            return r3;
          }(e3.plugins)), new n3(e3, t3);
        }
        const Ht = {};
        t2.parse = function(e3, t3) {
          var n3;
          if ("unambiguous" !== (null == (n3 = t3) ? void 0 : n3.sourceType)) return qt(t3, e3).parse();
          t3 = Object.assign({}, t3);
          try {
            t3.sourceType = "module";
            const n4 = qt(t3, e3), r3 = n4.parse();
            if (n4.sawUnambiguousESM) return r3;
            if (n4.ambiguousScriptDifferentAst) try {
              return t3.sourceType = "script", qt(t3, e3).parse();
            } catch (e4) {
            }
            else r3.program.sourceType = "script";
            return r3;
          } catch (n4) {
            try {
              return t3.sourceType = "script", qt(t3, e3).parse();
            } catch (e4) {
            }
            throw n4;
          }
        }, t2.parseExpression = function(e3, t3) {
          const n3 = qt(t3, e3);
          return n3.options.strictMode && (n3.state.strict = true), n3.getExpression();
        }, t2.tokTypes = Yt;
      }, 97: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function e3(t3, n3) {
          const l = /* @__PURE__ */ new WeakMap(), c = /* @__PURE__ */ new WeakMap(), u = n3 || (0, r2.validate)(null);
          return Object.assign((n4, ...a2) => {
            if ("string" == typeof n4) {
              if (a2.length > 1) throw new Error("Unexpected extra params.");
              return o((0, i.default)(t3, n4, (0, r2.merge)(u, (0, r2.validate)(a2[0]))));
            }
            if (Array.isArray(n4)) {
              let e4 = l.get(n4);
              return e4 || (e4 = (0, s.default)(t3, n4, u), l.set(n4, e4)), o(e4(a2));
            }
            if ("object" == typeof n4 && n4) {
              if (a2.length > 0) throw new Error("Unexpected extra params.");
              return e3(t3, (0, r2.merge)(u, (0, r2.validate)(n4)));
            }
            throw new Error("Unexpected template param " + typeof n4);
          }, { ast: (e4, ...n4) => {
            if ("string" == typeof e4) {
              if (n4.length > 1) throw new Error("Unexpected extra params.");
              return (0, i.default)(t3, e4, (0, r2.merge)((0, r2.merge)(u, (0, r2.validate)(n4[0])), a))();
            }
            if (Array.isArray(e4)) {
              let i2 = c.get(e4);
              return i2 || (i2 = (0, s.default)(t3, e4, (0, r2.merge)(u, a)), c.set(e4, i2)), i2(n4)();
            }
            throw new Error("Unexpected template param " + typeof e4);
          } });
        };
        var r2 = n2(2655), i = n2(5650), s = n2(2579);
        const a = (0, r2.validate)({ placeholderPattern: false });
        function o(e3) {
          let t3 = "";
          try {
            throw new Error();
          } catch (e4) {
            e4.stack && (t3 = e4.stack.split("\n").slice(3).join("\n"));
          }
          return (n3) => {
            try {
              return e3(n3);
            } catch (e4) {
              throw e4.stack += `
    =============
${t3}`, e4;
            }
          };
        }
      }, 6586: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.statements = t2.statement = t2.smart = t2.program = t2.expression = void 0;
        var r2 = n2(6067);
        const { assertExpressionStatement: i } = r2;
        function s(e3) {
          return { code: (e4) => `/* @babel/template */;
${e4}`, validate: () => {
          }, unwrap: (t3) => e3(t3.program.body.slice(1)) };
        }
        const a = s((e3) => e3.length > 1 ? e3 : e3[0]);
        t2.smart = a;
        const o = s((e3) => e3);
        t2.statements = o;
        const l = s((e3) => {
          if (0 === e3.length) throw new Error("Found nothing to return.");
          if (e3.length > 1) throw new Error("Found multiple statements but wanted one");
          return e3[0];
        });
        t2.statement = l;
        const c = { code: (e3) => `(
${e3}
)`, validate: (e3) => {
          if (e3.program.body.length > 1) throw new Error("Found multiple statements but wanted one");
          if (0 === c.unwrap(e3).start) throw new Error("Parse result included parens.");
        }, unwrap: ({ program: e3 }) => {
          const [t3] = e3.body;
          return i(t3), t3.expression;
        } };
        t2.expression = c, t2.program = { code: (e3) => e3, validate: () => {
        }, unwrap: (e3) => e3.program };
      }, 6849: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.statements = t2.statement = t2.smart = t2.program = t2.expression = t2.default = void 0;
        var r2 = n2(6586), i = n2(97);
        const s = (0, i.default)(r2.smart);
        t2.smart = s;
        const a = (0, i.default)(r2.statement);
        t2.statement = a;
        const o = (0, i.default)(r2.statements);
        t2.statements = o;
        const l = (0, i.default)(r2.expression);
        t2.expression = l;
        const c = (0, i.default)(r2.program);
        t2.program = c;
        var u = Object.assign(s.bind(void 0), { smart: s, statement: a, statements: o, expression: l, program: c, ast: s.ast });
        t2.default = u;
      }, 2579: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, n3) {
          const { metadata: a, names: o } = function(e4, t4, n4) {
            let r3 = "BABEL_TPL$";
            const s2 = t4.join("");
            do {
              r3 = "$$" + r3;
            } while (s2.includes(r3));
            const { names: a2, code: o2 } = function(e5, t5) {
              const n5 = [];
              let r4 = e5[0];
              for (let i2 = 1; i2 < e5.length; i2++) {
                const s3 = `${t5}${i2 - 1}`;
                n5.push(s3), r4 += s3 + e5[i2];
              }
              return { names: n5, code: r4 };
            }(t4, r3);
            return { metadata: (0, i.default)(e4, e4.code(o2), { parser: n4.parser, placeholderWhitelist: new Set(a2.concat(n4.placeholderWhitelist ? Array.from(n4.placeholderWhitelist) : [])), placeholderPattern: n4.placeholderPattern, preserveComments: n4.preserveComments, syntacticPlaceholders: n4.syntacticPlaceholders }), names: a2 };
          }(e3, t3, n3);
          return (t4) => {
            const n4 = {};
            return t4.forEach((e4, t5) => {
              n4[o[t5]] = e4;
            }), (t5) => {
              const i2 = (0, r2.normalizeReplacements)(t5);
              return i2 && Object.keys(i2).forEach((e4) => {
                if (Object.prototype.hasOwnProperty.call(n4, e4)) throw new Error("Unexpected replacement overlap.");
              }), e3.unwrap((0, s.default)(a, i2 ? Object.assign(i2, n4) : n4));
            };
          };
        };
        var r2 = n2(2655), i = n2(6382), s = n2(8112);
      }, 2655: (e2, t2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.merge = function(e3, t3) {
          const { placeholderWhitelist: n3 = e3.placeholderWhitelist, placeholderPattern: r2 = e3.placeholderPattern, preserveComments: i = e3.preserveComments, syntacticPlaceholders: s = e3.syntacticPlaceholders } = t3;
          return { parser: Object.assign({}, e3.parser, t3.parser), placeholderWhitelist: n3, placeholderPattern: r2, preserveComments: i, syntacticPlaceholders: s };
        }, t2.normalizeReplacements = function(e3) {
          if (Array.isArray(e3)) return e3.reduce((e4, t3, n3) => (e4["$" + n3] = t3, e4), {});
          if ("object" == typeof e3 || null == e3) return e3 || void 0;
          throw new Error("Template replacements must be an array, object, null, or undefined");
        }, t2.validate = function(e3) {
          if (null != e3 && "object" != typeof e3) throw new Error("Unknown template options.");
          const t3 = e3 || {}, { placeholderWhitelist: r2, placeholderPattern: i, preserveComments: s, syntacticPlaceholders: a } = t3, o = function(e4, t4) {
            if (null == e4) return {};
            var n3, r3, i2 = {}, s2 = Object.keys(e4);
            for (r3 = 0; r3 < s2.length; r3++) n3 = s2[r3], t4.indexOf(n3) >= 0 || (i2[n3] = e4[n3]);
            return i2;
          }(t3, n2);
          if (null != r2 && !(r2 instanceof Set)) throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
          if (null != i && !(i instanceof RegExp) && false !== i) throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
          if (null != s && "boolean" != typeof s) throw new Error("'.preserveComments' must be a boolean, null, or undefined");
          if (null != a && "boolean" != typeof a) throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
          if (true === a && (null != r2 || null != i)) throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
          return { parser: o, placeholderWhitelist: r2 || void 0, placeholderPattern: null == i ? void 0 : i, preserveComments: null == s ? void 0 : s, syntacticPlaceholders: null == a ? void 0 : a };
        };
        const n2 = ["placeholderWhitelist", "placeholderPattern", "preserveComments", "syntacticPlaceholders"];
      }, 6382: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, n3) {
          const { placeholderWhitelist: r3, placeholderPattern: a2, preserveComments: o2, syntacticPlaceholders: l2 } = n3, c2 = function(e4, t4, n4) {
            const r4 = (t4.plugins || []).slice();
            false !== n4 && r4.push("placeholders"), t4 = Object.assign({ allowReturnOutsideFunction: true, allowSuperOutsideMethod: true, sourceType: "module" }, t4, { plugins: r4 });
            try {
              return (0, i.parse)(e4, t4);
            } catch (t5) {
              const n5 = t5.loc;
              throw n5 && (t5.message += "\n" + (0, s.codeFrameColumns)(e4, { start: n5 }), t5.code = "BABEL_TEMPLATE_PARSE_ERROR"), t5;
            }
          }(t3, n3.parser, l2);
          y(c2, { preserveComments: o2 }), e3.validate(c2);
          const u2 = { syntactic: { placeholders: [], placeholderNames: /* @__PURE__ */ new Set() }, legacy: { placeholders: [], placeholderNames: /* @__PURE__ */ new Set() }, placeholderWhitelist: r3, placeholderPattern: a2, syntacticPlaceholders: l2 };
          return m(c2, g, u2), Object.assign({ ast: c2 }, u2.syntactic.placeholders.length ? u2.syntactic : u2.legacy);
        };
        var r2 = n2(6067), i = n2(7191), s = n2(4704);
        const { isCallExpression: a, isExpressionStatement: o, isFunction: l, isIdentifier: c, isJSXIdentifier: u, isNewExpression: p, isPlaceholder: h, isStatement: d, isStringLiteral: f, removePropertiesDeep: y, traverse: m } = r2, T = /^[_$A-Z0-9]+$/;
        function g(e3, t3, n3) {
          var r3;
          let i2, s2 = n3.syntactic.placeholders.length > 0;
          if (h(e3)) {
            if (false === n3.syntacticPlaceholders) throw new Error("%%foo%%-style placeholders can't be used when '.syntacticPlaceholders' is false.");
            i2 = e3.name.name, s2 = true;
          } else {
            if (s2 || n3.syntacticPlaceholders) return;
            if (c(e3) || u(e3)) i2 = e3.name;
            else {
              if (!f(e3)) return;
              i2 = e3.value;
            }
          }
          if (s2 && (null != n3.placeholderPattern || null != n3.placeholderWhitelist)) throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
          if (!(s2 || false !== n3.placeholderPattern && (n3.placeholderPattern || T).test(i2) || null != (r3 = n3.placeholderWhitelist) && r3.has(i2))) return;
          t3 = t3.slice();
          const { node: y2, key: m2 } = t3[t3.length - 1];
          let g2;
          f(e3) || h(e3, { expectedNode: "StringLiteral" }) ? g2 = "string" : p(y2) && "arguments" === m2 || a(y2) && "arguments" === m2 || l(y2) && "params" === m2 ? g2 = "param" : o(y2) && !h(e3) ? (g2 = "statement", t3 = t3.slice(0, -1)) : g2 = d(e3) && h(e3) ? "statement" : "other";
          const { placeholders: b, placeholderNames: E } = s2 ? n3.syntactic : n3.legacy;
          b.push({ name: i2, type: g2, resolve: (e4) => function(e5, t4) {
            let n4 = e5;
            for (let e6 = 0; e6 < t4.length - 1; e6++) {
              const { key: r5, index: i4 } = t4[e6];
              n4 = void 0 === i4 ? n4[r5] : n4[r5][i4];
            }
            const { key: r4, index: i3 } = t4[t4.length - 1];
            return { parent: n4, key: r4, index: i3 };
          }(e4, t3), isDuplicate: E.has(i2) }), E.add(i2);
        }
      }, 8112: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
          const n3 = s(e3.ast);
          return t3 && (e3.placeholders.forEach((e4) => {
            if (!Object.prototype.hasOwnProperty.call(t3, e4.name)) {
              const t4 = e4.name;
              throw new Error(`Error: No substitution given for "${t4}". If this is not meant to be a
            placeholder you may want to consider passing one of the following options to @babel/template:
            - { placeholderPattern: false, placeholderWhitelist: new Set(['${t4}'])}
            - { placeholderPattern: /^${t4}$/ }`);
            }
          }), Object.keys(t3).forEach((t4) => {
            if (!e3.placeholderNames.has(t4)) throw new Error(`Unknown substitution "${t4}" given`);
          })), e3.placeholders.slice().reverse().forEach((e4) => {
            try {
              !function(e5, t4, n4) {
                e5.isDuplicate && (Array.isArray(n4) ? n4 = n4.map((e6) => s(e6)) : "object" == typeof n4 && (n4 = s(n4)));
                const { parent: r3, key: d, index: f } = e5.resolve(t4);
                if ("string" === e5.type) {
                  if ("string" == typeof n4 && (n4 = p(n4)), !n4 || !u(n4)) throw new Error("Expected string substitution");
                } else if ("statement" === e5.type) void 0 === f ? n4 ? Array.isArray(n4) ? n4 = i(n4) : "string" == typeof n4 ? n4 = o(l(n4)) : c(n4) || (n4 = o(n4)) : n4 = a() : n4 && !Array.isArray(n4) && ("string" == typeof n4 && (n4 = l(n4)), c(n4) || (n4 = o(n4)));
                else if ("param" === e5.type) {
                  if ("string" == typeof n4 && (n4 = l(n4)), void 0 === f) throw new Error("Assertion failure.");
                } else if ("string" == typeof n4 && (n4 = l(n4)), Array.isArray(n4)) throw new Error("Cannot replace single expression with an array.");
                if (void 0 === f) h(r3, d, n4), r3[d] = n4;
                else {
                  const t5 = r3[d].slice();
                  "statement" === e5.type || "param" === e5.type ? null == n4 ? t5.splice(f, 1) : Array.isArray(n4) ? t5.splice(f, 1, ...n4) : t5[f] = n4 : t5[f] = n4, h(r3, d, t5), r3[d] = t5;
                }
              }(e4, n3, t3 && t3[e4.name] || null);
            } catch (t4) {
              throw t4.message = `@babel/template placeholder "${e4.name}": ${t4.message}`, t4;
            }
          }), n3;
        };
        var r2 = n2(6067);
        const { blockStatement: i, cloneNode: s, emptyStatement: a, expressionStatement: o, identifier: l, isStatement: c, isStringLiteral: u, stringLiteral: p, validate: h } = r2;
      }, 5650: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, n3) {
          let a;
          return t3 = e3.code(t3), (o) => {
            const l = (0, r2.normalizeReplacements)(o);
            return a || (a = (0, i.default)(e3, t3, n3)), e3.unwrap((0, s.default)(a, l));
          };
        };
        var r2 = n2(2655), i = n2(6382), s = n2(8112);
      }, 9446: (e2, t2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.clear = function() {
          i(), s();
        }, t2.clearPath = i, t2.clearScope = s, t2.getCachedPaths = function(e3, t3) {
          var r3;
          return null == (r3 = n2.get(a)) ? void 0 : r3.get(t3);
        }, t2.getOrCreateCachedPaths = function(e3, t3) {
          let r3 = n2.get(a);
          r3 || n2.set(a, r3 = /* @__PURE__ */ new WeakMap());
          let i2 = r3.get(t3);
          return i2 || r3.set(t3, i2 = /* @__PURE__ */ new Map()), i2;
        }, t2.scope = t2.path = void 0;
        let n2 = /* @__PURE__ */ new WeakMap();
        t2.path = n2;
        let r2 = /* @__PURE__ */ new WeakMap();
        function i() {
          t2.path = n2 = /* @__PURE__ */ new WeakMap();
        }
        function s() {
          t2.scope = r2 = /* @__PURE__ */ new WeakMap();
        }
        t2.scope = r2;
        const a = Object.freeze({});
      }, 4165: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var r2 = n2(763), i = n2(6067);
        const { VISITOR_KEYS: s } = i;
        t2.default = class {
          constructor(e3, t3, n3, r3) {
            this.queue = null, this.priorityQueue = null, this.parentPath = r3, this.scope = e3, this.state = n3, this.opts = t3;
          }
          shouldVisit(e3) {
            const t3 = this.opts;
            if (t3.enter || t3.exit) return true;
            if (t3[e3.type]) return true;
            const n3 = s[e3.type];
            if (null == n3 || !n3.length) return false;
            for (const t4 of n3) if (e3[t4]) return true;
            return false;
          }
          create(e3, t3, n3, i2) {
            return r2.default.get({ parentPath: this.parentPath, parent: e3, container: t3, key: n3, listKey: i2 });
          }
          maybeQueue(e3, t3) {
            this.queue && (t3 ? this.queue.push(e3) : this.priorityQueue.push(e3));
          }
          visitMultiple(e3, t3, n3) {
            if (0 === e3.length) return false;
            const r3 = [];
            for (let i2 = 0; i2 < e3.length; i2++) {
              const s2 = e3[i2];
              s2 && this.shouldVisit(s2) && r3.push(this.create(t3, e3, i2, n3));
            }
            return this.visitQueue(r3);
          }
          visitSingle(e3, t3) {
            return !!this.shouldVisit(e3[t3]) && this.visitQueue([this.create(e3, e3, t3)]);
          }
          visitQueue(e3) {
            this.queue = e3, this.priorityQueue = [];
            const t3 = /* @__PURE__ */ new WeakSet();
            let n3 = false;
            for (const r3 of e3) {
              if (r3.resync(), 0 !== r3.contexts.length && r3.contexts[r3.contexts.length - 1] === this || r3.pushContext(this), null === r3.key) continue;
              const { node: i2 } = r3;
              if (!t3.has(i2)) {
                if (i2 && t3.add(i2), r3.visit()) {
                  n3 = true;
                  break;
                }
                if (this.priorityQueue.length && (n3 = this.visitQueue(this.priorityQueue), this.priorityQueue = [], this.queue = e3, n3)) break;
              }
            }
            for (const t4 of e3) t4.popContext();
            return this.queue = null, n3;
          }
          visit(e3, t3) {
            const n3 = e3[t3];
            return !!n3 && (Array.isArray(n3) ? this.visitMultiple(n3, e3, t3) : this.visitSingle(e3, t3));
          }
        };
      }, 9799: (e2, t2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0, t2.default = class {
          getCode() {
          }
          getScope() {
          }
          addHelper() {
            throw new Error("Helpers are not supported by the default hub.");
          }
          buildError(e3, t3, n2 = TypeError) {
            return new n2(t3);
          }
        };
      }, 5686: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), Object.defineProperty(t2, "Hub", { enumerable: true, get: function() {
          return c.default;
        } }), Object.defineProperty(t2, "NodePath", { enumerable: true, get: function() {
          return o.default;
        } }), Object.defineProperty(t2, "Scope", { enumerable: true, get: function() {
          return l.default;
        } }), t2.visitors = t2.default = void 0;
        var r2 = n2(7380);
        t2.visitors = r2;
        var i = n2(6067), s = n2(9446), a = n2(9432), o = n2(763), l = n2(200), c = n2(9799);
        const { VISITOR_KEYS: u, removeProperties: p, traverseFast: h } = i;
        function d(e3, t3 = {}, n3, i2, s2, o2) {
          if (e3) {
            if (!t3.noScope && !n3 && "Program" !== e3.type && "File" !== e3.type) throw new Error(`You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a ${e3.type} node without passing scope and parentPath.`);
            if (!s2 && o2) throw new Error("visitSelf can only be used when providing a NodePath.");
            u[e3.type] && (r2.explode(t3), (0, a.traverseNode)(e3, t3, n3, i2, s2, null, o2));
          }
        }
        var f = d;
        function y(e3, t3) {
          e3.node.type === t3.type && (t3.has = true, e3.stop());
        }
        t2.default = f, d.visitors = r2, d.verify = r2.verify, d.explode = r2.explode, d.cheap = function(e3, t3) {
          h(e3, t3);
        }, d.node = function(e3, t3, n3, r3, i2, s2) {
          (0, a.traverseNode)(e3, t3, n3, r3, i2, s2);
        }, d.clearNode = function(e3, t3) {
          p(e3, t3);
        }, d.removeProperties = function(e3, t3) {
          return h(e3, d.clearNode, t3), e3;
        }, d.hasType = function(e3, t3, n3) {
          if (null != n3 && n3.includes(e3.type)) return false;
          if (e3.type === t3) return true;
          const r3 = { has: false, type: t3 };
          return d(e3, { noScope: true, denylist: n3, enter: y }, null, r3), r3.has;
        }, d.cache = s;
      }, 531: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.find = function(e3) {
          let t3 = this;
          do {
            if (e3(t3)) return t3;
          } while (t3 = t3.parentPath);
          return null;
        }, t2.findParent = function(e3) {
          let t3 = this;
          for (; t3 = t3.parentPath; ) if (e3(t3)) return t3;
          return null;
        }, t2.getAncestry = function() {
          let e3 = this;
          const t3 = [];
          do {
            t3.push(e3);
          } while (e3 = e3.parentPath);
          return t3;
        }, t2.getDeepestCommonAncestorFrom = function(e3, t3) {
          if (!e3.length) return this;
          if (1 === e3.length) return e3[0];
          let n3, r3, i2 = 1 / 0;
          const s = e3.map((e4) => {
            const t4 = [];
            do {
              t4.unshift(e4);
            } while ((e4 = e4.parentPath) && e4 !== this);
            return t4.length < i2 && (i2 = t4.length), t4;
          }), a = s[0];
          e: for (let e4 = 0; e4 < i2; e4++) {
            const t4 = a[e4];
            for (const n4 of s) if (n4[e4] !== t4) break e;
            n3 = e4, r3 = t4;
          }
          if (r3) return t3 ? t3(r3, n3, s) : r3;
          throw new Error("Couldn't find intersection");
        }, t2.getEarliestCommonAncestorFrom = function(e3) {
          return this.getDeepestCommonAncestorFrom(e3, function(e4, t3, n3) {
            let r3;
            const s = i[e4.type];
            for (const e5 of n3) {
              const n4 = e5[t3 + 1];
              r3 ? (n4.listKey && r3.listKey === n4.listKey && n4.key < r3.key || s.indexOf(r3.parentKey) > s.indexOf(n4.parentKey)) && (r3 = n4) : r3 = n4;
            }
            return r3;
          });
        }, t2.getFunctionParent = function() {
          return this.findParent((e3) => e3.isFunction());
        }, t2.getStatementParent = function() {
          let e3 = this;
          do {
            if (!e3.parentPath || Array.isArray(e3.container) && e3.isStatement()) break;
            e3 = e3.parentPath;
          } while (e3);
          if (e3 && (e3.isProgram() || e3.isFile())) throw new Error("File/Program node, we can't possibly find a statement parent to this");
          return e3;
        }, t2.inType = function(...e3) {
          let t3 = this;
          for (; t3; ) {
            for (const n3 of e3) if (t3.node.type === n3) return true;
            t3 = t3.parentPath;
          }
          return false;
        }, t2.isAncestor = function(e3) {
          return e3.isDescendant(this);
        }, t2.isDescendant = function(e3) {
          return !!this.findParent((t3) => t3 === e3);
        };
        var r2 = n2(6067);
        const { VISITOR_KEYS: i } = r2;
      }, 1801: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.addComment = function(e3, t3, n3) {
          i(this.node, e3, t3, n3);
        }, t2.addComments = function(e3, t3) {
          s(this.node, e3, t3);
        }, t2.shareCommentsWithSiblings = function() {
          if ("string" == typeof this.key) return;
          const e3 = this.node;
          if (!e3) return;
          const t3 = e3.trailingComments, n3 = e3.leadingComments;
          if (!t3 && !n3) return;
          const r3 = this.getSibling(this.key - 1), i2 = this.getSibling(this.key + 1), s2 = Boolean(r3.node), o = Boolean(i2.node);
          s2 && (n3 && r3.addComments("trailing", a(n3, r3.node.trailingComments)), t3 && !o && r3.addComments("trailing", t3)), o && (t3 && i2.addComments("leading", a(t3, i2.node.leadingComments)), n3 && !s2 && i2.addComments("leading", n3));
        };
        var r2 = n2(6067);
        const { addComment: i, addComments: s } = r2;
        function a(e3, t3) {
          if (!t3) return e3;
          let n3 = -1;
          return e3.filter((e4) => {
            const r3 = t3.indexOf(e4, n3);
            if (-1 === r3) return true;
            n3 = r3;
          });
        }
      }, 2981: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2._call = function(e3) {
          if (!e3) return false;
          for (const t3 of e3) {
            if (!t3) continue;
            const e4 = this.node;
            if (!e4) return true;
            const n3 = t3.call(this.state, this, this.state);
            if (n3 && "object" == typeof n3 && "function" == typeof n3.then) throw new Error("You appear to be using a plugin with an async traversal visitor, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
            if (n3) throw new Error(`Unexpected return value from visitor method ${t3}`);
            if (this.node !== e4) return true;
            if (this._traverseFlags > 0) return true;
          }
          return false;
        }, t2._getQueueContexts = function() {
          let e3 = this, t3 = this.contexts;
          for (; !t3.length && (e3 = e3.parentPath, e3); ) t3 = e3.contexts;
          return t3;
        }, t2._resyncKey = function() {
          if (this.container && this.node !== this.container[this.key]) {
            if (Array.isArray(this.container)) {
              for (let e3 = 0; e3 < this.container.length; e3++) if (this.container[e3] === this.node) return void this.setKey(e3);
            } else for (const e3 of Object.keys(this.container)) if (this.container[e3] === this.node) return void this.setKey(e3);
            this.key = null;
          }
        }, t2._resyncList = function() {
          if (!this.parent || !this.inList) return;
          const e3 = this.parent[this.listKey];
          this.container !== e3 && (this.container = e3 || null);
        }, t2._resyncParent = function() {
          this.parentPath && (this.parent = this.parentPath.node);
        }, t2._resyncRemoved = function() {
          null != this.key && this.container && this.container[this.key] === this.node || this._markRemoved();
        }, t2.call = function(e3) {
          const t3 = this.opts;
          return this.debug(e3), !(!this.node || !this._call(t3[e3])) || !!this.node && this._call(null == (n3 = t3[this.node.type]) ? void 0 : n3[e3]);
          var n3;
        }, t2.isBlacklisted = t2.isDenylisted = function() {
          var e3;
          const t3 = null != (e3 = this.opts.denylist) ? e3 : this.opts.blacklist;
          return t3 && t3.indexOf(this.node.type) > -1;
        }, t2.popContext = function() {
          this.contexts.pop(), this.contexts.length > 0 ? this.setContext(this.contexts[this.contexts.length - 1]) : this.setContext(void 0);
        }, t2.pushContext = function(e3) {
          this.contexts.push(e3), this.setContext(e3);
        }, t2.requeue = function(e3 = this) {
          if (e3.removed) return;
          const t3 = this.contexts;
          for (const n3 of t3) n3.maybeQueue(e3);
        }, t2.resync = function() {
          this.removed || (this._resyncParent(), this._resyncList(), this._resyncKey());
        }, t2.setContext = function(e3) {
          return null != this.skipKeys && (this.skipKeys = {}), this._traverseFlags = 0, e3 && (this.context = e3, this.state = e3.state, this.opts = e3.opts), this.setScope(), this;
        }, t2.setKey = function(e3) {
          var t3;
          this.key = e3, this.node = this.container[this.key], this.type = null == (t3 = this.node) ? void 0 : t3.type;
        }, t2.setScope = function() {
          var e3, t3;
          if (null != (e3 = this.opts) && e3.noScope) return;
          let n3, r3 = this.parentPath;
          for ((("key" === this.key || "decorators" === this.listKey) && r3.isMethod() || "discriminant" === this.key && r3.isSwitchStatement()) && (r3 = r3.parentPath); r3 && !n3; ) {
            var i2;
            if (null != (i2 = r3.opts) && i2.noScope) return;
            n3 = r3.scope, r3 = r3.parentPath;
          }
          this.scope = this.getScope(n3), null == (t3 = this.scope) || t3.init();
        }, t2.setup = function(e3, t3, n3, r3) {
          this.listKey = n3, this.container = t3, this.parentPath = e3 || this.parentPath, this.setKey(r3);
        }, t2.skip = function() {
          this.shouldSkip = true;
        }, t2.skipKey = function(e3) {
          null == this.skipKeys && (this.skipKeys = {}), this.skipKeys[e3] = true;
        }, t2.stop = function() {
          this._traverseFlags |= i.SHOULD_SKIP | i.SHOULD_STOP;
        }, t2.visit = function() {
          var e3, t3;
          if (!this.node) return false;
          if (this.isDenylisted()) return false;
          if (null != (e3 = (t3 = this.opts).shouldSkip) && e3.call(t3, this)) return false;
          const n3 = this.context;
          return this.shouldSkip || this.call("enter") ? (this.debug("Skip..."), this.shouldStop) : (s(this, n3), this.debug("Recursing into..."), this.shouldStop = (0, r2.traverseNode)(this.node, this.opts, this.scope, this.state, this, this.skipKeys), s(this, n3), this.call("exit"), this.shouldStop);
        };
        var r2 = n2(9432), i = n2(763);
        function s(e3, t3) {
          e3.context !== t3 && (e3.context = t3, e3.state = t3.state, e3.opts = t3.opts);
        }
      }, 6309: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.arrowFunctionToExpression = function({ allowInsertArrow: e3 = true, allowInsertArrowWithRest: t3 = e3, noNewArrows: n3 = !((e4) => null == (e4 = arguments[0]) ? void 0 : e4.specCompliant)() } = {}) {
          if (!this.isArrowFunctionExpression()) throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
          const { thisBinding: r3, fnPath: i2 } = k(this, n3, e3, t3);
          if (i2.ensureBlock(), i2.node.type = "FunctionExpression", !n3) {
            const e4 = r3 ? null : i2.scope.generateUidIdentifier("arrowCheckId");
            return e4 && i2.parentPath.scope.push({ id: e4, init: P([]) }), i2.get("body").unshiftContainer("body", d(p(this.hub.addHelper("newArrowCheck"), [O(), f(e4 ? e4.name : r3)]))), i2.replaceWith(p(b((0, s.default)(this, true) || i2.node, f("bind")), [e4 ? f(e4.name) : O()])), i2.get("callee.object");
          }
          return i2;
        }, t2.ensureBlock = function() {
          const e3 = this.get("body"), t3 = e3.node;
          if (Array.isArray(e3)) throw new Error("Can't convert array path to a block statement");
          if (!t3) throw new Error("Can't convert node without a body");
          if (e3.isBlockStatement()) return t3;
          const n3 = [];
          let r3, i2, s2 = "body";
          e3.isStatement() ? (i2 = "body", r3 = 0, n3.push(e3.node)) : (s2 += ".body.0", this.isFunction() ? (r3 = "argument", n3.push(D(e3.node))) : (r3 = "expression", n3.push(d(e3.node)))), this.node.body = u(n3);
          const a2 = this.get(s2);
          return e3.setup(a2, i2 ? a2.node[i2] : a2.node, i2, r3), this.node;
        }, t2.toComputedKey = function() {
          let e3;
          if (this.isMemberExpression()) e3 = this.node.property;
          else {
            if (!this.isProperty() && !this.isMethod()) throw new ReferenceError("todo");
            e3 = this.node.key;
          }
          return this.node.computed || y(e3) && (e3 = C(e3.name)), e3;
        }, t2.unwrapFunctionEnvironment = function() {
          if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
          k(this);
        };
        var r2 = n2(6067), i = n2(4705), s = n2(2023), a = n2(7380);
        const { arrowFunctionExpression: o, assignmentExpression: l, binaryExpression: c, blockStatement: u, callExpression: p, conditionalExpression: h, expressionStatement: d, identifier: f, isIdentifier: y, jsxIdentifier: m, logicalExpression: T, LOGICAL_OPERATORS: g, memberExpression: b, metaProperty: E, numericLiteral: S, objectExpression: P, restElement: x, returnStatement: D, sequenceExpression: A, spreadElement: v, stringLiteral: C, super: w, thisExpression: O, toExpression: I, unaryExpression: N } = r2;
        t2.arrowFunctionToShadowed = function() {
          this.isArrowFunctionExpression() && this.arrowFunctionToExpression();
        };
        const F = (0, a.merge)([{ CallExpression(e3, { allSuperCalls: t3 }) {
          e3.get("callee").isSuper() && t3.push(e3);
        } }, i.default]);
        function k(e3, t3 = true, n3 = true, r3 = true) {
          let i2, s2 = e3.findParent((e4) => e4.isArrowFunctionExpression() ? (null != i2 || (i2 = e4), false) : e4.isFunction() || e4.isProgram() || e4.isClassProperty({ static: false }) || e4.isClassPrivateProperty({ static: false }));
          const a2 = s2.isClassMethod({ kind: "constructor" });
          if (s2.isClassProperty() || s2.isClassPrivateProperty()) if (i2) s2 = i2;
          else {
            if (!n3) throw e3.buildCodeFrameError("Unable to transform arrow inside class property");
            e3.replaceWith(p(o([], I(e3.node)), [])), s2 = e3.get("callee"), e3 = s2.get("body");
          }
          const { thisPaths: u2, argumentsPaths: d2, newTargetPaths: y2, superProps: P2, superCalls: D2 } = function(e4) {
            const t4 = [], n4 = [], r4 = [], i3 = [], s3 = [];
            return e4.traverse(B, { thisPaths: t4, argumentsPaths: n4, newTargetPaths: r4, superProps: i3, superCalls: s3 }), { thisPaths: t4, argumentsPaths: n4, newTargetPaths: r4, superProps: i3, superCalls: s3 };
          }(e3);
          if (a2 && D2.length > 0) {
            if (!n3) throw D2[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super()` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
            if (!r3) throw D2[0].buildCodeFrameError("When using '@babel/plugin-transform-parameters', it's not possible to compile `super()` in an arrow function with default or rest parameters without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
            const e4 = [];
            s2.traverse(F, { allSuperCalls: e4 });
            const t4 = function(e5) {
              return M(e5, "supercall", () => {
                const t5 = e5.scope.generateUidIdentifier("args");
                return o([x(t5)], p(w(), [v(f(t5.name))]));
              });
            }(s2);
            e4.forEach((e5) => {
              const n4 = f(t4);
              n4.loc = e5.node.callee.loc, e5.get("callee").replaceWith(n4);
            });
          }
          if (d2.length > 0) {
            const e4 = M(s2, "arguments", () => {
              const e5 = () => f("arguments");
              return s2.scope.path.isProgram() ? h(c("===", N("typeof", e5()), C("undefined")), s2.scope.buildUndefinedNode(), e5()) : e5();
            });
            d2.forEach((t4) => {
              const n4 = f(e4);
              n4.loc = t4.node.loc, t4.replaceWith(n4);
            });
          }
          if (y2.length > 0) {
            const e4 = M(s2, "newtarget", () => E(f("new"), f("target")));
            y2.forEach((t4) => {
              const n4 = f(e4);
              n4.loc = t4.node.loc, t4.replaceWith(n4);
            });
          }
          if (P2.length > 0) {
            if (!n3) throw P2[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super.prop` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
            P2.reduce((e4, t4) => e4.concat(function(e5) {
              if (e5.parentPath.isAssignmentExpression() && "=" !== e5.parentPath.node.operator) {
                const n4 = e5.parentPath, r4 = n4.node.operator.slice(0, -1), i3 = n4.node.right, s3 = function(e6) {
                  return g.includes(e6);
                }(r4);
                if (e5.node.computed) {
                  const a3 = e5.scope.generateDeclaredUidIdentifier("tmp"), o2 = e5.node.object, c2 = e5.node.property;
                  n4.get("left").replaceWith(b(o2, l("=", a3, c2), true)), n4.get("right").replaceWith(t5(s3 ? "=" : r4, b(o2, f(a3.name), true), i3));
                } else {
                  const a3 = e5.node.object, o2 = e5.node.property;
                  n4.get("left").replaceWith(b(a3, o2)), n4.get("right").replaceWith(t5(s3 ? "=" : r4, b(a3, f(o2.name)), i3));
                }
                return s3 ? n4.replaceWith(T(r4, n4.node.left, n4.node.right)) : n4.node.operator = "=", [n4.get("left"), n4.get("right").get("left")];
              }
              if (e5.parentPath.isUpdateExpression()) {
                const t6 = e5.parentPath, n4 = e5.scope.generateDeclaredUidIdentifier("tmp"), r4 = e5.node.computed ? e5.scope.generateDeclaredUidIdentifier("prop") : null, i3 = [l("=", n4, b(e5.node.object, r4 ? l("=", r4, e5.node.property) : e5.node.property, e5.node.computed)), l("=", b(e5.node.object, r4 ? f(r4.name) : e5.node.property, e5.node.computed), c(e5.parentPath.node.operator[0], f(n4.name), S(1)))];
                return e5.parentPath.node.prefix || i3.push(f(n4.name)), t6.replaceWith(A(i3)), [t6.get("expressions.0.right"), t6.get("expressions.1.left")];
              }
              return [e5];
              function t5(e6, t6, n4) {
                return "=" === e6 ? l("=", t6, n4) : c(e6, t6, n4);
              }
            }(t4)), []).forEach((e4) => {
              const t4 = e4.node.computed ? "" : e4.get("property").node.name, n4 = e4.parentPath, r4 = n4.isAssignmentExpression({ left: e4.node }), i3 = n4.isCallExpression({ callee: e4.node }), a3 = n4.isTaggedTemplateExpression({ tag: e4.node }), c2 = function(e5, t5, n5) {
                return M(e5, `superprop_${t5 ? "set" : "get"}:${n5 || ""}`, () => {
                  const r5 = [];
                  let i4;
                  if (n5) i4 = b(w(), f(n5));
                  else {
                    const t6 = e5.scope.generateUidIdentifier("prop");
                    r5.unshift(t6), i4 = b(w(), f(t6.name), true);
                  }
                  if (t5) {
                    const t6 = e5.scope.generateUidIdentifier("value");
                    r5.push(t6), i4 = l("=", i4, f(t6.name));
                  }
                  return o(r5, i4);
                });
              }(s2, r4, t4), h2 = [];
              if (e4.node.computed && h2.push(e4.get("property").node), r4) {
                const e5 = n4.node.right;
                h2.push(e5);
              }
              const d3 = p(f(c2), h2);
              i3 ? (n4.unshiftContainer("arguments", O()), e4.replaceWith(b(d3, f("call"))), u2.push(n4.get("arguments.0"))) : r4 ? n4.replaceWith(d3) : a3 ? (e4.replaceWith(p(b(d3, f("bind"), false), [O()])), u2.push(e4.get("arguments.0"))) : e4.replaceWith(d3);
            });
          }
          let k2;
          return (u2.length > 0 || !t3) && (k2 = function(e4, t4) {
            return M(e4, "this", (n4) => {
              if (!t4 || !L(e4)) return O();
              e4.traverse(_, { supers: /* @__PURE__ */ new WeakSet(), thisBinding: n4 });
            });
          }(s2, a2), (t3 || a2 && L(s2)) && (u2.forEach((e4) => {
            const t4 = e4.isJSX() ? m(k2) : f(k2);
            t4.loc = e4.node.loc, e4.replaceWith(t4);
          }), t3 || (k2 = null))), { thisBinding: k2, fnPath: e3 };
        }
        function L(e3) {
          return e3.isClassMethod() && !!e3.parentPath.parentPath.node.superClass;
        }
        const _ = (0, a.merge)([{ CallExpression(e3, { supers: t3, thisBinding: n3 }) {
          e3.get("callee").isSuper() && (t3.has(e3.node) || (t3.add(e3.node), e3.replaceWithMultiple([e3.node, l("=", f(n3), f("this"))])));
        } }, i.default]);
        function M(e3, t3, n3) {
          const r3 = "binding:" + t3;
          let i2 = e3.getData(r3);
          if (!i2) {
            const s2 = e3.scope.generateUidIdentifier(t3);
            i2 = s2.name, e3.setData(r3, i2), e3.scope.push({ id: s2, init: n3(i2) });
          }
          return i2;
        }
        const B = (0, a.merge)([{ ThisExpression(e3, { thisPaths: t3 }) {
          t3.push(e3);
        }, JSXIdentifier(e3, { thisPaths: t3 }) {
          "this" === e3.node.name && (e3.parentPath.isJSXMemberExpression({ object: e3.node }) || e3.parentPath.isJSXOpeningElement({ name: e3.node })) && t3.push(e3);
        }, CallExpression(e3, { superCalls: t3 }) {
          e3.get("callee").isSuper() && t3.push(e3);
        }, MemberExpression(e3, { superProps: t3 }) {
          e3.get("object").isSuper() && t3.push(e3);
        }, Identifier(e3, { argumentsPaths: t3 }) {
          if (!e3.isReferencedIdentifier({ name: "arguments" })) return;
          let n3 = e3.scope;
          do {
            if (n3.hasOwnBinding("arguments")) return void n3.rename("arguments");
            if (n3.path.isFunction() && !n3.path.isArrowFunctionExpression()) break;
          } while (n3 = n3.parent);
          t3.push(e3);
        }, MetaProperty(e3, { newTargetPaths: t3 }) {
          e3.get("meta").isIdentifier({ name: "new" }) && e3.get("property").isIdentifier({ name: "target" }) && t3.push(e3);
        } }, i.default]);
      }, 2822: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.evaluate = function() {
          const e3 = { confident: true, deoptPath: null, seen: /* @__PURE__ */ new Map() };
          let t3 = l(this, e3);
          return e3.confident || (t3 = void 0), { confident: e3.confident, deopt: e3.deoptPath, value: t3 };
        }, t2.evaluateTruthy = function() {
          const e3 = this.evaluate();
          if (e3.confident) return !!e3.value;
        };
        const r2 = ["String", "Number", "Math"], i = ["random"];
        function s(e3) {
          return r2.includes(e3);
        }
        function a(e3, t3) {
          t3.confident && (t3.deoptPath = e3, t3.confident = false);
        }
        const o = /* @__PURE__ */ new Map([["undefined", void 0], ["Infinity", 1 / 0], ["NaN", NaN]]);
        function l(e3, t3) {
          const { node: r3 } = e3, { seen: u } = t3;
          if (u.has(r3)) {
            const n3 = u.get(r3);
            return n3.resolved ? n3.value : void a(e3, t3);
          }
          {
            const p = { resolved: false };
            u.set(r3, p);
            const h = function(e4, t4) {
              if (t4.confident) {
                if (e4.isSequenceExpression()) {
                  const n3 = e4.get("expressions");
                  return l(n3[n3.length - 1], t4);
                }
                if (e4.isStringLiteral() || e4.isNumericLiteral() || e4.isBooleanLiteral()) return e4.node.value;
                if (e4.isNullLiteral()) return null;
                if (e4.isTemplateLiteral()) return c(e4, e4.node.quasis, t4);
                if (e4.isTaggedTemplateExpression() && e4.get("tag").isMemberExpression()) {
                  const n3 = e4.get("tag.object"), { node: { name: r4 } } = n3, i2 = e4.get("tag.property");
                  if (n3.isIdentifier() && "String" === r4 && !e4.scope.getBinding(r4) && i2.isIdentifier() && "raw" === i2.node.name) return c(e4, e4.node.quasi.quasis, t4, true);
                }
                if (e4.isConditionalExpression()) {
                  const n3 = l(e4.get("test"), t4);
                  if (!t4.confident) return;
                  return l(n3 ? e4.get("consequent") : e4.get("alternate"), t4);
                }
                if (e4.isExpressionWrapper()) return l(e4.get("expression"), t4);
                if (e4.isMemberExpression() && !e4.parentPath.isCallExpression({ callee: e4.node })) {
                  const n3 = e4.get("property"), r4 = e4.get("object");
                  if (r4.isLiteral()) {
                    const i2 = r4.node.value, s2 = typeof i2;
                    let a2 = null;
                    if (e4.node.computed) {
                      if (a2 = l(n3, t4), !t4.confident) return;
                    } else n3.isIdentifier() && (a2 = n3.node.name);
                    if (!("number" !== s2 && "string" !== s2 || null == a2 || "number" != typeof a2 && "string" != typeof a2)) return i2[a2];
                  }
                }
                if (e4.isReferencedIdentifier()) {
                  const n3 = e4.scope.getBinding(e4.node.name);
                  if (n3) {
                    if (n3.constantViolations.length > 0 || e4.node.start < n3.path.node.end) return void a(n3.path, t4);
                    if (n3.hasValue) return n3.value;
                  }
                  const r4 = e4.node.name;
                  if (o.has(r4)) return n3 ? void a(n3.path, t4) : o.get(r4);
                  const i2 = e4.resolve();
                  return i2 === e4 ? void a(e4, t4) : l(i2, t4);
                }
                if (e4.isUnaryExpression({ prefix: true })) {
                  if ("void" === e4.node.operator) return;
                  const n3 = e4.get("argument");
                  if ("typeof" === e4.node.operator && (n3.isFunction() || n3.isClass())) return "function";
                  const r4 = l(n3, t4);
                  if (!t4.confident) return;
                  switch (e4.node.operator) {
                    case "!":
                      return !r4;
                    case "+":
                      return +r4;
                    case "-":
                      return -r4;
                    case "~":
                      return ~r4;
                    case "typeof":
                      return typeof r4;
                  }
                }
                if (e4.isArrayExpression()) {
                  const n3 = [], r4 = e4.get("elements");
                  for (const e5 of r4) {
                    const r5 = e5.evaluate();
                    if (!r5.confident) return void a(r5.deopt, t4);
                    n3.push(r5.value);
                  }
                  return n3;
                }
                if (e4.isObjectExpression()) {
                  const n3 = {}, r4 = e4.get("properties");
                  for (const e5 of r4) {
                    if (e5.isObjectMethod() || e5.isSpreadElement()) return void a(e5, t4);
                    const r5 = e5.get("key");
                    let i2;
                    if (e5.node.computed) {
                      if (i2 = r5.evaluate(), !i2.confident) return void a(i2.deopt, t4);
                      i2 = i2.value;
                    } else i2 = r5.isIdentifier() ? r5.node.name : r5.node.value;
                    let s2 = e5.get("value").evaluate();
                    if (!s2.confident) return void a(s2.deopt, t4);
                    s2 = s2.value, n3[i2] = s2;
                  }
                  return n3;
                }
                if (e4.isLogicalExpression()) {
                  const n3 = t4.confident, r4 = l(e4.get("left"), t4), i2 = t4.confident;
                  t4.confident = n3;
                  const s2 = l(e4.get("right"), t4), a2 = t4.confident;
                  switch (e4.node.operator) {
                    case "||":
                      if (t4.confident = i2 && (!!r4 || a2), !t4.confident) return;
                      return r4 || s2;
                    case "&&":
                      if (t4.confident = i2 && (!r4 || a2), !t4.confident) return;
                      return r4 && s2;
                    case "??":
                      if (t4.confident = i2 && (null != r4 || a2), !t4.confident) return;
                      return null != r4 ? r4 : s2;
                  }
                }
                if (e4.isBinaryExpression()) {
                  const n3 = l(e4.get("left"), t4);
                  if (!t4.confident) return;
                  const r4 = l(e4.get("right"), t4);
                  if (!t4.confident) return;
                  switch (e4.node.operator) {
                    case "-":
                      return n3 - r4;
                    case "+":
                      return n3 + r4;
                    case "/":
                      return n3 / r4;
                    case "*":
                      return n3 * r4;
                    case "%":
                      return n3 % r4;
                    case "**":
                      return Math.pow(n3, r4);
                    case "<":
                      return n3 < r4;
                    case ">":
                      return n3 > r4;
                    case "<=":
                      return n3 <= r4;
                    case ">=":
                      return n3 >= r4;
                    case "==":
                      return n3 == r4;
                    case "!=":
                      return n3 != r4;
                    case "===":
                      return n3 === r4;
                    case "!==":
                      return n3 !== r4;
                    case "|":
                      return n3 | r4;
                    case "&":
                      return n3 & r4;
                    case "^":
                      return n3 ^ r4;
                    case "<<":
                      return n3 << r4;
                    case ">>":
                      return n3 >> r4;
                    case ">>>":
                      return n3 >>> r4;
                  }
                }
                if (e4.isCallExpression()) {
                  const r4 = e4.get("callee");
                  let a2, o2;
                  if (r4.isIdentifier() && !e4.scope.getBinding(r4.node.name) && s(r4.node.name) && (o2 = n2.g[r4.node.name]), r4.isMemberExpression()) {
                    const e5 = r4.get("object"), t5 = r4.get("property");
                    if (e5.isIdentifier() && t5.isIdentifier() && s(e5.node.name) && !function(e6) {
                      return i.includes(e6);
                    }(t5.node.name) && (a2 = n2.g[e5.node.name], o2 = a2[t5.node.name]), e5.isLiteral() && t5.isIdentifier()) {
                      const n3 = typeof e5.node.value;
                      "string" !== n3 && "number" !== n3 || (a2 = e5.node.value, o2 = a2[t5.node.name]);
                    }
                  }
                  if (o2) {
                    const n3 = e4.get("arguments").map((e5) => l(e5, t4));
                    if (!t4.confident) return;
                    return o2.apply(a2, n3);
                  }
                }
                a(e4, t4);
              }
            }(e3, t3);
            return t3.confident && (p.resolved = true, p.value = h), h;
          }
        }
        function c(e3, t3, n3, r3 = false) {
          let i2 = "", s2 = 0;
          const a2 = e3.isTemplateLiteral() ? e3.get("expressions") : e3.get("quasi.expressions");
          for (const e4 of t3) {
            if (!n3.confident) break;
            i2 += r3 ? e4.value.raw : e4.value.cooked;
            const t4 = a2[s2++];
            t4 && (i2 += String(l(t4, n3)));
          }
          if (n3.confident) return i2;
        }
      }, 5983: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2._getKey = function(e3, t3) {
          const n3 = this.node, i2 = n3[e3];
          return Array.isArray(i2) ? i2.map((s2, a2) => r2.default.get({ listKey: e3, parentPath: this, parent: n3, container: i2, key: a2 }).setContext(t3)) : r2.default.get({ parentPath: this, parent: n3, container: n3, key: e3 }).setContext(t3);
        }, t2._getPattern = function(e3, t3) {
          let n3 = this;
          for (const r3 of e3) n3 = "." === r3 ? n3.parentPath : Array.isArray(n3) ? n3[r3] : n3.get(r3, t3);
          return n3;
        }, t2.get = function(e3, t3 = true) {
          true === t3 && (t3 = this.context);
          const n3 = e3.split(".");
          return 1 === n3.length ? this._getKey(e3, t3) : this._getPattern(n3, t3);
        }, t2.getAllNextSiblings = function() {
          let e3 = this.key, t3 = this.getSibling(++e3);
          const n3 = [];
          for (; t3.node; ) n3.push(t3), t3 = this.getSibling(++e3);
          return n3;
        }, t2.getAllPrevSiblings = function() {
          let e3 = this.key, t3 = this.getSibling(--e3);
          const n3 = [];
          for (; t3.node; ) n3.push(t3), t3 = this.getSibling(--e3);
          return n3;
        }, t2.getBindingIdentifierPaths = function(e3 = false, t3 = false) {
          const n3 = [this], r3 = /* @__PURE__ */ Object.create(null);
          for (; n3.length; ) {
            const i2 = n3.shift();
            if (!i2) continue;
            if (!i2.node) continue;
            const a2 = s.keys[i2.node.type];
            if (i2.isIdentifier()) e3 ? (r3[i2.node.name] = r3[i2.node.name] || []).push(i2) : r3[i2.node.name] = i2;
            else if (i2.isExportDeclaration()) {
              const e4 = i2.get("declaration");
              o(e4) && n3.push(e4);
            } else {
              if (t3) {
                if (i2.isFunctionDeclaration()) {
                  n3.push(i2.get("id"));
                  continue;
                }
                if (i2.isFunctionExpression()) continue;
              }
              if (a2) for (let e4 = 0; e4 < a2.length; e4++) {
                const t4 = a2[e4], r4 = i2.get(t4);
                Array.isArray(r4) ? n3.push(...r4) : r4.node && n3.push(r4);
              }
            }
          }
          return r3;
        }, t2.getBindingIdentifiers = function(e3) {
          return s(this.node, e3);
        }, t2.getCompletionRecords = function() {
          return m(this, { canHaveBreak: false, shouldPopulateBreak: false, inCaseClause: false }).map((e3) => e3.path);
        }, t2.getNextSibling = function() {
          return this.getSibling(this.key + 1);
        }, t2.getOpposite = function() {
          return "left" === this.key ? this.getSibling("right") : "right" === this.key ? this.getSibling("left") : null;
        }, t2.getOuterBindingIdentifierPaths = function(e3 = false) {
          return this.getBindingIdentifierPaths(e3, true);
        }, t2.getOuterBindingIdentifiers = function(e3) {
          return a(this.node, e3);
        }, t2.getPrevSibling = function() {
          return this.getSibling(this.key - 1);
        }, t2.getSibling = function(e3) {
          return r2.default.get({ parentPath: this.parentPath, parent: this.parent, container: this.container, listKey: this.listKey, key: e3 }).setContext(this.context);
        };
        var r2 = n2(763), i = n2(6067);
        const { getBindingIdentifiers: s, getOuterBindingIdentifiers: a, isDeclaration: o, numericLiteral: l, unaryExpression: c } = i, u = 0, p = 1;
        function h(e3, t3, n3) {
          return e3 && t3.push(...m(e3, n3)), t3;
        }
        function d(e3) {
          e3.forEach((e4) => {
            e4.type = p;
          });
        }
        function f(e3, t3) {
          e3.forEach((e4) => {
            e4.path.isBreakStatement({ label: null }) && (t3 ? e4.path.replaceWith(c("void", l(0))) : e4.path.remove());
          });
        }
        function y(e3, t3) {
          const n3 = [];
          if (t3.canHaveBreak) {
            let r3 = [];
            for (let i2 = 0; i2 < e3.length; i2++) {
              const s2 = e3[i2], a2 = Object.assign({}, t3, { inCaseClause: false });
              s2.isBlockStatement() && (t3.inCaseClause || t3.shouldPopulateBreak) ? a2.shouldPopulateBreak = true : a2.shouldPopulateBreak = false;
              const o2 = m(s2, a2);
              if (o2.length > 0 && o2.every((e4) => e4.type === p)) {
                r3.length > 0 && o2.every((e4) => e4.path.isBreakStatement({ label: null })) ? (d(r3), n3.push(...r3), r3.some((e4) => e4.path.isDeclaration()) && (n3.push(...o2), f(o2, true)), f(o2, false)) : (n3.push(...o2), t3.shouldPopulateBreak || f(o2, true));
                break;
              }
              if (i2 === e3.length - 1) n3.push(...o2);
              else {
                r3 = [];
                for (let e4 = 0; e4 < o2.length; e4++) {
                  const t4 = o2[e4];
                  t4.type === p && n3.push(t4), t4.type === u && r3.push(t4);
                }
              }
            }
          } else if (e3.length) for (let r3 = e3.length - 1; r3 >= 0; r3--) {
            const i2 = m(e3[r3], t3);
            if (i2.length > 1 || 1 === i2.length && !i2[0].path.isVariableDeclaration()) {
              n3.push(...i2);
              break;
            }
          }
          return n3;
        }
        function m(e3, t3) {
          let n3 = [];
          if (e3.isIfStatement()) n3 = h(e3.get("consequent"), n3, t3), n3 = h(e3.get("alternate"), n3, t3);
          else {
            if (e3.isDoExpression() || e3.isFor() || e3.isWhile() || e3.isLabeledStatement()) return h(e3.get("body"), n3, t3);
            if (e3.isProgram() || e3.isBlockStatement()) return y(e3.get("body"), t3);
            if (e3.isFunction()) return m(e3.get("body"), t3);
            if (e3.isTryStatement()) n3 = h(e3.get("block"), n3, t3), n3 = h(e3.get("handler"), n3, t3);
            else {
              if (e3.isCatchClause()) return h(e3.get("body"), n3, t3);
              if (e3.isSwitchStatement()) return function(e4, t4, n4) {
                let r3 = [];
                for (let i2 = 0; i2 < e4.length; i2++) {
                  const s2 = m(e4[i2], n4), a2 = [], o2 = [];
                  for (const e5 of s2) e5.type === u && a2.push(e5), e5.type === p && o2.push(e5);
                  a2.length && (r3 = a2), t4.push(...o2);
                }
                return t4.push(...r3), t4;
              }(e3.get("cases"), n3, t3);
              if (e3.isSwitchCase()) return y(e3.get("consequent"), { canHaveBreak: true, shouldPopulateBreak: false, inCaseClause: true });
              e3.isBreakStatement() ? n3.push(/* @__PURE__ */ function(e4) {
                return { type: p, path: e4 };
              }(e3)) : n3.push(/* @__PURE__ */ function(e4) {
                return { type: u, path: e4 };
              }(e3));
            }
          }
          return n3;
        }
      }, 763: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = t2.SHOULD_STOP = t2.SHOULD_SKIP = t2.REMOVED = void 0;
        var r2 = n2(8176), i = n2(1227), s = n2(5686), a = n2(200), o = n2(6067), l = o, c = n2(9446), u = n2(7848), p = n2(531), h = n2(326), d = n2(383), f = n2(2822), y = n2(6309), m = n2(4989), T = n2(2981), g = n2(1319), b = n2(4825), E = n2(5983), S = n2(1801), P = n2(8745);
        const { validate: x } = o, D = i("babel");
        t2.REMOVED = 1, t2.SHOULD_STOP = 2, t2.SHOULD_SKIP = 4;
        class A {
          constructor(e3, t3) {
            this.contexts = [], this.state = null, this.opts = null, this._traverseFlags = 0, this.skipKeys = null, this.parentPath = null, this.container = null, this.listKey = null, this.key = null, this.node = null, this.type = null, this.parent = t3, this.hub = e3, this.data = null, this.context = null, this.scope = null;
          }
          static get({ hub: e3, parentPath: t3, parent: n3, container: r3, listKey: i2, key: s2 }) {
            if (!e3 && t3 && (e3 = t3.hub), !n3) throw new Error("To get a node path the parent needs to exist");
            const a2 = r3[s2], o2 = c.getOrCreateCachedPaths(e3, n3);
            let l2 = o2.get(a2);
            return l2 || (l2 = new A(e3, n3), a2 && o2.set(a2, l2)), l2.setup(t3, r3, i2, s2), l2;
          }
          getScope(e3) {
            return this.isScope() ? new a.default(this) : e3;
          }
          setData(e3, t3) {
            return null == this.data && (this.data = /* @__PURE__ */ Object.create(null)), this.data[e3] = t3;
          }
          getData(e3, t3) {
            null == this.data && (this.data = /* @__PURE__ */ Object.create(null));
            let n3 = this.data[e3];
            return void 0 === n3 && void 0 !== t3 && (n3 = this.data[e3] = t3), n3;
          }
          hasNode() {
            return null != this.node;
          }
          buildCodeFrameError(e3, t3 = SyntaxError) {
            return this.hub.buildError(this.node, e3, t3);
          }
          traverse(e3, t3) {
            (0, s.default)(this.node, e3, this.scope, t3, this);
          }
          set(e3, t3) {
            x(this.node, e3, t3), this.node[e3] = t3;
          }
          getPathLocation() {
            const e3 = [];
            let t3 = this;
            do {
              let n3 = t3.key;
              t3.inList && (n3 = `${t3.listKey}[${n3}]`), e3.unshift(n3);
            } while (t3 = t3.parentPath);
            return e3.join(".");
          }
          debug(e3) {
            D.enabled && D(`${this.getPathLocation()} ${this.type}: ${e3}`);
          }
          toString() {
            return (0, u.default)(this.node).code;
          }
          get inList() {
            return !!this.listKey;
          }
          set inList(e3) {
            e3 || (this.listKey = null);
          }
          get parentKey() {
            return this.listKey || this.key;
          }
          get shouldSkip() {
            return !!(4 & this._traverseFlags);
          }
          set shouldSkip(e3) {
            e3 ? this._traverseFlags |= 4 : this._traverseFlags &= -5;
          }
          get shouldStop() {
            return !!(2 & this._traverseFlags);
          }
          set shouldStop(e3) {
            e3 ? this._traverseFlags |= 2 : this._traverseFlags &= -3;
          }
          get removed() {
            return !!(1 & this._traverseFlags);
          }
          set removed(e3) {
            e3 ? this._traverseFlags |= 1 : this._traverseFlags &= -2;
          }
        }
        Object.assign(A.prototype, p, h, d, f, y, m, T, g, b, E, S), A.prototype._guessExecutionStatusRelativeToDifferentFunctions = m._guessExecutionStatusRelativeTo;
        for (const e3 of l.TYPES) {
          const t3 = `is${e3}`, n3 = l[t3];
          A.prototype[t3] = function(e4) {
            return n3(this.node, e4);
          }, A.prototype[`assert${e3}`] = function(t4) {
            if (!n3(this.node, t4)) throw new TypeError(`Expected node path of type ${e3}`);
          };
        }
        Object.assign(A.prototype, P);
        for (const e3 of Object.keys(r2)) "_" !== e3[0] && (l.TYPES.includes(e3) || l.TYPES.push(e3));
        var v = A;
        t2.default = v;
      }, 326: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2._getTypeAnnotation = function() {
          const e3 = this.node;
          if (e3) {
            if (e3.typeAnnotation) return e3.typeAnnotation;
            if (!A.has(e3)) {
              A.add(e3);
              try {
                var t3;
                let n3 = r2[e3.type];
                if (n3) return n3.call(this, e3);
                if (n3 = r2[this.parentPath.type], null != (t3 = n3) && t3.validParent) return this.parentPath.getTypeAnnotation();
              } finally {
                A.delete(e3);
              }
            }
          } else if ("init" === this.key && this.parentPath.isVariableDeclarator()) {
            const e4 = this.parentPath.parentPath, t4 = e4.parentPath;
            return "left" === e4.key && t4.isForInStatement() ? x() : "left" === e4.key && t4.isForOfStatement() ? s() : D();
          }
        }, t2.baseTypeStrictlyMatches = function(e3) {
          const t3 = this.getTypeAnnotation(), n3 = e3.getTypeAnnotation();
          return !(a(t3) || !u(t3)) && n3.type === t3.type;
        }, t2.couldBeBaseType = function(e3) {
          const t3 = this.getTypeAnnotation();
          if (a(t3)) return true;
          if (S(t3)) {
            for (const n3 of t3.types) if (a(n3) || v(e3, n3, true)) return true;
            return false;
          }
          return v(e3, t3, true);
        }, t2.getTypeAnnotation = function() {
          let e3 = this.getData("typeAnnotation");
          return null != e3 || (e3 = this._getTypeAnnotation() || s(), (E(e3) || T(e3)) && (e3 = e3.typeAnnotation), this.setData("typeAnnotation", e3)), e3;
        }, t2.isBaseType = function(e3, t3) {
          return v(e3, this.getTypeAnnotation(), t3);
        }, t2.isGenericType = function(e3) {
          const t3 = this.getTypeAnnotation();
          return !("Array" !== e3 || !(m(t3) || o(t3) || b(t3))) || (p(t3) && h(t3.id, { name: e3 }) || g(t3) && h(t3.typeName, { name: e3 }));
        };
        var r2 = n2(3239), i = n2(6067);
        const { anyTypeAnnotation: s, isAnyTypeAnnotation: a, isArrayTypeAnnotation: o, isBooleanTypeAnnotation: l, isEmptyTypeAnnotation: c, isFlowBaseAnnotation: u, isGenericTypeAnnotation: p, isIdentifier: h, isMixedTypeAnnotation: d, isNumberTypeAnnotation: f, isStringTypeAnnotation: y, isTSArrayType: m, isTSTypeAnnotation: T, isTSTypeReference: g, isTupleTypeAnnotation: b, isTypeAnnotation: E, isUnionTypeAnnotation: S, isVoidTypeAnnotation: P, stringTypeAnnotation: x, voidTypeAnnotation: D } = i, A = /* @__PURE__ */ new WeakSet();
        function v(e3, t3, n3) {
          if ("string" === e3) return y(t3);
          if ("number" === e3) return f(t3);
          if ("boolean" === e3) return l(t3);
          if ("any" === e3) return a(t3);
          if ("mixed" === e3) return d(t3);
          if ("empty" === e3) return c(t3);
          if ("void" === e3) return P(t3);
          if (n3) return false;
          throw new Error(`Unknown base type ${e3}`);
        }
      }, 475: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
          if (!this.isReferenced()) return;
          const t3 = this.scope.getBinding(e3.name);
          return t3 ? t3.identifier.typeAnnotation ? t3.identifier.typeAnnotation : function(e4, t4, n3) {
            const r3 = [], s2 = [];
            let a2 = c(e4, t4, s2);
            const o2 = p(e4, t4, n3);
            if (o2) {
              const t5 = c(e4, o2.ifStatement);
              a2 = a2.filter((e5) => t5.indexOf(e5) < 0), r3.push(o2.typeAnnotation);
            }
            if (a2.length) {
              a2.push(...s2);
              for (const e5 of a2) r3.push(e5.getTypeAnnotation());
            }
            if (r3.length) return (0, i.createUnionType)(r3);
          }(t3, this, e3.name) : "undefined" === e3.name ? l() : "NaN" === e3.name || "Infinity" === e3.name ? o() : void e3.name;
        };
        var r2 = n2(6067), i = n2(5193);
        const { BOOLEAN_NUMBER_BINARY_OPERATORS: s, createTypeAnnotationBasedOnTypeof: a, numberTypeAnnotation: o, voidTypeAnnotation: l } = r2;
        function c(e3, t3, n3) {
          const r3 = e3.constantViolations.slice();
          return r3.unshift(e3.path), r3.filter((e4) => {
            const r4 = (e4 = e4.resolve())._guessExecutionStatusRelativeTo(t3);
            return n3 && "unknown" === r4 && n3.push(e4), "before" === r4;
          });
        }
        function u(e3, t3) {
          const n3 = t3.node.operator, r3 = t3.get("right").resolve(), i2 = t3.get("left").resolve();
          let l2, c2, u2;
          if (i2.isIdentifier({ name: e3 }) ? l2 = r3 : r3.isIdentifier({ name: e3 }) && (l2 = i2), l2) return "===" === n3 ? l2.getTypeAnnotation() : s.indexOf(n3) >= 0 ? o() : void 0;
          if ("===" !== n3 && "==" !== n3) return;
          if (i2.isUnaryExpression({ operator: "typeof" }) ? (c2 = i2, u2 = r3) : r3.isUnaryExpression({ operator: "typeof" }) && (c2 = r3, u2 = i2), !c2) return;
          if (!c2.get("argument").isIdentifier({ name: e3 })) return;
          if (u2 = u2.resolve(), !u2.isLiteral()) return;
          const p2 = u2.node.value;
          return "string" == typeof p2 ? a(p2) : void 0;
        }
        function p(e3, t3, n3) {
          const r3 = function(e4, t4, n4) {
            let r4;
            for (; r4 = t4.parentPath; ) {
              if (r4.isIfStatement() || r4.isConditionalExpression()) {
                if ("test" === t4.key) return;
                return r4;
              }
              if (r4.isFunction() && r4.parentPath.scope.getBinding(n4) !== e4) return;
              t4 = r4;
            }
          }(e3, t3, n3);
          if (!r3) return;
          const s2 = [r3.get("test")], a2 = [];
          for (let e4 = 0; e4 < s2.length; e4++) {
            const t4 = s2[e4];
            if (t4.isLogicalExpression()) "&&" === t4.node.operator && (s2.push(t4.get("left")), s2.push(t4.get("right")));
            else if (t4.isBinaryExpression()) {
              const e5 = u(n3, t4);
              e5 && a2.push(e5);
            }
          }
          return a2.length ? { typeAnnotation: (0, i.createUnionType)(a2), ifStatement: r3 } : p(e3, r3, n3);
        }
      }, 3239: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.ArrayExpression = v, t2.AssignmentExpression = function() {
          return this.get("right").getTypeAnnotation();
        }, t2.BinaryExpression = function(e3) {
          const t3 = e3.operator;
          if (l.indexOf(t3) >= 0) return g();
          if (a.indexOf(t3) >= 0) return d();
          if ("+" === t3) {
            const e4 = this.get("right"), t4 = this.get("left");
            return t4.isBaseType("number") && e4.isBaseType("number") ? g() : t4.isBaseType("string") || e4.isBaseType("string") ? b() : S([b(), g()]);
          }
        }, t2.BooleanLiteral = function() {
          return d();
        }, t2.CallExpression = function() {
          const { callee: e3 } = this.node;
          return O(e3) ? h(b()) : w(e3) || I(e3) || x(e3, { name: "Array" }) ? h(p()) : N(e3) ? h(E([b(), p()])) : F(this.get("callee"));
        }, t2.ConditionalExpression = function() {
          const e3 = [this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()];
          return (0, s.createUnionType)(e3);
        }, t2.ClassDeclaration = t2.ClassExpression = t2.FunctionDeclaration = t2.ArrowFunctionExpression = t2.FunctionExpression = function() {
          return y(m("Function"));
        }, Object.defineProperty(t2, "Identifier", { enumerable: true, get: function() {
          return i.default;
        } }), t2.LogicalExpression = function() {
          const e3 = [this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()];
          return (0, s.createUnionType)(e3);
        }, t2.NewExpression = function(e3) {
          if ("Identifier" === e3.callee.type) return y(e3.callee);
        }, t2.NullLiteral = function() {
          return T();
        }, t2.NumericLiteral = function() {
          return g();
        }, t2.ObjectExpression = function() {
          return y(m("Object"));
        }, t2.ParenthesizedExpression = function() {
          return this.get("expression").getTypeAnnotation();
        }, t2.RegExpLiteral = function() {
          return y(m("RegExp"));
        }, t2.RestElement = C, t2.SequenceExpression = function() {
          return this.get("expressions").pop().getTypeAnnotation();
        }, t2.StringLiteral = function() {
          return b();
        }, t2.TSAsExpression = A, t2.TSNonNullExpression = function() {
          return this.get("expression").getTypeAnnotation();
        }, t2.TaggedTemplateExpression = function() {
          return F(this.get("tag"));
        }, t2.TemplateLiteral = function() {
          return b();
        }, t2.TypeCastExpression = D, t2.UnaryExpression = function(e3) {
          const t3 = e3.operator;
          return "void" === t3 ? P() : c.indexOf(t3) >= 0 ? g() : u.indexOf(t3) >= 0 ? b() : o.indexOf(t3) >= 0 ? d() : void 0;
        }, t2.UpdateExpression = function(e3) {
          const t3 = e3.operator;
          if ("++" === t3 || "--" === t3) return g();
        }, t2.VariableDeclarator = function() {
          if (this.get("id").isIdentifier()) return this.get("init").getTypeAnnotation();
        };
        var r2 = n2(6067), i = n2(475), s = n2(5193);
        const { BOOLEAN_BINARY_OPERATORS: a, BOOLEAN_UNARY_OPERATORS: o, NUMBER_BINARY_OPERATORS: l, NUMBER_UNARY_OPERATORS: c, STRING_UNARY_OPERATORS: u, anyTypeAnnotation: p, arrayTypeAnnotation: h, booleanTypeAnnotation: d, buildMatchMemberExpression: f, genericTypeAnnotation: y, identifier: m, nullLiteralTypeAnnotation: T, numberTypeAnnotation: g, stringTypeAnnotation: b, tupleTypeAnnotation: E, unionTypeAnnotation: S, voidTypeAnnotation: P, isIdentifier: x } = r2;
        function D(e3) {
          return e3.typeAnnotation;
        }
        function A(e3) {
          return e3.typeAnnotation;
        }
        function v() {
          return y(m("Array"));
        }
        function C() {
          return v();
        }
        D.validParent = true, A.validParent = true, C.validParent = true;
        const w = f("Array.from"), O = f("Object.keys"), I = f("Object.values"), N = f("Object.entries");
        function F(e3) {
          if ((e3 = e3.resolve()).isFunction()) {
            const { node: t3 } = e3;
            if (t3.async) return t3.generator ? y(m("AsyncIterator")) : y(m("Promise"));
            if (t3.generator) return y(m("Iterator"));
            if (e3.node.returnType) return e3.node.returnType;
          }
        }
      }, 5193: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.createUnionType = function(e3) {
          return o(e3[0]) ? i ? i(e3) : a(e3) : s ? s(e3) : void 0;
        };
        var r2 = n2(6067);
        const { createFlowUnionType: i, createTSUnionType: s, createUnionTypeAnnotation: a, isFlowType: o, isTSType: l } = r2;
      }, 4989: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2._guessExecutionStatusRelativeTo = function(e3) {
          return b(this, e3, /* @__PURE__ */ new Map());
        }, t2._resolve = function(e3, t3) {
          if (!(t3 && t3.indexOf(this) >= 0)) if ((t3 = t3 || []).push(this), this.isVariableDeclarator()) {
            if (this.get("id").isIdentifier()) return this.get("init").resolve(e3, t3);
          } else if (this.isReferencedIdentifier()) {
            const n3 = this.scope.getBinding(this.node.name);
            if (!n3) return;
            if (!n3.constant) return;
            if ("module" === n3.kind) return;
            if (n3.path !== this) {
              const r3 = n3.path.resolve(e3, t3);
              if (this.find((e4) => e4.node === r3.node)) return;
              return r3;
            }
          } else {
            if (this.isTypeCastExpression()) return this.get("expression").resolve(e3, t3);
            if (e3 && this.isMemberExpression()) {
              const n3 = this.toComputedKey();
              if (!c(n3)) return;
              const r3 = n3.value, i2 = this.get("object").resolve(e3, t3);
              if (i2.isObjectExpression()) {
                const n4 = i2.get("properties");
                for (const i3 of n4) {
                  if (!i3.isProperty()) continue;
                  const n5 = i3.get("key");
                  let s2 = i3.isnt("computed") && n5.isIdentifier({ name: r3 });
                  if (s2 = s2 || n5.isLiteral({ value: r3 }), s2) return i3.get("value").resolve(e3, t3);
                }
              } else if (i2.isArrayExpression() && !isNaN(+r3)) {
                const n4 = i2.get("elements")[r3];
                if (n4) return n4.resolve(e3, t3);
              }
            }
          }
        }, t2.canHaveVariableDeclarationOrExpression = function() {
          return ("init" === this.key || "left" === this.key) && this.parentPath.isFor();
        }, t2.canSwapBetweenExpressionAndStatement = function(e3) {
          return !("body" !== this.key || !this.parentPath.isArrowFunctionExpression()) && (this.isExpression() ? a(e3) : !!this.isBlockStatement() && o(e3));
        }, t2.equals = function(e3, t3) {
          return this.node[e3] === t3;
        }, t2.getSource = function() {
          const e3 = this.node;
          if (e3.end) {
            const t3 = this.hub.getCode();
            if (t3) return t3.slice(e3.start, e3.end);
          }
          return "";
        }, t2.has = d, t2.is = void 0, t2.isCompletionRecord = function(e3) {
          let t3 = this, n3 = true;
          do {
            const { type: r3, container: i2 } = t3;
            if (!n3 && (t3.isFunction() || "StaticBlock" === r3)) return !!e3;
            if (n3 = false, Array.isArray(i2) && t3.key !== i2.length - 1) return false;
          } while ((t3 = t3.parentPath) && !t3.isProgram() && !t3.isDoExpression());
          return true;
        }, t2.isConstantExpression = function() {
          if (this.isIdentifier()) {
            const e3 = this.scope.getBinding(this.node.name);
            return !!e3 && e3.constant;
          }
          if (this.isLiteral()) return !this.isRegExpLiteral() && (!this.isTemplateLiteral() || this.get("expressions").every((e3) => e3.isConstantExpression()));
          if (this.isUnaryExpression()) return "void" === this.node.operator && this.get("argument").isConstantExpression();
          if (this.isBinaryExpression()) {
            const { operator: e3 } = this.node;
            return "in" !== e3 && "instanceof" !== e3 && this.get("left").isConstantExpression() && this.get("right").isConstantExpression();
          }
          return false;
        }, t2.isInStrictMode = function() {
          return !!(this.isProgram() ? this : this.parentPath).find((e3) => {
            if (e3.isProgram({ sourceType: "module" })) return true;
            if (e3.isClass()) return true;
            if (e3.isArrowFunctionExpression() && !e3.get("body").isBlockStatement()) return false;
            let t3;
            if (e3.isFunction()) t3 = e3.node.body;
            else {
              if (!e3.isProgram()) return false;
              t3 = e3.node;
            }
            for (const e4 of t3.directives) if ("use strict" === e4.value.value) return true;
          });
        }, t2.isNodeType = function(e3) {
          return p(this.type, e3);
        }, t2.isStatementOrBlock = function() {
          return !this.parentPath.isLabeledStatement() && !a(this.container) && i.includes(this.key);
        }, t2.isStatic = function() {
          return this.scope.isStatic(this.node);
        }, t2.isnt = function(e3) {
          return !this.has(e3);
        }, t2.matchesPattern = function(e3, t3) {
          return h(this.node, e3, t3);
        }, t2.referencesImport = function(e3, t3) {
          if (!this.isReferencedIdentifier()) {
            if (this.isJSXMemberExpression() && this.node.property.name === t3 || (this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? u(this.node.property, { value: t3 }) : this.node.property.name === t3)) {
              const t4 = this.get("object");
              return t4.isReferencedIdentifier() && t4.referencesImport(e3, "*");
            }
            return false;
          }
          const n3 = this.scope.getBinding(this.node.name);
          if (!n3 || "module" !== n3.kind) return false;
          const r3 = n3.path, i2 = r3.parentPath;
          return !!i2.isImportDeclaration() && (i2.node.source.value === e3 && (!t3 || (!(!r3.isImportDefaultSpecifier() || "default" !== t3) || (!(!r3.isImportNamespaceSpecifier() || "*" !== t3) || !(!r3.isImportSpecifier() || !l(r3.node.imported, { name: t3 }))))));
        }, t2.resolve = function(e3, t3) {
          return this._resolve(e3, t3) || this;
        }, t2.willIMaybeExecuteBefore = function(e3) {
          return "after" !== this._guessExecutionStatusRelativeTo(e3);
        };
        var r2 = n2(6067);
        const { STATEMENT_OR_BLOCK_KEYS: i, VISITOR_KEYS: s, isBlockStatement: a, isExpression: o, isIdentifier: l, isLiteral: c, isStringLiteral: u, isType: p, matchesPattern: h } = r2;
        function d(e3) {
          const t3 = this.node && this.node[e3];
          return t3 && Array.isArray(t3) ? !!t3.length : !!t3;
        }
        const f = d;
        function y(e3) {
          return e3.isProgram() ? e3 : (e3.parentPath.scope.getFunctionParent() || e3.parentPath.scope.getProgramParent()).path;
        }
        function m(e3, t3) {
          switch (e3) {
            case "LogicalExpression":
            case "AssignmentPattern":
              return "right" === t3;
            case "ConditionalExpression":
            case "IfStatement":
              return "consequent" === t3 || "alternate" === t3;
            case "WhileStatement":
            case "DoWhileStatement":
            case "ForInStatement":
            case "ForOfStatement":
              return "body" === t3;
            case "ForStatement":
              return "body" === t3 || "update" === t3;
            case "SwitchStatement":
              return "cases" === t3;
            case "TryStatement":
              return "handler" === t3;
            case "OptionalMemberExpression":
              return "property" === t3;
            case "OptionalCallExpression":
              return "arguments" === t3;
            default:
              return false;
          }
        }
        function T(e3, t3) {
          for (let n3 = 0; n3 < t3; n3++) {
            const t4 = e3[n3];
            if (m(t4.parent.type, t4.parentKey)) return true;
          }
          return false;
        }
        t2.is = f;
        const g = Symbol();
        function b(e3, t3, n3) {
          const r3 = { this: y(e3), target: y(t3) };
          if (r3.target.node !== r3.this.node) return function(e4, t4, n4) {
            let r4, i3 = n4.get(e4.node);
            if (i3) {
              if (r4 = i3.get(t4.node)) return r4 === g ? "unknown" : r4;
            } else n4.set(e4.node, i3 = /* @__PURE__ */ new Map());
            i3.set(t4.node, g);
            const s2 = function(e5, t5, n5) {
              if (!t5.isFunctionDeclaration()) return "before" === b(e5, t5, n5) ? "before" : "unknown";
              if (t5.parentPath.isExportDeclaration()) return "unknown";
              const r5 = t5.scope.getBinding(t5.node.id.name);
              if (!r5.references) return "before";
              const i4 = r5.referencePaths;
              let s3;
              for (const r6 of i4) {
                if (r6.find((e6) => e6.node === t5.node)) continue;
                if ("callee" !== r6.key || !r6.parentPath.isCallExpression()) return "unknown";
                const i5 = b(e5, r6, n5);
                if (s3 && s3 !== i5) return "unknown";
                s3 = i5;
              }
              return s3;
            }(e4, t4, n4);
            return i3.set(t4.node, s2), s2;
          }(e3, r3.target, n3);
          const i2 = { target: t3.getAncestry(), this: e3.getAncestry() };
          if (i2.target.indexOf(e3) >= 0) return "after";
          if (i2.this.indexOf(t3) >= 0) return "before";
          let a2;
          const o2 = { target: 0, this: 0 };
          for (; !a2 && o2.this < i2.this.length; ) {
            const e4 = i2.this[o2.this];
            o2.target = i2.target.indexOf(e4), o2.target >= 0 ? a2 = e4 : o2.this++;
          }
          if (!a2) throw new Error("Internal Babel error - The two compared nodes don't appear to belong to the same program.");
          if (T(i2.this, o2.this - 1) || T(i2.target, o2.target - 1)) return "unknown";
          const l2 = { this: i2.this[o2.this - 1], target: i2.target[o2.target - 1] };
          if (l2.target.listKey && l2.this.listKey && l2.target.container === l2.this.container) return l2.target.key > l2.this.key ? "before" : "after";
          const c2 = s[a2.type], u2 = c2.indexOf(l2.this.parentKey);
          return c2.indexOf(l2.target.parentKey) > u2 ? "before" : "after";
        }
      }, 6698: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var r2 = n2(6067), i = r2;
        const { react: s } = r2, { cloneNode: a, jsxExpressionContainer: o, variableDeclaration: l, variableDeclarator: c } = i, u = { ReferencedIdentifier(e3, t3) {
          if (e3.isJSXIdentifier() && s.isCompatTag(e3.node.name) && !e3.parentPath.isJSXMemberExpression()) return;
          if ("this" === e3.node.name) {
            let n4 = e3.scope;
            do {
              if (n4.path.isFunction() && !n4.path.isArrowFunctionExpression()) break;
            } while (n4 = n4.parent);
            n4 && t3.breakOnScopePaths.push(n4.path);
          }
          const n3 = e3.scope.getBinding(e3.node.name);
          if (n3) {
            for (const r3 of n3.constantViolations) if (r3.scope !== n3.path.scope) return t3.mutableBinding = true, void e3.stop();
            n3 === t3.scope.getBinding(e3.node.name) && (t3.bindings[e3.node.name] = n3);
          }
        } };
        t2.default = class {
          constructor(e3, t3) {
            this.breakOnScopePaths = void 0, this.bindings = void 0, this.mutableBinding = void 0, this.scopes = void 0, this.scope = void 0, this.path = void 0, this.attachAfter = void 0, this.breakOnScopePaths = [], this.bindings = {}, this.mutableBinding = false, this.scopes = [], this.scope = t3, this.path = e3, this.attachAfter = false;
          }
          isCompatibleScope(e3) {
            for (const t3 of Object.keys(this.bindings)) {
              const n3 = this.bindings[t3];
              if (!e3.bindingIdentifierEquals(t3, n3.identifier)) return false;
            }
            return true;
          }
          getCompatibleScopes() {
            let e3 = this.path.scope;
            do {
              if (!this.isCompatibleScope(e3)) break;
              if (this.scopes.push(e3), this.breakOnScopePaths.indexOf(e3.path) >= 0) break;
            } while (e3 = e3.parent);
          }
          getAttachmentPath() {
            let e3 = this._getAttachmentPath();
            if (!e3) return;
            let t3 = e3.scope;
            if (t3.path === e3 && (t3 = e3.scope.parent), t3.path.isProgram() || t3.path.isFunction()) for (const n3 of Object.keys(this.bindings)) {
              if (!t3.hasOwnBinding(n3)) continue;
              const r3 = this.bindings[n3];
              if ("param" !== r3.kind && "params" !== r3.path.parentKey && this.getAttachmentParentForPath(r3.path).key >= e3.key) {
                this.attachAfter = true, e3 = r3.path;
                for (const t4 of r3.constantViolations) this.getAttachmentParentForPath(t4).key > e3.key && (e3 = t4);
              }
            }
            return e3;
          }
          _getAttachmentPath() {
            const e3 = this.scopes.pop();
            if (e3) {
              if (e3.path.isFunction()) {
                if (!this.hasOwnParamBindings(e3)) return this.getNextScopeAttachmentParent();
                {
                  if (this.scope === e3) return;
                  const t3 = e3.path.get("body").get("body");
                  for (let e4 = 0; e4 < t3.length; e4++) if (!t3[e4].node._blockHoist) return t3[e4];
                }
              } else if (e3.path.isProgram()) return this.getNextScopeAttachmentParent();
            }
          }
          getNextScopeAttachmentParent() {
            const e3 = this.scopes.pop();
            if (e3) return this.getAttachmentParentForPath(e3.path);
          }
          getAttachmentParentForPath(e3) {
            do {
              if (!e3.parentPath || Array.isArray(e3.container) && e3.isStatement()) return e3;
            } while (e3 = e3.parentPath);
          }
          hasOwnParamBindings(e3) {
            for (const t3 of Object.keys(this.bindings)) {
              if (!e3.hasOwnBinding(t3)) continue;
              const n3 = this.bindings[t3];
              if ("param" === n3.kind && n3.constant) return true;
            }
            return false;
          }
          run() {
            if (this.path.traverse(u, this), this.mutableBinding) return;
            this.getCompatibleScopes();
            const e3 = this.getAttachmentPath();
            if (!e3) return;
            if (e3.getFunctionParent() === this.path.getFunctionParent()) return;
            let t3 = e3.scope.generateUidIdentifier("ref");
            const n3 = c(t3, this.path.node), r3 = this.attachAfter ? "insertAfter" : "insertBefore", [i2] = e3[r3]([e3.isVariableDeclarator() ? n3 : l("var", [n3])]), s2 = this.path.parentPath;
            return s2.isJSXElement() && this.path.container === s2.node.children && (t3 = o(t3)), this.path.replaceWith(a(t3)), e3.isVariableDeclarator() ? i2.get("init") : i2.get("declarations.0.init");
          }
        };
      }, 308: (e2, t2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.hooks = void 0, t2.hooks = [function(e3, t3) {
          if ("test" === e3.key && (t3.isWhile() || t3.isSwitchCase()) || "declaration" === e3.key && t3.isExportDeclaration() || "body" === e3.key && t3.isLabeledStatement() || "declarations" === e3.listKey && t3.isVariableDeclaration() && 1 === t3.node.declarations.length || "expression" === e3.key && t3.isExpressionStatement()) return t3.remove(), true;
        }, function(e3, t3) {
          if (t3.isSequenceExpression() && 1 === t3.node.expressions.length) return t3.replaceWith(t3.node.expressions[0]), true;
        }, function(e3, t3) {
          if (t3.isBinary()) return "left" === e3.key ? t3.replaceWith(t3.node.right) : t3.replaceWith(t3.node.left), true;
        }, function(e3, t3) {
          if (t3.isIfStatement() && "consequent" === e3.key || "body" === e3.key && (t3.isLoop() || t3.isArrowFunctionExpression())) return e3.replaceWith({ type: "BlockStatement", body: [] }), true;
        }];
      }, 8745: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.isBindingIdentifier = function() {
          const { node: e3, parent: t3 } = this, n3 = this.parentPath.parent;
          return p(e3) && i(e3, t3, n3);
        }, t2.isBlockScoped = function() {
          return s(this.node);
        }, t2.isExpression = function() {
          return this.isIdentifier() ? this.isReferencedIdentifier() : o(this.node);
        }, t2.isFlow = function() {
          const { node: e3 } = this;
          return !(!l(e3) && (h(e3) ? "type" !== e3.importKind && "typeof" !== e3.importKind : a(e3) ? "type" !== e3.exportKind : !d(e3) || "type" !== e3.importKind && "typeof" !== e3.importKind));
        }, t2.isForAwaitStatement = function() {
          return D(this.node, { await: true });
        }, t2.isGenerated = function() {
          return !this.isUser();
        }, t2.isPure = function(e3) {
          return this.scope.isPure(this.node, e3);
        }, t2.isReferenced = function() {
          return g(this.node, this.parent);
        }, t2.isReferencedIdentifier = function(e3) {
          const { node: t3, parent: n3 } = this;
          if (!p(t3, e3) && !y(n3, e3)) {
            if (!f(t3, e3)) return false;
            if (A(t3.name)) return false;
          }
          return g(t3, n3, this.parentPath.parent);
        }, t2.isReferencedMemberExpression = function() {
          const { node: e3, parent: t3 } = this;
          return m(e3) && g(e3, t3);
        }, t2.isRestProperty = function() {
          return T(this.node) && this.parentPath && this.parentPath.isObjectPattern();
        }, t2.isScope = function() {
          return b(this.node, this.parent);
        }, t2.isSpreadProperty = function() {
          return T(this.node) && this.parentPath && this.parentPath.isObjectExpression();
        }, t2.isStatement = function() {
          const { node: e3, parent: t3 } = this;
          if (E(e3)) {
            if (P(e3)) {
              if (u(t3, { left: e3 })) return false;
              if (c(t3, { init: e3 })) return false;
            }
            return true;
          }
          return false;
        }, t2.isUser = function() {
          return this.node && !!this.node.loc;
        }, t2.isVar = function() {
          return S(this.node);
        };
        var r2 = n2(6067);
        const { isBinding: i, isBlockScoped: s, isExportDeclaration: a, isExpression: o, isFlow: l, isForStatement: c, isForXStatement: u, isIdentifier: p, isImportDeclaration: h, isImportSpecifier: d, isJSXIdentifier: f, isJSXMemberExpression: y, isMemberExpression: m, isRestElement: T, isReferenced: g, isScope: b, isStatement: E, isVar: S, isVariableDeclaration: P, react: x, isForOfStatement: D } = r2, { isCompatTag: A } = x;
        t2.isExistentialTypeParam = function() {
          throw new Error("`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.");
        }, t2.isNumericLiteralTypeAnnotation = function() {
          throw new Error("`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.");
        };
      }, 8176: (e2, t2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.Var = t2.User = t2.Statement = t2.SpreadProperty = t2.Scope = t2.RestProperty = t2.ReferencedMemberExpression = t2.ReferencedIdentifier = t2.Referenced = t2.Pure = t2.NumericLiteralTypeAnnotation = t2.Generated = t2.ForAwaitStatement = t2.Flow = t2.Expression = t2.ExistentialTypeParam = t2.BlockScoped = t2.BindingIdentifier = void 0, t2.ReferencedIdentifier = ["Identifier", "JSXIdentifier"], t2.ReferencedMemberExpression = ["MemberExpression"], t2.BindingIdentifier = ["Identifier"], t2.Statement = ["Statement"], t2.Expression = ["Expression"], t2.Scope = ["Scopable", "Pattern"], t2.Referenced = null, t2.BlockScoped = null, t2.Var = ["VariableDeclaration"], t2.User = null, t2.Generated = null, t2.Pure = null, t2.Flow = ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"], t2.RestProperty = ["RestElement"], t2.SpreadProperty = ["RestElement"], t2.ExistentialTypeParam = ["ExistsTypeAnnotation"], t2.NumericLiteralTypeAnnotation = ["NumberLiteralTypeAnnotation"], t2.ForAwaitStatement = ["ForOfStatement"];
      }, 4825: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2._containerInsert = function(e3, t3) {
          this.updateSiblingKeys(e3, t3.length);
          const n3 = [];
          this.container.splice(e3, 0, ...t3);
          for (let i3 = 0; i3 < t3.length; i3++) {
            var r3;
            const t4 = e3 + i3, s2 = this.getSibling(t4);
            n3.push(s2), null != (r3 = this.context) && r3.queue && s2.pushContext(this.context);
          }
          const i2 = this._getQueueContexts();
          for (const e4 of n3) {
            e4.setScope(), e4.debug("Inserted.");
            for (const t4 of i2) t4.maybeQueue(e4, true);
          }
          return n3;
        }, t2._containerInsertAfter = function(e3) {
          return this._containerInsert(this.key + 1, e3);
        }, t2._containerInsertBefore = function(e3) {
          return this._containerInsert(this.key, e3);
        }, t2._verifyNodeList = function(e3) {
          if (!e3) return [];
          Array.isArray(e3) || (e3 = [e3]);
          for (let t3 = 0; t3 < e3.length; t3++) {
            const n3 = e3[t3];
            let r3;
            if (n3 ? "object" != typeof n3 ? r3 = "contains a non-object node" : n3.type ? n3 instanceof s.default && (r3 = "has a NodePath when it expected a raw object") : r3 = "without a type" : r3 = "has falsy node", r3) {
              const e4 = Array.isArray(n3) ? "array" : typeof n3;
              throw new Error(`Node list ${r3} with the index of ${t3} and type of ${e4}`);
            }
          }
          return e3;
        }, t2.hoist = function(e3 = this.scope) {
          return new i.default(this, e3).run();
        }, t2.insertAfter = function(e3) {
          if (this._assertUnremoved(), this.isSequenceExpression()) return P(this.get("expressions")).insertAfter(e3);
          const t3 = this._verifyNodeList(e3), { parentPath: n3, parent: r3 } = this;
          if (n3.isExpressionStatement() || n3.isLabeledStatement() || m(r3) || n3.isExportDefaultDeclaration() && this.isDeclaration()) return n3.insertAfter(t3.map((e4) => T(e4) ? d(e4) : e4));
          if (this.isNodeType("Expression") && !this.isJSXElement() && !n3.isJSXElement() || n3.isForStatement() && "init" === this.key) {
            if (this.node) {
              const e4 = this.node;
              let { scope: r4 } = this;
              if (r4.path.isPattern()) return l(e4), this.replaceWith(p(o([], e4), [])), this.get("callee.body").insertAfter(t3), [this];
              if (x(this)) t3.unshift(e4);
              else if (y(e4) && E(e4.callee)) t3.unshift(e4), t3.push(S());
              else if (function(e5, t4) {
                if (!f(e5) || !g(e5.left)) return false;
                const n4 = t4.getBlockParent();
                return n4.hasOwnBinding(e5.left.name) && n4.getOwnBinding(e5.left.name).constantViolations.length <= 1;
              }(e4, r4)) t3.unshift(e4), t3.push(h(e4.left));
              else if (r4.isPure(e4, true)) t3.push(e4);
              else {
                n3.isMethod({ computed: true, key: e4 }) && (r4 = r4.parent);
                const i2 = r4.generateDeclaredUidIdentifier();
                t3.unshift(d(c("=", h(i2), e4))), t3.push(d(h(i2)));
              }
            }
            return this.replaceExpressionWithStatements(t3);
          }
          if (Array.isArray(this.container)) return this._containerInsertAfter(t3);
          if (this.isStatementOrBlock()) {
            const e4 = this.node, n4 = e4 && (!this.isExpressionStatement() || null != e4.expression);
            return this.replaceWith(u(n4 ? [e4] : [])), this.pushContainer("body", t3);
          }
          throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
        }, t2.insertBefore = function(e3) {
          this._assertUnremoved();
          const t3 = this._verifyNodeList(e3), { parentPath: n3, parent: r3 } = this;
          if (n3.isExpressionStatement() || n3.isLabeledStatement() || m(r3) || n3.isExportDefaultDeclaration() && this.isDeclaration()) return n3.insertBefore(t3);
          if (this.isNodeType("Expression") && !this.isJSXElement() || n3.isForStatement() && "init" === this.key) return this.node && t3.push(this.node), this.replaceExpressionWithStatements(t3);
          if (Array.isArray(this.container)) return this._containerInsertBefore(t3);
          if (this.isStatementOrBlock()) {
            const e4 = this.node, n4 = e4 && (!this.isExpressionStatement() || null != e4.expression);
            return this.replaceWith(u(n4 ? [e4] : [])), this.unshiftContainer("body", t3);
          }
          throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
        }, t2.pushContainer = function(e3, t3) {
          this._assertUnremoved();
          const n3 = this._verifyNodeList(t3), r3 = this.node[e3];
          return s.default.get({ parentPath: this, parent: this.node, container: r3, listKey: e3, key: r3.length }).setContext(this.context).replaceWithMultiple(n3);
        }, t2.unshiftContainer = function(e3, t3) {
          return this._assertUnremoved(), t3 = this._verifyNodeList(t3), s.default.get({ parentPath: this, parent: this.node, container: this.node[e3], listKey: e3, key: 0 }).setContext(this.context)._containerInsertBefore(t3);
        }, t2.updateSiblingKeys = function(e3, t3) {
          if (!this.parent) return;
          const n3 = (0, r2.getCachedPaths)(this.hub, this.parent) || [];
          for (const [, r3] of n3) "number" == typeof r3.key && r3.key >= e3 && (r3.key += t3);
        };
        var r2 = n2(9446), i = n2(6698), s = n2(763), a = n2(6067);
        const { arrowFunctionExpression: o, assertExpression: l, assignmentExpression: c, blockStatement: u, callExpression: p, cloneNode: h, expressionStatement: d, isAssignmentExpression: f, isCallExpression: y, isExportNamedDeclaration: m, isExpression: T, isIdentifier: g, isSequenceExpression: b, isSuper: E, thisExpression: S } = a, P = (e3) => e3[e3.length - 1];
        function x(e3) {
          return b(e3.parent) && (P(e3.parent.expressions) !== e3.node || x(e3.parentPath));
        }
      }, 1319: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2._assertUnremoved = function() {
          if (this.removed) throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
        }, t2._callRemovalHooks = function() {
          for (const e3 of r2.hooks) if (e3(this, this.parentPath)) return true;
        }, t2._markRemoved = function() {
          this._traverseFlags |= s.SHOULD_SKIP | s.REMOVED, this.parent && (0, i.getCachedPaths)(this.hub, this.parent).delete(this.node), this.node = null;
        }, t2._remove = function() {
          Array.isArray(this.container) ? (this.container.splice(this.key, 1), this.updateSiblingKeys(this.key, -1)) : this._replaceWith(null);
        }, t2._removeFromScope = function() {
          const e3 = this.getBindingIdentifiers();
          Object.keys(e3).forEach((e4) => this.scope.removeBinding(e4));
        }, t2.remove = function() {
          var e3;
          this._assertUnremoved(), this.resync(), null != (e3 = this.opts) && e3.noScope || this._removeFromScope(), this._callRemovalHooks() || (this.shareCommentsWithSiblings(), this._remove()), this._markRemoved();
        };
        var r2 = n2(308), i = n2(9446), s = n2(763);
      }, 383: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2._replaceWith = function(e3) {
          var t3;
          if (!this.container) throw new ReferenceError("Container is falsy");
          this.inList ? w(this.parent, this.key, [e3]) : w(this.parent, this.key, e3), this.debug(`Replace with ${null == e3 ? void 0 : e3.type}`), null == (t3 = (0, a.getCachedPaths)(this.hub, this.parent)) || t3.set(e3, this).delete(this.node), this.node = this.container[this.key] = e3;
        }, t2.replaceExpressionWithStatements = function(e3) {
          this.resync();
          const t3 = C(e3, this.scope);
          if (t3) return this.replaceWith(t3)[0].get("expressions");
          const n3 = this.getFunctionParent(), r3 = null == n3 ? void 0 : n3.is("async"), s2 = null == n3 ? void 0 : n3.is("generator"), a2 = p([], f(e3));
          this.replaceWith(y(a2, []));
          const o2 = this.get("callee");
          (0, c.default)(o2.get("body"), (e4) => {
            this.scope.push({ id: e4 });
          }, "var");
          const l2 = this.get("callee").getCompletionRecords();
          for (const e4 of l2) {
            if (!e4.isExpressionStatement()) continue;
            const t4 = e4.findParent((e5) => e5.isLoop());
            if (t4) {
              let n4 = t4.getData("expressionReplacementReturnUid");
              n4 ? n4 = g(n4.name) : (n4 = o2.scope.generateDeclaredUidIdentifier("ret"), o2.get("body").pushContainer("body", v(m(n4))), t4.setData("expressionReplacementReturnUid", n4)), e4.get("expression").replaceWith(h("=", m(n4), e4.node.expression));
            } else e4.replaceWith(v(e4.node.expression));
          }
          o2.arrowFunctionToExpression();
          const T2 = o2, b2 = r3 && i.default.hasType(this.get("callee.body").node, "AwaitExpression", u), E2 = s2 && i.default.hasType(this.get("callee.body").node, "YieldExpression", u);
          return b2 && (T2.set("async", true), E2 || this.replaceWith(d(this.node))), E2 && (T2.set("generator", true), this.replaceWith(O(this.node, true))), T2.get("body.body");
        }, t2.replaceInline = function(e3) {
          if (this.resync(), Array.isArray(e3)) {
            if (Array.isArray(this.container)) {
              e3 = this._verifyNodeList(e3);
              const t3 = this._containerInsertAfter(e3);
              return this.remove(), t3;
            }
            return this.replaceWithMultiple(e3);
          }
          return this.replaceWith(e3);
        }, t2.replaceWith = function(e3) {
          if (this.resync(), this.removed) throw new Error("You can't replace this node, we've already removed it");
          let t3 = e3 instanceof s.default ? e3.node : e3;
          if (!t3) throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
          if (this.node === t3) return [this];
          if (this.isProgram() && !x(t3)) throw new Error("You can only replace a Program root node with another Program node");
          if (Array.isArray(t3)) throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
          if ("string" == typeof t3) throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
          let n3 = "";
          if (this.isNodeType("Statement") && P(t3) && (this.canHaveVariableDeclarationOrExpression() || this.canSwapBetweenExpressionAndStatement(t3) || this.parentPath.isExportDefaultDeclaration() || (t3 = T(t3), n3 = "expression")), this.isNodeType("Expression") && D(t3) && !this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(t3)) return this.replaceExpressionWithStatements([t3]);
          const r3 = this.node;
          return r3 && (S(t3, r3), A(r3)), this._replaceWith(t3), this.type = t3.type, this.setScope(), this.requeue(), [n3 ? this.get(n3) : this];
        }, t2.replaceWithMultiple = function(e3) {
          var t3;
          this.resync(), e3 = this._verifyNodeList(e3), b(e3[0], this.node), E(e3[e3.length - 1], this.node), null == (t3 = (0, a.getCachedPaths)(this.hub, this.parent)) || t3.delete(this.node), this.node = this.container[this.key] = null;
          const n3 = this.insertAfter(e3);
          return this.node ? this.requeue() : this.remove(), n3;
        }, t2.replaceWithSourceString = function(e3) {
          let t3;
          this.resync();
          try {
            e3 = `(${e3})`, t3 = (0, o.parse)(e3);
          } catch (t4) {
            const n4 = t4.loc;
            throw n4 && (t4.message += " - make sure this is an expression.\n" + (0, r2.codeFrameColumns)(e3, { start: { line: n4.line, column: n4.column + 1 } }), t4.code = "BABEL_REPLACE_SOURCE_ERROR"), t4;
          }
          const n3 = t3.program.body[0].expression;
          return i.default.removeProperties(n3), this.replaceWith(n3);
        };
        var r2 = n2(4704), i = n2(5686), s = n2(763), a = n2(9446), o = n2(7191), l = n2(6067), c = n2(7438);
        const { FUNCTION_TYPES: u, arrowFunctionExpression: p, assignmentExpression: h, awaitExpression: d, blockStatement: f, callExpression: y, cloneNode: m, expressionStatement: T, identifier: g, inheritLeadingComments: b, inheritTrailingComments: E, inheritsComments: S, isExpression: P, isProgram: x, isStatement: D, removeComments: A, returnStatement: v, toSequenceExpression: C, validate: w, yieldExpression: O } = l;
      }, 8670: (e2, t2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0, t2.default = class {
          constructor({ identifier: e3, scope: t3, path: n2, kind: r2 }) {
            this.identifier = void 0, this.scope = void 0, this.path = void 0, this.kind = void 0, this.constantViolations = [], this.constant = true, this.referencePaths = [], this.referenced = false, this.references = 0, this.identifier = e3, this.scope = t3, this.path = n2, this.kind = r2, "var" !== r2 && "hoisted" !== r2 || !function(e4) {
              for (let { parentPath: t4, key: n3 } = e4; t4; { parentPath: t4, key: n3 } = t4) {
                if (t4.isFunctionParent()) return false;
                if (t4.isWhile() || t4.isForXStatement() || t4.isForStatement() && "body" === n3) return true;
              }
              return false;
            }(n2) || this.reassign(n2), this.clearValue();
          }
          deoptValue() {
            this.clearValue(), this.hasDeoptedValue = true;
          }
          setValue(e3) {
            this.hasDeoptedValue || (this.hasValue = true, this.value = e3);
          }
          clearValue() {
            this.hasDeoptedValue = false, this.hasValue = false, this.value = null;
          }
          reassign(e3) {
            this.constant = false, -1 === this.constantViolations.indexOf(e3) && this.constantViolations.push(e3);
          }
          reference(e3) {
            -1 === this.referencePaths.indexOf(e3) && (this.referenced = true, this.references++, this.referencePaths.push(e3));
          }
          dereference() {
            this.references--, this.referenced = !!this.references;
          }
        };
      }, 200: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var r2 = n2(6426), i = n2(5686), s = n2(8670), a = n2(1272), o = n2(6067), l = o, c = n2(9446), u = n2(7380);
        const { NOT_LOCAL_BINDING: p, callExpression: h, cloneNode: d, getBindingIdentifiers: f, identifier: y, isArrayExpression: m, isBinary: T, isClass: g, isClassBody: b, isClassDeclaration: E, isExportAllDeclaration: S, isExportDefaultDeclaration: P, isExportNamedDeclaration: x, isFunctionDeclaration: D, isIdentifier: A, isImportDeclaration: v, isLiteral: C, isMethod: w, isModuleSpecifier: O, isNullLiteral: I, isObjectExpression: N, isProperty: F, isPureish: k, isRegExpLiteral: L, isSuper: _, isTaggedTemplateExpression: M, isTemplateLiteral: B, isThisExpression: j, isUnaryExpression: R, isVariableDeclaration: U, matchesPattern: V, memberExpression: K, numericLiteral: W, toIdentifier: X, unaryExpression: Y, variableDeclaration: q, variableDeclarator: H, isRecordExpression: J, isTupleExpression: $, isObjectProperty: G, isTopicReference: z, isMetaProperty: Q, isPrivateName: Z, isExportDeclaration: ee } = o;
        function te(e3, t3) {
          switch (null == e3 ? void 0 : e3.type) {
            default:
              var n3;
              if (v(e3) || ee(e3)) if ((S(e3) || x(e3) || v(e3)) && e3.source) te(e3.source, t3);
              else if ((x(e3) || v(e3)) && null != (n3 = e3.specifiers) && n3.length) for (const n4 of e3.specifiers) te(n4, t3);
              else (P(e3) || x(e3)) && e3.declaration && te(e3.declaration, t3);
              else O(e3) ? te(e3.local, t3) : !C(e3) || I(e3) || L(e3) || B(e3) || t3.push(e3.value);
              break;
            case "MemberExpression":
            case "OptionalMemberExpression":
            case "JSXMemberExpression":
              te(e3.object, t3), te(e3.property, t3);
              break;
            case "Identifier":
            case "JSXIdentifier":
              t3.push(e3.name);
              break;
            case "CallExpression":
            case "OptionalCallExpression":
            case "NewExpression":
              te(e3.callee, t3);
              break;
            case "ObjectExpression":
            case "ObjectPattern":
              for (const n4 of e3.properties) te(n4, t3);
              break;
            case "SpreadElement":
            case "RestElement":
            case "UnaryExpression":
            case "UpdateExpression":
              te(e3.argument, t3);
              break;
            case "ObjectProperty":
            case "ObjectMethod":
            case "ClassProperty":
            case "ClassMethod":
            case "ClassPrivateProperty":
            case "ClassPrivateMethod":
              te(e3.key, t3);
              break;
            case "ThisExpression":
              t3.push("this");
              break;
            case "Super":
              t3.push("super");
              break;
            case "Import":
              t3.push("import");
              break;
            case "DoExpression":
              t3.push("do");
              break;
            case "YieldExpression":
              t3.push("yield"), te(e3.argument, t3);
              break;
            case "AwaitExpression":
              t3.push("await"), te(e3.argument, t3);
              break;
            case "AssignmentExpression":
              te(e3.left, t3);
              break;
            case "VariableDeclarator":
            case "FunctionExpression":
            case "FunctionDeclaration":
            case "ClassExpression":
            case "ClassDeclaration":
            case "PrivateName":
              te(e3.id, t3);
              break;
            case "ParenthesizedExpression":
              te(e3.expression, t3);
              break;
            case "MetaProperty":
              te(e3.meta, t3), te(e3.property, t3);
              break;
            case "JSXElement":
              te(e3.openingElement, t3);
              break;
            case "JSXOpeningElement":
              te(e3.name, t3);
              break;
            case "JSXFragment":
              te(e3.openingFragment, t3);
              break;
            case "JSXOpeningFragment":
              t3.push("Fragment");
              break;
            case "JSXNamespacedName":
              te(e3.namespace, t3), te(e3.name, t3);
          }
        }
        const ne = { ForStatement(e3) {
          const t3 = e3.get("init");
          if (t3.isVar()) {
            const { scope: n3 } = e3;
            (n3.getFunctionParent() || n3.getProgramParent()).registerBinding("var", t3);
          }
        }, Declaration(e3) {
          e3.isBlockScoped() || e3.isImportDeclaration() || e3.isExportDeclaration() || (e3.scope.getFunctionParent() || e3.scope.getProgramParent()).registerDeclaration(e3);
        }, ImportDeclaration(e3) {
          e3.scope.getBlockParent().registerDeclaration(e3);
        }, ReferencedIdentifier(e3, t3) {
          t3.references.push(e3);
        }, ForXStatement(e3, t3) {
          const n3 = e3.get("left");
          if (n3.isPattern() || n3.isIdentifier()) t3.constantViolations.push(e3);
          else if (n3.isVar()) {
            const { scope: t4 } = e3;
            (t4.getFunctionParent() || t4.getProgramParent()).registerBinding("var", n3);
          }
        }, ExportDeclaration: { exit(e3) {
          const { node: t3, scope: n3 } = e3;
          if (S(t3)) return;
          const r3 = t3.declaration;
          if (E(r3) || D(r3)) {
            const t4 = r3.id;
            if (!t4) return;
            const i2 = n3.getBinding(t4.name);
            null == i2 || i2.reference(e3);
          } else if (U(r3)) for (const t4 of r3.declarations) for (const r4 of Object.keys(f(t4))) {
            const t5 = n3.getBinding(r4);
            null == t5 || t5.reference(e3);
          }
        } }, LabeledStatement(e3) {
          e3.scope.getBlockParent().registerDeclaration(e3);
        }, AssignmentExpression(e3, t3) {
          t3.assignments.push(e3);
        }, UpdateExpression(e3, t3) {
          t3.constantViolations.push(e3);
        }, UnaryExpression(e3, t3) {
          "delete" === e3.node.operator && t3.constantViolations.push(e3);
        }, BlockScoped(e3) {
          let t3 = e3.scope;
          if (t3.path === e3 && (t3 = t3.parent), t3.getBlockParent().registerDeclaration(e3), e3.isClassDeclaration() && e3.node.id) {
            const t4 = e3.node.id.name;
            e3.scope.bindings[t4] = e3.scope.parent.getBinding(t4);
          }
        }, CatchClause(e3) {
          e3.scope.registerBinding("let", e3);
        }, Function(e3) {
          const t3 = e3.get("params");
          for (const n3 of t3) e3.scope.registerBinding("param", n3);
          e3.isFunctionExpression() && e3.has("id") && !e3.get("id").node[p] && e3.scope.registerBinding("local", e3.get("id"), e3);
        }, ClassExpression(e3) {
          e3.has("id") && !e3.get("id").node[p] && e3.scope.registerBinding("local", e3);
        } };
        let re = 0;
        class ie {
          constructor(e3) {
            this.uid = void 0, this.path = void 0, this.block = void 0, this.labels = void 0, this.inited = void 0, this.bindings = void 0, this.references = void 0, this.globals = void 0, this.uids = void 0, this.data = void 0, this.crawling = void 0;
            const { node: t3 } = e3, n3 = c.scope.get(t3);
            if ((null == n3 ? void 0 : n3.path) === e3) return n3;
            c.scope.set(t3, this), this.uid = re++, this.block = t3, this.path = e3, this.labels = /* @__PURE__ */ new Map(), this.inited = false;
          }
          get parent() {
            var e3;
            let t3, n3 = this.path;
            do {
              const e4 = "key" === n3.key || "decorators" === n3.listKey;
              n3 = n3.parentPath, e4 && n3.isMethod() && (n3 = n3.parentPath), n3 && n3.isScope() && (t3 = n3);
            } while (n3 && !t3);
            return null == (e3 = t3) ? void 0 : e3.scope;
          }
          get parentBlock() {
            return this.path.parent;
          }
          get hub() {
            return this.path.hub;
          }
          traverse(e3, t3, n3) {
            (0, i.default)(e3, t3, this, n3, this.path);
          }
          generateDeclaredUidIdentifier(e3) {
            const t3 = this.generateUidIdentifier(e3);
            return this.push({ id: t3 }), d(t3);
          }
          generateUidIdentifier(e3) {
            return y(this.generateUid(e3));
          }
          generateUid(e3 = "temp") {
            let t3;
            e3 = X(e3).replace(/^_+/, "").replace(/[0-9]+$/g, "");
            let n3 = 1;
            do {
              t3 = this._generateUid(e3, n3), n3++;
            } while (this.hasLabel(t3) || this.hasBinding(t3) || this.hasGlobal(t3) || this.hasReference(t3));
            const r3 = this.getProgramParent();
            return r3.references[t3] = true, r3.uids[t3] = true, t3;
          }
          _generateUid(e3, t3) {
            let n3 = e3;
            return t3 > 1 && (n3 += t3), `_${n3}`;
          }
          generateUidBasedOnNode(e3, t3) {
            const n3 = [];
            te(e3, n3);
            let r3 = n3.join("$");
            return r3 = r3.replace(/^_/, "") || t3 || "ref", this.generateUid(r3.slice(0, 20));
          }
          generateUidIdentifierBasedOnNode(e3, t3) {
            return y(this.generateUidBasedOnNode(e3, t3));
          }
          isStatic(e3) {
            if (j(e3) || _(e3) || z(e3)) return true;
            if (A(e3)) {
              const t3 = this.getBinding(e3.name);
              return t3 ? t3.constant : this.hasBinding(e3.name);
            }
            return false;
          }
          maybeGenerateMemoised(e3, t3) {
            if (this.isStatic(e3)) return null;
            {
              const n3 = this.generateUidIdentifierBasedOnNode(e3);
              return t3 ? n3 : (this.push({ id: n3 }), d(n3));
            }
          }
          checkBlockScopedCollisions(e3, t3, n3, r3) {
            if ("param" !== t3 && "local" !== e3.kind && ("let" === t3 || "let" === e3.kind || "const" === e3.kind || "module" === e3.kind || "param" === e3.kind && "const" === t3)) throw this.hub.buildError(r3, `Duplicate declaration "${n3}"`, TypeError);
          }
          rename(e3, t3) {
            const n3 = this.getBinding(e3);
            n3 && (t3 || (t3 = this.generateUidIdentifier(e3).name), new r2.default(n3, e3, t3).rename(arguments[2]));
          }
          _renameFromMap(e3, t3, n3, r3) {
            e3[t3] && (e3[n3] = r3, e3[t3] = null);
          }
          dump() {
            const e3 = "-".repeat(60);
            console.log(e3);
            let t3 = this;
            do {
              console.log("#", t3.block.type);
              for (const e4 of Object.keys(t3.bindings)) {
                const n3 = t3.bindings[e4];
                console.log(" -", e4, { constant: n3.constant, references: n3.references, violations: n3.constantViolations.length, kind: n3.kind });
              }
            } while (t3 = t3.parent);
            console.log(e3);
          }
          toArray(e3, t3, n3) {
            if (A(e3)) {
              const t4 = this.getBinding(e3.name);
              if (null != t4 && t4.constant && t4.path.isGenericType("Array")) return e3;
            }
            if (m(e3)) return e3;
            if (A(e3, { name: "arguments" })) return h(K(K(K(y("Array"), y("prototype")), y("slice")), y("call")), [e3]);
            let r3;
            const i2 = [e3];
            return true === t3 ? r3 = "toConsumableArray" : "number" == typeof t3 ? (i2.push(W(t3)), r3 = "slicedToArray") : r3 = "toArray", n3 && (i2.unshift(this.hub.addHelper(r3)), r3 = "maybeArrayLike"), h(this.hub.addHelper(r3), i2);
          }
          hasLabel(e3) {
            return !!this.getLabel(e3);
          }
          getLabel(e3) {
            return this.labels.get(e3);
          }
          registerLabel(e3) {
            this.labels.set(e3.node.label.name, e3);
          }
          registerDeclaration(e3) {
            if (e3.isLabeledStatement()) this.registerLabel(e3);
            else if (e3.isFunctionDeclaration()) this.registerBinding("hoisted", e3.get("id"), e3);
            else if (e3.isVariableDeclaration()) {
              const t3 = e3.get("declarations"), { kind: n3 } = e3.node;
              for (const e4 of t3) this.registerBinding("using" === n3 || "await using" === n3 ? "const" : n3, e4);
            } else if (e3.isClassDeclaration()) {
              if (e3.node.declare) return;
              this.registerBinding("let", e3);
            } else if (e3.isImportDeclaration()) {
              const t3 = "type" === e3.node.importKind || "typeof" === e3.node.importKind, n3 = e3.get("specifiers");
              for (const e4 of n3) {
                const n4 = t3 || e4.isImportSpecifier() && ("type" === e4.node.importKind || "typeof" === e4.node.importKind);
                this.registerBinding(n4 ? "unknown" : "module", e4);
              }
            } else if (e3.isExportDeclaration()) {
              const t3 = e3.get("declaration");
              (t3.isClassDeclaration() || t3.isFunctionDeclaration() || t3.isVariableDeclaration()) && this.registerDeclaration(t3);
            } else this.registerBinding("unknown", e3);
          }
          buildUndefinedNode() {
            return Y("void", W(0), true);
          }
          registerConstantViolation(e3) {
            const t3 = e3.getBindingIdentifiers();
            for (const r3 of Object.keys(t3)) {
              var n3;
              null == (n3 = this.getBinding(r3)) || n3.reassign(e3);
            }
          }
          registerBinding(e3, t3, n3 = t3) {
            if (!e3) throw new ReferenceError("no `kind`");
            if (t3.isVariableDeclaration()) {
              const n4 = t3.get("declarations");
              for (const t4 of n4) this.registerBinding(e3, t4);
              return;
            }
            const r3 = this.getProgramParent(), i2 = t3.getOuterBindingIdentifiers(true);
            for (const t4 of Object.keys(i2)) {
              r3.references[t4] = true;
              for (const r4 of i2[t4]) {
                const i3 = this.getOwnBinding(t4);
                if (i3) {
                  if (i3.identifier === r4) continue;
                  this.checkBlockScopedCollisions(i3, e3, t4, r4);
                }
                i3 ? this.registerConstantViolation(n3) : this.bindings[t4] = new s.default({ identifier: r4, scope: this, path: n3, kind: e3 });
              }
            }
          }
          addGlobal(e3) {
            this.globals[e3.name] = e3;
          }
          hasUid(e3) {
            let t3 = this;
            do {
              if (t3.uids[e3]) return true;
            } while (t3 = t3.parent);
            return false;
          }
          hasGlobal(e3) {
            let t3 = this;
            do {
              if (t3.globals[e3]) return true;
            } while (t3 = t3.parent);
            return false;
          }
          hasReference(e3) {
            return !!this.getProgramParent().references[e3];
          }
          isPure(e3, t3) {
            if (A(e3)) {
              const n4 = this.getBinding(e3.name);
              return !!n4 && (!t3 || n4.constant);
            }
            if (j(e3) || Q(e3) || z(e3) || Z(e3)) return true;
            var n3, r3, i2;
            if (g(e3)) return !(e3.superClass && !this.isPure(e3.superClass, t3)) && !((null == (n3 = e3.decorators) ? void 0 : n3.length) > 0) && this.isPure(e3.body, t3);
            if (b(e3)) {
              for (const n4 of e3.body) if (!this.isPure(n4, t3)) return false;
              return true;
            }
            if (T(e3)) return this.isPure(e3.left, t3) && this.isPure(e3.right, t3);
            if (m(e3) || $(e3)) {
              for (const n4 of e3.elements) if (null !== n4 && !this.isPure(n4, t3)) return false;
              return true;
            }
            if (N(e3) || J(e3)) {
              for (const n4 of e3.properties) if (!this.isPure(n4, t3)) return false;
              return true;
            }
            if (w(e3)) return !(e3.computed && !this.isPure(e3.key, t3) || (null == (r3 = e3.decorators) ? void 0 : r3.length) > 0);
            if (F(e3)) return !(e3.computed && !this.isPure(e3.key, t3) || (null == (i2 = e3.decorators) ? void 0 : i2.length) > 0 || (G(e3) || e3.static) && null !== e3.value && !this.isPure(e3.value, t3));
            if (R(e3)) return this.isPure(e3.argument, t3);
            if (M(e3)) return V(e3.tag, "String.raw") && !this.hasBinding("String", true) && this.isPure(e3.quasi, t3);
            if (B(e3)) {
              for (const n4 of e3.expressions) if (!this.isPure(n4, t3)) return false;
              return true;
            }
            return k(e3);
          }
          setData(e3, t3) {
            return this.data[e3] = t3;
          }
          getData(e3) {
            let t3 = this;
            do {
              const n3 = t3.data[e3];
              if (null != n3) return n3;
            } while (t3 = t3.parent);
          }
          removeData(e3) {
            let t3 = this;
            do {
              null != t3.data[e3] && (t3.data[e3] = null);
            } while (t3 = t3.parent);
          }
          init() {
            this.inited || (this.inited = true, this.crawl());
          }
          crawl() {
            const e3 = this.path;
            this.references = /* @__PURE__ */ Object.create(null), this.bindings = /* @__PURE__ */ Object.create(null), this.globals = /* @__PURE__ */ Object.create(null), this.uids = /* @__PURE__ */ Object.create(null), this.data = /* @__PURE__ */ Object.create(null);
            const t3 = this.getProgramParent();
            if (t3.crawling) return;
            const n3 = { references: [], constantViolations: [], assignments: [] };
            if (this.crawling = true, "Program" !== e3.type && (0, u.isExplodedVisitor)(ne)) {
              for (const t5 of ne.enter) t5.call(n3, e3, n3);
              const t4 = ne[e3.type];
              if (t4) for (const r3 of t4.enter) r3.call(n3, e3, n3);
            }
            e3.traverse(ne, n3), this.crawling = false;
            for (const e4 of n3.assignments) {
              const n4 = e4.getBindingIdentifiers();
              for (const r3 of Object.keys(n4)) e4.scope.getBinding(r3) || t3.addGlobal(n4[r3]);
              e4.scope.registerConstantViolation(e4);
            }
            for (const e4 of n3.references) {
              const n4 = e4.scope.getBinding(e4.node.name);
              n4 ? n4.reference(e4) : t3.addGlobal(e4.node);
            }
            for (const e4 of n3.constantViolations) e4.scope.registerConstantViolation(e4);
          }
          push(e3) {
            let t3 = this.path;
            t3.isPattern() ? t3 = this.getPatternParent().path : t3.isBlockStatement() || t3.isProgram() || (t3 = this.getBlockParent().path), t3.isSwitchStatement() && (t3 = (this.getFunctionParent() || this.getProgramParent()).path);
            const { init: n3, unique: r3, kind: i2 = "var", id: s2 } = e3;
            if (!n3 && !r3 && ("var" === i2 || "let" === i2) && t3.isFunction() && !t3.node.name && l.isCallExpression(t3.parent, { callee: t3.node }) && t3.parent.arguments.length <= t3.node.params.length && l.isIdentifier(s2)) return t3.pushContainer("params", s2), void t3.scope.registerBinding("param", t3.get("params")[t3.node.params.length - 1]);
            (t3.isLoop() || t3.isCatchClause() || t3.isFunction()) && (t3.ensureBlock(), t3 = t3.get("body"));
            const a2 = null == e3._blockHoist ? 2 : e3._blockHoist, o2 = `declaration:${i2}:${a2}`;
            let c2 = !r3 && t3.getData(o2);
            if (!c2) {
              const e4 = q(i2, []);
              e4._blockHoist = a2, [c2] = t3.unshiftContainer("body", [e4]), r3 || t3.setData(o2, c2);
            }
            const u2 = H(s2, n3), p2 = c2.node.declarations.push(u2);
            t3.scope.registerBinding(i2, c2.get("declarations")[p2 - 1]);
          }
          getProgramParent() {
            let e3 = this;
            do {
              if (e3.path.isProgram()) return e3;
            } while (e3 = e3.parent);
            throw new Error("Couldn't find a Program");
          }
          getFunctionParent() {
            let e3 = this;
            do {
              if (e3.path.isFunctionParent()) return e3;
            } while (e3 = e3.parent);
            return null;
          }
          getBlockParent() {
            let e3 = this;
            do {
              if (e3.path.isBlockParent()) return e3;
            } while (e3 = e3.parent);
            throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
          }
          getPatternParent() {
            let e3 = this;
            do {
              if (!e3.path.isPattern()) return e3.getBlockParent();
            } while (e3 = e3.parent.parent);
            throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
          }
          getAllBindings() {
            const e3 = /* @__PURE__ */ Object.create(null);
            let t3 = this;
            do {
              for (const n3 of Object.keys(t3.bindings)) n3 in e3 == 0 && (e3[n3] = t3.bindings[n3]);
              t3 = t3.parent;
            } while (t3);
            return e3;
          }
          getAllBindingsOfKind(...e3) {
            const t3 = /* @__PURE__ */ Object.create(null);
            for (const n3 of e3) {
              let e4 = this;
              do {
                for (const r3 of Object.keys(e4.bindings)) {
                  const i2 = e4.bindings[r3];
                  i2.kind === n3 && (t3[r3] = i2);
                }
                e4 = e4.parent;
              } while (e4);
            }
            return t3;
          }
          bindingIdentifierEquals(e3, t3) {
            return this.getBindingIdentifier(e3) === t3;
          }
          getBinding(e3) {
            let t3, n3 = this;
            do {
              const i2 = n3.getOwnBinding(e3);
              var r3;
              if (i2) {
                if (null == (r3 = t3) || !r3.isPattern() || "param" === i2.kind || "local" === i2.kind) return i2;
              } else if (!i2 && "arguments" === e3 && n3.path.isFunction() && !n3.path.isArrowFunctionExpression()) break;
              t3 = n3.path;
            } while (n3 = n3.parent);
          }
          getOwnBinding(e3) {
            return this.bindings[e3];
          }
          getBindingIdentifier(e3) {
            var t3;
            return null == (t3 = this.getBinding(e3)) ? void 0 : t3.identifier;
          }
          getOwnBindingIdentifier(e3) {
            const t3 = this.bindings[e3];
            return null == t3 ? void 0 : t3.identifier;
          }
          hasOwnBinding(e3) {
            return !!this.getOwnBinding(e3);
          }
          hasBinding(e3, t3) {
            var n3, r3, i2;
            return !(!e3 || !this.hasOwnBinding(e3) && ("boolean" == typeof t3 && (t3 = { noGlobals: t3 }), !this.parentHasBinding(e3, t3) && (null != (n3 = t3) && n3.noUids || !this.hasUid(e3)) && (null != (r3 = t3) && r3.noGlobals || !ie.globals.includes(e3)) && (null != (i2 = t3) && i2.noGlobals || !ie.contextVariables.includes(e3))));
          }
          parentHasBinding(e3, t3) {
            var n3;
            return null == (n3 = this.parent) ? void 0 : n3.hasBinding(e3, t3);
          }
          moveBindingTo(e3, t3) {
            const n3 = this.getBinding(e3);
            n3 && (n3.scope.removeOwnBinding(e3), n3.scope = t3, t3.bindings[e3] = n3);
          }
          removeOwnBinding(e3) {
            delete this.bindings[e3];
          }
          removeBinding(e3) {
            var t3;
            null == (t3 = this.getBinding(e3)) || t3.scope.removeOwnBinding(e3);
            let n3 = this;
            do {
              n3.uids[e3] && (n3.uids[e3] = false);
            } while (n3 = n3.parent);
          }
        }
        t2.default = ie, ie.globals = Object.keys(a.builtin), ie.contextVariables = ["arguments", "undefined", "Infinity", "NaN"];
      }, 6426: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var r2 = n2(3472), i = n2(6067), s = n2(4705), a = n2(9432), o = n2(7380);
        const l = { ReferencedIdentifier({ node: e3 }, t3) {
          e3.name === t3.oldName && (e3.name = t3.newName);
        }, Scope(e3, t3) {
          e3.scope.bindingIdentifierEquals(t3.oldName, t3.binding.identifier) || (e3.skip(), e3.isMethod() && (0, s.requeueComputedKeyAndDecorators)(e3));
        }, ObjectProperty({ node: e3, scope: t3 }, n3) {
          const { name: r3 } = e3.key;
          var i2;
          !e3.shorthand || r3 !== n3.oldName && r3 !== n3.newName || t3.getBindingIdentifier(r3) !== n3.binding.identifier || (e3.shorthand = false, null != (i2 = e3.extra) && i2.shorthand && (e3.extra.shorthand = false));
        }, "AssignmentExpression|Declaration|VariableDeclarator"(e3, t3) {
          if (e3.isVariableDeclaration()) return;
          const n3 = e3.getOuterBindingIdentifiers();
          for (const e4 in n3) e4 === t3.oldName && (n3[e4].name = t3.newName);
        } };
        t2.default = class {
          constructor(e3, t3, n3) {
            this.newName = n3, this.oldName = t3, this.binding = e3;
          }
          maybeConvertFromExportDeclaration(e3) {
            const t3 = e3.parentPath;
            if (t3.isExportDeclaration()) {
              if (t3.isExportDefaultDeclaration()) {
                const { declaration: e4 } = t3.node;
                if (i.isDeclaration(e4) && !e4.id) return;
              }
              t3.isExportAllDeclaration() || (0, r2.default)(t3);
            }
          }
          maybeConvertFromClassFunctionDeclaration(e3) {
            return e3;
          }
          maybeConvertFromClassFunctionExpression(e3) {
            return e3;
          }
          rename() {
            const { binding: e3, oldName: t3, newName: n3 } = this, { scope: r3, path: i2 } = e3, s2 = i2.find((e4) => e4.isDeclaration() || e4.isFunctionExpression() || e4.isClassExpression());
            s2 && s2.getOuterBindingIdentifiers()[t3] === e3.identifier && this.maybeConvertFromExportDeclaration(s2);
            const c = arguments[0] || r3.block;
            (0, a.traverseNode)(c, (0, o.explode)(l), r3, this, r3.path, { discriminant: true }), arguments[0] || (r3.removeOwnBinding(t3), r3.bindings[n3] = e3, this.binding.identifier.name = n3), s2 && (this.maybeConvertFromClassFunctionDeclaration(i2), this.maybeConvertFromClassFunctionExpression(i2));
          }
        };
      }, 9432: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.traverseNode = function(e3, t3, n3, i2, a, o, l) {
          const c = s[e3.type];
          if (!c) return false;
          const u = new r2.default(n3, t3, i2, a);
          if (l) return (null == o || !o[a.parentKey]) && u.visitQueue([a]);
          for (const t4 of c) if ((null == o || !o[t4]) && u.visit(e3, t4)) return true;
          return false;
        };
        var r2 = n2(4165), i = n2(6067);
        const { VISITOR_KEYS: s } = i;
      }, 7380: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.explode = p, t2.isExplodedVisitor = u, t2.merge = function(e3, t3 = [], n3) {
          const r3 = {};
          for (let i2 = 0; i2 < e3.length; i2++) {
            const s2 = p(e3[i2]), a2 = t3[i2];
            let o2 = s2;
            (a2 || n3) && (o2 = f(o2, a2, n3)), g(r3, o2);
            for (const e4 of Object.keys(s2)) {
              if (T(e4)) continue;
              let t4 = s2[e4];
              (a2 || n3) && (t4 = f(t4, a2, n3)), g(r3[e4] || (r3[e4] = {}), t4);
            }
          }
          return r3;
        }, t2.verify = h;
        var r2 = n2(8176), i = n2(6067);
        const { DEPRECATED_KEYS: s, DEPRECATED_ALIASES: a, FLIPPED_ALIAS_KEYS: o, TYPES: l, __internal__deprecationWarning: c } = i;
        function u(e3) {
          return null == e3 ? void 0 : e3._exploded;
        }
        function p(e3) {
          if (u(e3)) return e3;
          e3._exploded = true;
          for (const t3 of Object.keys(e3)) {
            if (T(t3)) continue;
            const n3 = t3.split("|");
            if (1 === n3.length) continue;
            const r3 = e3[t3];
            delete e3[t3];
            for (const t4 of n3) e3[t4] = r3;
          }
          h(e3), delete e3.__esModule, function(e4) {
            for (const t3 of Object.keys(e4)) {
              if (T(t3)) continue;
              const n3 = e4[t3];
              "function" == typeof n3 && (e4[t3] = { enter: n3 });
            }
          }(e3), y(e3);
          for (const t3 of Object.keys(e3)) {
            if (T(t3)) continue;
            if (!(t3 in r2)) continue;
            const n3 = e3[t3];
            for (const e4 of Object.keys(n3)) n3[e4] = m(t3, n3[e4]);
            delete e3[t3];
            const i2 = r2[t3];
            if (null !== i2) for (const t4 of i2) e3[t4] ? g(e3[t4], n3) : e3[t4] = n3;
            else g(e3, n3);
          }
          for (const t3 of Object.keys(e3)) {
            if (T(t3)) continue;
            let n3 = o[t3];
            if (t3 in s) {
              const e4 = s[t3];
              c(t3, e4, "Visitor "), n3 = [e4];
            } else if (t3 in a) {
              const e4 = a[t3];
              c(t3, e4, "Visitor "), n3 = o[e4];
            }
            if (!n3) continue;
            const r3 = e3[t3];
            delete e3[t3];
            for (const t4 of n3) {
              const n4 = e3[t4];
              n4 ? g(n4, r3) : e3[t4] = Object.assign({}, r3);
            }
          }
          for (const t3 of Object.keys(e3)) T(t3) || y(e3[t3]);
          return e3;
        }
        function h(e3) {
          if (!e3._verified) {
            if ("function" == typeof e3) throw new Error("You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Function }`?");
            for (const t3 of Object.keys(e3)) {
              if ("enter" !== t3 && "exit" !== t3 || d(t3, e3[t3]), T(t3)) continue;
              if (l.indexOf(t3) < 0) throw new Error(`You gave us a visitor for the node type ${t3} but it's not a valid type`);
              const n3 = e3[t3];
              if ("object" == typeof n3) for (const e4 of Object.keys(n3)) {
                if ("enter" !== e4 && "exit" !== e4) throw new Error(`You passed \`traverse()\` a visitor object with the property ${t3} that has the invalid property ${e4}`);
                d(`${t3}.${e4}`, n3[e4]);
              }
            }
            e3._verified = true;
          }
        }
        function d(e3, t3) {
          const n3 = [].concat(t3);
          for (const t4 of n3) if ("function" != typeof t4) throw new TypeError(`Non-function found defined in ${e3} with type ${typeof t4}`);
        }
        function f(e3, t3, n3) {
          const r3 = {};
          for (const i2 of ["enter", "exit"]) {
            let s2 = e3[i2];
            Array.isArray(s2) && (s2 = s2.map(function(e4) {
              let r4 = e4;
              return t3 && (r4 = function(n4) {
                e4.call(t3, n4, t3);
              }), n3 && (r4 = n3(null == t3 ? void 0 : t3.key, i2, r4)), r4 !== e4 && (r4.toString = () => e4.toString()), r4;
            }), r3[i2] = s2);
          }
          return r3;
        }
        function y(e3) {
          e3.enter && !Array.isArray(e3.enter) && (e3.enter = [e3.enter]), e3.exit && !Array.isArray(e3.exit) && (e3.exit = [e3.exit]);
        }
        function m(e3, t3) {
          const n3 = function(n4) {
            if (n4[`is${e3}`]()) return t3.apply(this, arguments);
          };
          return n3.toString = () => t3.toString(), n3;
        }
        function T(e3) {
          return "_" === e3[0] || "enter" === e3 || "exit" === e3 || "shouldSkip" === e3 || "denylist" === e3 || "noScope" === e3 || "skipKeys" === e3 || "blacklist" === e3;
        }
        function g(e3, t3) {
          for (const n3 of ["enter", "exit"]) t3[n3] && (e3[n3] = [].concat(e3[n3] || [], t3[n3]));
        }
      }, 391: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
          if (!(0, r2.default)(e3)) {
            var t3;
            const n3 = null != (t3 = null == e3 ? void 0 : e3.type) ? t3 : JSON.stringify(e3);
            throw new TypeError(`Not a valid node of type "${n3}"`);
          }
        };
        var r2 = n2(4814);
      }, 163: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.assertAccessor = function(e3, t3) {
          s("Accessor", e3, t3);
        }, t2.assertAnyTypeAnnotation = function(e3, t3) {
          s("AnyTypeAnnotation", e3, t3);
        }, t2.assertArgumentPlaceholder = function(e3, t3) {
          s("ArgumentPlaceholder", e3, t3);
        }, t2.assertArrayExpression = function(e3, t3) {
          s("ArrayExpression", e3, t3);
        }, t2.assertArrayPattern = function(e3, t3) {
          s("ArrayPattern", e3, t3);
        }, t2.assertArrayTypeAnnotation = function(e3, t3) {
          s("ArrayTypeAnnotation", e3, t3);
        }, t2.assertArrowFunctionExpression = function(e3, t3) {
          s("ArrowFunctionExpression", e3, t3);
        }, t2.assertAssignmentExpression = function(e3, t3) {
          s("AssignmentExpression", e3, t3);
        }, t2.assertAssignmentPattern = function(e3, t3) {
          s("AssignmentPattern", e3, t3);
        }, t2.assertAwaitExpression = function(e3, t3) {
          s("AwaitExpression", e3, t3);
        }, t2.assertBigIntLiteral = function(e3, t3) {
          s("BigIntLiteral", e3, t3);
        }, t2.assertBinary = function(e3, t3) {
          s("Binary", e3, t3);
        }, t2.assertBinaryExpression = function(e3, t3) {
          s("BinaryExpression", e3, t3);
        }, t2.assertBindExpression = function(e3, t3) {
          s("BindExpression", e3, t3);
        }, t2.assertBlock = function(e3, t3) {
          s("Block", e3, t3);
        }, t2.assertBlockParent = function(e3, t3) {
          s("BlockParent", e3, t3);
        }, t2.assertBlockStatement = function(e3, t3) {
          s("BlockStatement", e3, t3);
        }, t2.assertBooleanLiteral = function(e3, t3) {
          s("BooleanLiteral", e3, t3);
        }, t2.assertBooleanLiteralTypeAnnotation = function(e3, t3) {
          s("BooleanLiteralTypeAnnotation", e3, t3);
        }, t2.assertBooleanTypeAnnotation = function(e3, t3) {
          s("BooleanTypeAnnotation", e3, t3);
        }, t2.assertBreakStatement = function(e3, t3) {
          s("BreakStatement", e3, t3);
        }, t2.assertCallExpression = function(e3, t3) {
          s("CallExpression", e3, t3);
        }, t2.assertCatchClause = function(e3, t3) {
          s("CatchClause", e3, t3);
        }, t2.assertClass = function(e3, t3) {
          s("Class", e3, t3);
        }, t2.assertClassAccessorProperty = function(e3, t3) {
          s("ClassAccessorProperty", e3, t3);
        }, t2.assertClassBody = function(e3, t3) {
          s("ClassBody", e3, t3);
        }, t2.assertClassDeclaration = function(e3, t3) {
          s("ClassDeclaration", e3, t3);
        }, t2.assertClassExpression = function(e3, t3) {
          s("ClassExpression", e3, t3);
        }, t2.assertClassImplements = function(e3, t3) {
          s("ClassImplements", e3, t3);
        }, t2.assertClassMethod = function(e3, t3) {
          s("ClassMethod", e3, t3);
        }, t2.assertClassPrivateMethod = function(e3, t3) {
          s("ClassPrivateMethod", e3, t3);
        }, t2.assertClassPrivateProperty = function(e3, t3) {
          s("ClassPrivateProperty", e3, t3);
        }, t2.assertClassProperty = function(e3, t3) {
          s("ClassProperty", e3, t3);
        }, t2.assertCompletionStatement = function(e3, t3) {
          s("CompletionStatement", e3, t3);
        }, t2.assertConditional = function(e3, t3) {
          s("Conditional", e3, t3);
        }, t2.assertConditionalExpression = function(e3, t3) {
          s("ConditionalExpression", e3, t3);
        }, t2.assertContinueStatement = function(e3, t3) {
          s("ContinueStatement", e3, t3);
        }, t2.assertDebuggerStatement = function(e3, t3) {
          s("DebuggerStatement", e3, t3);
        }, t2.assertDecimalLiteral = function(e3, t3) {
          s("DecimalLiteral", e3, t3);
        }, t2.assertDeclaration = function(e3, t3) {
          s("Declaration", e3, t3);
        }, t2.assertDeclareClass = function(e3, t3) {
          s("DeclareClass", e3, t3);
        }, t2.assertDeclareExportAllDeclaration = function(e3, t3) {
          s("DeclareExportAllDeclaration", e3, t3);
        }, t2.assertDeclareExportDeclaration = function(e3, t3) {
          s("DeclareExportDeclaration", e3, t3);
        }, t2.assertDeclareFunction = function(e3, t3) {
          s("DeclareFunction", e3, t3);
        }, t2.assertDeclareInterface = function(e3, t3) {
          s("DeclareInterface", e3, t3);
        }, t2.assertDeclareModule = function(e3, t3) {
          s("DeclareModule", e3, t3);
        }, t2.assertDeclareModuleExports = function(e3, t3) {
          s("DeclareModuleExports", e3, t3);
        }, t2.assertDeclareOpaqueType = function(e3, t3) {
          s("DeclareOpaqueType", e3, t3);
        }, t2.assertDeclareTypeAlias = function(e3, t3) {
          s("DeclareTypeAlias", e3, t3);
        }, t2.assertDeclareVariable = function(e3, t3) {
          s("DeclareVariable", e3, t3);
        }, t2.assertDeclaredPredicate = function(e3, t3) {
          s("DeclaredPredicate", e3, t3);
        }, t2.assertDecorator = function(e3, t3) {
          s("Decorator", e3, t3);
        }, t2.assertDirective = function(e3, t3) {
          s("Directive", e3, t3);
        }, t2.assertDirectiveLiteral = function(e3, t3) {
          s("DirectiveLiteral", e3, t3);
        }, t2.assertDoExpression = function(e3, t3) {
          s("DoExpression", e3, t3);
        }, t2.assertDoWhileStatement = function(e3, t3) {
          s("DoWhileStatement", e3, t3);
        }, t2.assertEmptyStatement = function(e3, t3) {
          s("EmptyStatement", e3, t3);
        }, t2.assertEmptyTypeAnnotation = function(e3, t3) {
          s("EmptyTypeAnnotation", e3, t3);
        }, t2.assertEnumBody = function(e3, t3) {
          s("EnumBody", e3, t3);
        }, t2.assertEnumBooleanBody = function(e3, t3) {
          s("EnumBooleanBody", e3, t3);
        }, t2.assertEnumBooleanMember = function(e3, t3) {
          s("EnumBooleanMember", e3, t3);
        }, t2.assertEnumDeclaration = function(e3, t3) {
          s("EnumDeclaration", e3, t3);
        }, t2.assertEnumDefaultedMember = function(e3, t3) {
          s("EnumDefaultedMember", e3, t3);
        }, t2.assertEnumMember = function(e3, t3) {
          s("EnumMember", e3, t3);
        }, t2.assertEnumNumberBody = function(e3, t3) {
          s("EnumNumberBody", e3, t3);
        }, t2.assertEnumNumberMember = function(e3, t3) {
          s("EnumNumberMember", e3, t3);
        }, t2.assertEnumStringBody = function(e3, t3) {
          s("EnumStringBody", e3, t3);
        }, t2.assertEnumStringMember = function(e3, t3) {
          s("EnumStringMember", e3, t3);
        }, t2.assertEnumSymbolBody = function(e3, t3) {
          s("EnumSymbolBody", e3, t3);
        }, t2.assertExistsTypeAnnotation = function(e3, t3) {
          s("ExistsTypeAnnotation", e3, t3);
        }, t2.assertExportAllDeclaration = function(e3, t3) {
          s("ExportAllDeclaration", e3, t3);
        }, t2.assertExportDeclaration = function(e3, t3) {
          s("ExportDeclaration", e3, t3);
        }, t2.assertExportDefaultDeclaration = function(e3, t3) {
          s("ExportDefaultDeclaration", e3, t3);
        }, t2.assertExportDefaultSpecifier = function(e3, t3) {
          s("ExportDefaultSpecifier", e3, t3);
        }, t2.assertExportNamedDeclaration = function(e3, t3) {
          s("ExportNamedDeclaration", e3, t3);
        }, t2.assertExportNamespaceSpecifier = function(e3, t3) {
          s("ExportNamespaceSpecifier", e3, t3);
        }, t2.assertExportSpecifier = function(e3, t3) {
          s("ExportSpecifier", e3, t3);
        }, t2.assertExpression = function(e3, t3) {
          s("Expression", e3, t3);
        }, t2.assertExpressionStatement = function(e3, t3) {
          s("ExpressionStatement", e3, t3);
        }, t2.assertExpressionWrapper = function(e3, t3) {
          s("ExpressionWrapper", e3, t3);
        }, t2.assertFile = function(e3, t3) {
          s("File", e3, t3);
        }, t2.assertFlow = function(e3, t3) {
          s("Flow", e3, t3);
        }, t2.assertFlowBaseAnnotation = function(e3, t3) {
          s("FlowBaseAnnotation", e3, t3);
        }, t2.assertFlowDeclaration = function(e3, t3) {
          s("FlowDeclaration", e3, t3);
        }, t2.assertFlowPredicate = function(e3, t3) {
          s("FlowPredicate", e3, t3);
        }, t2.assertFlowType = function(e3, t3) {
          s("FlowType", e3, t3);
        }, t2.assertFor = function(e3, t3) {
          s("For", e3, t3);
        }, t2.assertForInStatement = function(e3, t3) {
          s("ForInStatement", e3, t3);
        }, t2.assertForOfStatement = function(e3, t3) {
          s("ForOfStatement", e3, t3);
        }, t2.assertForStatement = function(e3, t3) {
          s("ForStatement", e3, t3);
        }, t2.assertForXStatement = function(e3, t3) {
          s("ForXStatement", e3, t3);
        }, t2.assertFunction = function(e3, t3) {
          s("Function", e3, t3);
        }, t2.assertFunctionDeclaration = function(e3, t3) {
          s("FunctionDeclaration", e3, t3);
        }, t2.assertFunctionExpression = function(e3, t3) {
          s("FunctionExpression", e3, t3);
        }, t2.assertFunctionParent = function(e3, t3) {
          s("FunctionParent", e3, t3);
        }, t2.assertFunctionTypeAnnotation = function(e3, t3) {
          s("FunctionTypeAnnotation", e3, t3);
        }, t2.assertFunctionTypeParam = function(e3, t3) {
          s("FunctionTypeParam", e3, t3);
        }, t2.assertGenericTypeAnnotation = function(e3, t3) {
          s("GenericTypeAnnotation", e3, t3);
        }, t2.assertIdentifier = function(e3, t3) {
          s("Identifier", e3, t3);
        }, t2.assertIfStatement = function(e3, t3) {
          s("IfStatement", e3, t3);
        }, t2.assertImmutable = function(e3, t3) {
          s("Immutable", e3, t3);
        }, t2.assertImport = function(e3, t3) {
          s("Import", e3, t3);
        }, t2.assertImportAttribute = function(e3, t3) {
          s("ImportAttribute", e3, t3);
        }, t2.assertImportDeclaration = function(e3, t3) {
          s("ImportDeclaration", e3, t3);
        }, t2.assertImportDefaultSpecifier = function(e3, t3) {
          s("ImportDefaultSpecifier", e3, t3);
        }, t2.assertImportNamespaceSpecifier = function(e3, t3) {
          s("ImportNamespaceSpecifier", e3, t3);
        }, t2.assertImportOrExportDeclaration = function(e3, t3) {
          s("ImportOrExportDeclaration", e3, t3);
        }, t2.assertImportSpecifier = function(e3, t3) {
          s("ImportSpecifier", e3, t3);
        }, t2.assertIndexedAccessType = function(e3, t3) {
          s("IndexedAccessType", e3, t3);
        }, t2.assertInferredPredicate = function(e3, t3) {
          s("InferredPredicate", e3, t3);
        }, t2.assertInterfaceDeclaration = function(e3, t3) {
          s("InterfaceDeclaration", e3, t3);
        }, t2.assertInterfaceExtends = function(e3, t3) {
          s("InterfaceExtends", e3, t3);
        }, t2.assertInterfaceTypeAnnotation = function(e3, t3) {
          s("InterfaceTypeAnnotation", e3, t3);
        }, t2.assertInterpreterDirective = function(e3, t3) {
          s("InterpreterDirective", e3, t3);
        }, t2.assertIntersectionTypeAnnotation = function(e3, t3) {
          s("IntersectionTypeAnnotation", e3, t3);
        }, t2.assertJSX = function(e3, t3) {
          s("JSX", e3, t3);
        }, t2.assertJSXAttribute = function(e3, t3) {
          s("JSXAttribute", e3, t3);
        }, t2.assertJSXClosingElement = function(e3, t3) {
          s("JSXClosingElement", e3, t3);
        }, t2.assertJSXClosingFragment = function(e3, t3) {
          s("JSXClosingFragment", e3, t3);
        }, t2.assertJSXElement = function(e3, t3) {
          s("JSXElement", e3, t3);
        }, t2.assertJSXEmptyExpression = function(e3, t3) {
          s("JSXEmptyExpression", e3, t3);
        }, t2.assertJSXExpressionContainer = function(e3, t3) {
          s("JSXExpressionContainer", e3, t3);
        }, t2.assertJSXFragment = function(e3, t3) {
          s("JSXFragment", e3, t3);
        }, t2.assertJSXIdentifier = function(e3, t3) {
          s("JSXIdentifier", e3, t3);
        }, t2.assertJSXMemberExpression = function(e3, t3) {
          s("JSXMemberExpression", e3, t3);
        }, t2.assertJSXNamespacedName = function(e3, t3) {
          s("JSXNamespacedName", e3, t3);
        }, t2.assertJSXOpeningElement = function(e3, t3) {
          s("JSXOpeningElement", e3, t3);
        }, t2.assertJSXOpeningFragment = function(e3, t3) {
          s("JSXOpeningFragment", e3, t3);
        }, t2.assertJSXSpreadAttribute = function(e3, t3) {
          s("JSXSpreadAttribute", e3, t3);
        }, t2.assertJSXSpreadChild = function(e3, t3) {
          s("JSXSpreadChild", e3, t3);
        }, t2.assertJSXText = function(e3, t3) {
          s("JSXText", e3, t3);
        }, t2.assertLVal = function(e3, t3) {
          s("LVal", e3, t3);
        }, t2.assertLabeledStatement = function(e3, t3) {
          s("LabeledStatement", e3, t3);
        }, t2.assertLiteral = function(e3, t3) {
          s("Literal", e3, t3);
        }, t2.assertLogicalExpression = function(e3, t3) {
          s("LogicalExpression", e3, t3);
        }, t2.assertLoop = function(e3, t3) {
          s("Loop", e3, t3);
        }, t2.assertMemberExpression = function(e3, t3) {
          s("MemberExpression", e3, t3);
        }, t2.assertMetaProperty = function(e3, t3) {
          s("MetaProperty", e3, t3);
        }, t2.assertMethod = function(e3, t3) {
          s("Method", e3, t3);
        }, t2.assertMiscellaneous = function(e3, t3) {
          s("Miscellaneous", e3, t3);
        }, t2.assertMixedTypeAnnotation = function(e3, t3) {
          s("MixedTypeAnnotation", e3, t3);
        }, t2.assertModuleDeclaration = function(e3, t3) {
          (0, i.default)("assertModuleDeclaration", "assertImportOrExportDeclaration"), s("ModuleDeclaration", e3, t3);
        }, t2.assertModuleExpression = function(e3, t3) {
          s("ModuleExpression", e3, t3);
        }, t2.assertModuleSpecifier = function(e3, t3) {
          s("ModuleSpecifier", e3, t3);
        }, t2.assertNewExpression = function(e3, t3) {
          s("NewExpression", e3, t3);
        }, t2.assertNoop = function(e3, t3) {
          s("Noop", e3, t3);
        }, t2.assertNullLiteral = function(e3, t3) {
          s("NullLiteral", e3, t3);
        }, t2.assertNullLiteralTypeAnnotation = function(e3, t3) {
          s("NullLiteralTypeAnnotation", e3, t3);
        }, t2.assertNullableTypeAnnotation = function(e3, t3) {
          s("NullableTypeAnnotation", e3, t3);
        }, t2.assertNumberLiteral = function(e3, t3) {
          (0, i.default)("assertNumberLiteral", "assertNumericLiteral"), s("NumberLiteral", e3, t3);
        }, t2.assertNumberLiteralTypeAnnotation = function(e3, t3) {
          s("NumberLiteralTypeAnnotation", e3, t3);
        }, t2.assertNumberTypeAnnotation = function(e3, t3) {
          s("NumberTypeAnnotation", e3, t3);
        }, t2.assertNumericLiteral = function(e3, t3) {
          s("NumericLiteral", e3, t3);
        }, t2.assertObjectExpression = function(e3, t3) {
          s("ObjectExpression", e3, t3);
        }, t2.assertObjectMember = function(e3, t3) {
          s("ObjectMember", e3, t3);
        }, t2.assertObjectMethod = function(e3, t3) {
          s("ObjectMethod", e3, t3);
        }, t2.assertObjectPattern = function(e3, t3) {
          s("ObjectPattern", e3, t3);
        }, t2.assertObjectProperty = function(e3, t3) {
          s("ObjectProperty", e3, t3);
        }, t2.assertObjectTypeAnnotation = function(e3, t3) {
          s("ObjectTypeAnnotation", e3, t3);
        }, t2.assertObjectTypeCallProperty = function(e3, t3) {
          s("ObjectTypeCallProperty", e3, t3);
        }, t2.assertObjectTypeIndexer = function(e3, t3) {
          s("ObjectTypeIndexer", e3, t3);
        }, t2.assertObjectTypeInternalSlot = function(e3, t3) {
          s("ObjectTypeInternalSlot", e3, t3);
        }, t2.assertObjectTypeProperty = function(e3, t3) {
          s("ObjectTypeProperty", e3, t3);
        }, t2.assertObjectTypeSpreadProperty = function(e3, t3) {
          s("ObjectTypeSpreadProperty", e3, t3);
        }, t2.assertOpaqueType = function(e3, t3) {
          s("OpaqueType", e3, t3);
        }, t2.assertOptionalCallExpression = function(e3, t3) {
          s("OptionalCallExpression", e3, t3);
        }, t2.assertOptionalIndexedAccessType = function(e3, t3) {
          s("OptionalIndexedAccessType", e3, t3);
        }, t2.assertOptionalMemberExpression = function(e3, t3) {
          s("OptionalMemberExpression", e3, t3);
        }, t2.assertParenthesizedExpression = function(e3, t3) {
          s("ParenthesizedExpression", e3, t3);
        }, t2.assertPattern = function(e3, t3) {
          s("Pattern", e3, t3);
        }, t2.assertPatternLike = function(e3, t3) {
          s("PatternLike", e3, t3);
        }, t2.assertPipelineBareFunction = function(e3, t3) {
          s("PipelineBareFunction", e3, t3);
        }, t2.assertPipelinePrimaryTopicReference = function(e3, t3) {
          s("PipelinePrimaryTopicReference", e3, t3);
        }, t2.assertPipelineTopicExpression = function(e3, t3) {
          s("PipelineTopicExpression", e3, t3);
        }, t2.assertPlaceholder = function(e3, t3) {
          s("Placeholder", e3, t3);
        }, t2.assertPrivate = function(e3, t3) {
          s("Private", e3, t3);
        }, t2.assertPrivateName = function(e3, t3) {
          s("PrivateName", e3, t3);
        }, t2.assertProgram = function(e3, t3) {
          s("Program", e3, t3);
        }, t2.assertProperty = function(e3, t3) {
          s("Property", e3, t3);
        }, t2.assertPureish = function(e3, t3) {
          s("Pureish", e3, t3);
        }, t2.assertQualifiedTypeIdentifier = function(e3, t3) {
          s("QualifiedTypeIdentifier", e3, t3);
        }, t2.assertRecordExpression = function(e3, t3) {
          s("RecordExpression", e3, t3);
        }, t2.assertRegExpLiteral = function(e3, t3) {
          s("RegExpLiteral", e3, t3);
        }, t2.assertRegexLiteral = function(e3, t3) {
          (0, i.default)("assertRegexLiteral", "assertRegExpLiteral"), s("RegexLiteral", e3, t3);
        }, t2.assertRestElement = function(e3, t3) {
          s("RestElement", e3, t3);
        }, t2.assertRestProperty = function(e3, t3) {
          (0, i.default)("assertRestProperty", "assertRestElement"), s("RestProperty", e3, t3);
        }, t2.assertReturnStatement = function(e3, t3) {
          s("ReturnStatement", e3, t3);
        }, t2.assertScopable = function(e3, t3) {
          s("Scopable", e3, t3);
        }, t2.assertSequenceExpression = function(e3, t3) {
          s("SequenceExpression", e3, t3);
        }, t2.assertSpreadElement = function(e3, t3) {
          s("SpreadElement", e3, t3);
        }, t2.assertSpreadProperty = function(e3, t3) {
          (0, i.default)("assertSpreadProperty", "assertSpreadElement"), s("SpreadProperty", e3, t3);
        }, t2.assertStandardized = function(e3, t3) {
          s("Standardized", e3, t3);
        }, t2.assertStatement = function(e3, t3) {
          s("Statement", e3, t3);
        }, t2.assertStaticBlock = function(e3, t3) {
          s("StaticBlock", e3, t3);
        }, t2.assertStringLiteral = function(e3, t3) {
          s("StringLiteral", e3, t3);
        }, t2.assertStringLiteralTypeAnnotation = function(e3, t3) {
          s("StringLiteralTypeAnnotation", e3, t3);
        }, t2.assertStringTypeAnnotation = function(e3, t3) {
          s("StringTypeAnnotation", e3, t3);
        }, t2.assertSuper = function(e3, t3) {
          s("Super", e3, t3);
        }, t2.assertSwitchCase = function(e3, t3) {
          s("SwitchCase", e3, t3);
        }, t2.assertSwitchStatement = function(e3, t3) {
          s("SwitchStatement", e3, t3);
        }, t2.assertSymbolTypeAnnotation = function(e3, t3) {
          s("SymbolTypeAnnotation", e3, t3);
        }, t2.assertTSAnyKeyword = function(e3, t3) {
          s("TSAnyKeyword", e3, t3);
        }, t2.assertTSArrayType = function(e3, t3) {
          s("TSArrayType", e3, t3);
        }, t2.assertTSAsExpression = function(e3, t3) {
          s("TSAsExpression", e3, t3);
        }, t2.assertTSBaseType = function(e3, t3) {
          s("TSBaseType", e3, t3);
        }, t2.assertTSBigIntKeyword = function(e3, t3) {
          s("TSBigIntKeyword", e3, t3);
        }, t2.assertTSBooleanKeyword = function(e3, t3) {
          s("TSBooleanKeyword", e3, t3);
        }, t2.assertTSCallSignatureDeclaration = function(e3, t3) {
          s("TSCallSignatureDeclaration", e3, t3);
        }, t2.assertTSConditionalType = function(e3, t3) {
          s("TSConditionalType", e3, t3);
        }, t2.assertTSConstructSignatureDeclaration = function(e3, t3) {
          s("TSConstructSignatureDeclaration", e3, t3);
        }, t2.assertTSConstructorType = function(e3, t3) {
          s("TSConstructorType", e3, t3);
        }, t2.assertTSDeclareFunction = function(e3, t3) {
          s("TSDeclareFunction", e3, t3);
        }, t2.assertTSDeclareMethod = function(e3, t3) {
          s("TSDeclareMethod", e3, t3);
        }, t2.assertTSEntityName = function(e3, t3) {
          s("TSEntityName", e3, t3);
        }, t2.assertTSEnumDeclaration = function(e3, t3) {
          s("TSEnumDeclaration", e3, t3);
        }, t2.assertTSEnumMember = function(e3, t3) {
          s("TSEnumMember", e3, t3);
        }, t2.assertTSExportAssignment = function(e3, t3) {
          s("TSExportAssignment", e3, t3);
        }, t2.assertTSExpressionWithTypeArguments = function(e3, t3) {
          s("TSExpressionWithTypeArguments", e3, t3);
        }, t2.assertTSExternalModuleReference = function(e3, t3) {
          s("TSExternalModuleReference", e3, t3);
        }, t2.assertTSFunctionType = function(e3, t3) {
          s("TSFunctionType", e3, t3);
        }, t2.assertTSImportEqualsDeclaration = function(e3, t3) {
          s("TSImportEqualsDeclaration", e3, t3);
        }, t2.assertTSImportType = function(e3, t3) {
          s("TSImportType", e3, t3);
        }, t2.assertTSIndexSignature = function(e3, t3) {
          s("TSIndexSignature", e3, t3);
        }, t2.assertTSIndexedAccessType = function(e3, t3) {
          s("TSIndexedAccessType", e3, t3);
        }, t2.assertTSInferType = function(e3, t3) {
          s("TSInferType", e3, t3);
        }, t2.assertTSInstantiationExpression = function(e3, t3) {
          s("TSInstantiationExpression", e3, t3);
        }, t2.assertTSInterfaceBody = function(e3, t3) {
          s("TSInterfaceBody", e3, t3);
        }, t2.assertTSInterfaceDeclaration = function(e3, t3) {
          s("TSInterfaceDeclaration", e3, t3);
        }, t2.assertTSIntersectionType = function(e3, t3) {
          s("TSIntersectionType", e3, t3);
        }, t2.assertTSIntrinsicKeyword = function(e3, t3) {
          s("TSIntrinsicKeyword", e3, t3);
        }, t2.assertTSLiteralType = function(e3, t3) {
          s("TSLiteralType", e3, t3);
        }, t2.assertTSMappedType = function(e3, t3) {
          s("TSMappedType", e3, t3);
        }, t2.assertTSMethodSignature = function(e3, t3) {
          s("TSMethodSignature", e3, t3);
        }, t2.assertTSModuleBlock = function(e3, t3) {
          s("TSModuleBlock", e3, t3);
        }, t2.assertTSModuleDeclaration = function(e3, t3) {
          s("TSModuleDeclaration", e3, t3);
        }, t2.assertTSNamedTupleMember = function(e3, t3) {
          s("TSNamedTupleMember", e3, t3);
        }, t2.assertTSNamespaceExportDeclaration = function(e3, t3) {
          s("TSNamespaceExportDeclaration", e3, t3);
        }, t2.assertTSNeverKeyword = function(e3, t3) {
          s("TSNeverKeyword", e3, t3);
        }, t2.assertTSNonNullExpression = function(e3, t3) {
          s("TSNonNullExpression", e3, t3);
        }, t2.assertTSNullKeyword = function(e3, t3) {
          s("TSNullKeyword", e3, t3);
        }, t2.assertTSNumberKeyword = function(e3, t3) {
          s("TSNumberKeyword", e3, t3);
        }, t2.assertTSObjectKeyword = function(e3, t3) {
          s("TSObjectKeyword", e3, t3);
        }, t2.assertTSOptionalType = function(e3, t3) {
          s("TSOptionalType", e3, t3);
        }, t2.assertTSParameterProperty = function(e3, t3) {
          s("TSParameterProperty", e3, t3);
        }, t2.assertTSParenthesizedType = function(e3, t3) {
          s("TSParenthesizedType", e3, t3);
        }, t2.assertTSPropertySignature = function(e3, t3) {
          s("TSPropertySignature", e3, t3);
        }, t2.assertTSQualifiedName = function(e3, t3) {
          s("TSQualifiedName", e3, t3);
        }, t2.assertTSRestType = function(e3, t3) {
          s("TSRestType", e3, t3);
        }, t2.assertTSSatisfiesExpression = function(e3, t3) {
          s("TSSatisfiesExpression", e3, t3);
        }, t2.assertTSStringKeyword = function(e3, t3) {
          s("TSStringKeyword", e3, t3);
        }, t2.assertTSSymbolKeyword = function(e3, t3) {
          s("TSSymbolKeyword", e3, t3);
        }, t2.assertTSThisType = function(e3, t3) {
          s("TSThisType", e3, t3);
        }, t2.assertTSTupleType = function(e3, t3) {
          s("TSTupleType", e3, t3);
        }, t2.assertTSType = function(e3, t3) {
          s("TSType", e3, t3);
        }, t2.assertTSTypeAliasDeclaration = function(e3, t3) {
          s("TSTypeAliasDeclaration", e3, t3);
        }, t2.assertTSTypeAnnotation = function(e3, t3) {
          s("TSTypeAnnotation", e3, t3);
        }, t2.assertTSTypeAssertion = function(e3, t3) {
          s("TSTypeAssertion", e3, t3);
        }, t2.assertTSTypeElement = function(e3, t3) {
          s("TSTypeElement", e3, t3);
        }, t2.assertTSTypeLiteral = function(e3, t3) {
          s("TSTypeLiteral", e3, t3);
        }, t2.assertTSTypeOperator = function(e3, t3) {
          s("TSTypeOperator", e3, t3);
        }, t2.assertTSTypeParameter = function(e3, t3) {
          s("TSTypeParameter", e3, t3);
        }, t2.assertTSTypeParameterDeclaration = function(e3, t3) {
          s("TSTypeParameterDeclaration", e3, t3);
        }, t2.assertTSTypeParameterInstantiation = function(e3, t3) {
          s("TSTypeParameterInstantiation", e3, t3);
        }, t2.assertTSTypePredicate = function(e3, t3) {
          s("TSTypePredicate", e3, t3);
        }, t2.assertTSTypeQuery = function(e3, t3) {
          s("TSTypeQuery", e3, t3);
        }, t2.assertTSTypeReference = function(e3, t3) {
          s("TSTypeReference", e3, t3);
        }, t2.assertTSUndefinedKeyword = function(e3, t3) {
          s("TSUndefinedKeyword", e3, t3);
        }, t2.assertTSUnionType = function(e3, t3) {
          s("TSUnionType", e3, t3);
        }, t2.assertTSUnknownKeyword = function(e3, t3) {
          s("TSUnknownKeyword", e3, t3);
        }, t2.assertTSVoidKeyword = function(e3, t3) {
          s("TSVoidKeyword", e3, t3);
        }, t2.assertTaggedTemplateExpression = function(e3, t3) {
          s("TaggedTemplateExpression", e3, t3);
        }, t2.assertTemplateElement = function(e3, t3) {
          s("TemplateElement", e3, t3);
        }, t2.assertTemplateLiteral = function(e3, t3) {
          s("TemplateLiteral", e3, t3);
        }, t2.assertTerminatorless = function(e3, t3) {
          s("Terminatorless", e3, t3);
        }, t2.assertThisExpression = function(e3, t3) {
          s("ThisExpression", e3, t3);
        }, t2.assertThisTypeAnnotation = function(e3, t3) {
          s("ThisTypeAnnotation", e3, t3);
        }, t2.assertThrowStatement = function(e3, t3) {
          s("ThrowStatement", e3, t3);
        }, t2.assertTopicReference = function(e3, t3) {
          s("TopicReference", e3, t3);
        }, t2.assertTryStatement = function(e3, t3) {
          s("TryStatement", e3, t3);
        }, t2.assertTupleExpression = function(e3, t3) {
          s("TupleExpression", e3, t3);
        }, t2.assertTupleTypeAnnotation = function(e3, t3) {
          s("TupleTypeAnnotation", e3, t3);
        }, t2.assertTypeAlias = function(e3, t3) {
          s("TypeAlias", e3, t3);
        }, t2.assertTypeAnnotation = function(e3, t3) {
          s("TypeAnnotation", e3, t3);
        }, t2.assertTypeCastExpression = function(e3, t3) {
          s("TypeCastExpression", e3, t3);
        }, t2.assertTypeParameter = function(e3, t3) {
          s("TypeParameter", e3, t3);
        }, t2.assertTypeParameterDeclaration = function(e3, t3) {
          s("TypeParameterDeclaration", e3, t3);
        }, t2.assertTypeParameterInstantiation = function(e3, t3) {
          s("TypeParameterInstantiation", e3, t3);
        }, t2.assertTypeScript = function(e3, t3) {
          s("TypeScript", e3, t3);
        }, t2.assertTypeofTypeAnnotation = function(e3, t3) {
          s("TypeofTypeAnnotation", e3, t3);
        }, t2.assertUnaryExpression = function(e3, t3) {
          s("UnaryExpression", e3, t3);
        }, t2.assertUnaryLike = function(e3, t3) {
          s("UnaryLike", e3, t3);
        }, t2.assertUnionTypeAnnotation = function(e3, t3) {
          s("UnionTypeAnnotation", e3, t3);
        }, t2.assertUpdateExpression = function(e3, t3) {
          s("UpdateExpression", e3, t3);
        }, t2.assertUserWhitespacable = function(e3, t3) {
          s("UserWhitespacable", e3, t3);
        }, t2.assertV8IntrinsicIdentifier = function(e3, t3) {
          s("V8IntrinsicIdentifier", e3, t3);
        }, t2.assertVariableDeclaration = function(e3, t3) {
          s("VariableDeclaration", e3, t3);
        }, t2.assertVariableDeclarator = function(e3, t3) {
          s("VariableDeclarator", e3, t3);
        }, t2.assertVariance = function(e3, t3) {
          s("Variance", e3, t3);
        }, t2.assertVoidTypeAnnotation = function(e3, t3) {
          s("VoidTypeAnnotation", e3, t3);
        }, t2.assertWhile = function(e3, t3) {
          s("While", e3, t3);
        }, t2.assertWhileStatement = function(e3, t3) {
          s("WhileStatement", e3, t3);
        }, t2.assertWithStatement = function(e3, t3) {
          s("WithStatement", e3, t3);
        }, t2.assertYieldExpression = function(e3, t3) {
          s("YieldExpression", e3, t3);
        };
        var r2 = n2(5171), i = n2(4619);
        function s(e3, t3, n3) {
          if (!(0, r2.default)(e3, t3, n3)) throw new Error(`Expected type "${e3}" with option ${JSON.stringify(n3)}, but instead got "${t3.type}".`);
        }
      }, 7625: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
          const t3 = (0, i.default)(e3);
          return 1 === t3.length ? t3[0] : (0, r2.unionTypeAnnotation)(t3);
        };
        var r2 = n2(1411), i = n2(8874);
      }, 5976: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var r2 = n2(1411);
        t2.default = function(e3) {
          switch (e3) {
            case "string":
              return (0, r2.stringTypeAnnotation)();
            case "number":
              return (0, r2.numberTypeAnnotation)();
            case "undefined":
              return (0, r2.voidTypeAnnotation)();
            case "boolean":
              return (0, r2.booleanTypeAnnotation)();
            case "function":
              return (0, r2.genericTypeAnnotation)((0, r2.identifier)("Function"));
            case "object":
              return (0, r2.genericTypeAnnotation)((0, r2.identifier)("Object"));
            case "symbol":
              return (0, r2.genericTypeAnnotation)((0, r2.identifier)("Symbol"));
            case "bigint":
              return (0, r2.anyTypeAnnotation)();
          }
          throw new Error("Invalid typeof value: " + e3);
        };
      }, 1411: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.anyTypeAnnotation = function() {
          return { type: "AnyTypeAnnotation" };
        }, t2.argumentPlaceholder = function() {
          return { type: "ArgumentPlaceholder" };
        }, t2.arrayExpression = function(e3 = []) {
          return (0, r2.default)({ type: "ArrayExpression", elements: e3 });
        }, t2.arrayPattern = function(e3) {
          return (0, r2.default)({ type: "ArrayPattern", elements: e3 });
        }, t2.arrayTypeAnnotation = function(e3) {
          return (0, r2.default)({ type: "ArrayTypeAnnotation", elementType: e3 });
        }, t2.arrowFunctionExpression = function(e3, t3, n3 = false) {
          return (0, r2.default)({ type: "ArrowFunctionExpression", params: e3, body: t3, async: n3, expression: null });
        }, t2.assignmentExpression = function(e3, t3, n3) {
          return (0, r2.default)({ type: "AssignmentExpression", operator: e3, left: t3, right: n3 });
        }, t2.assignmentPattern = function(e3, t3) {
          return (0, r2.default)({ type: "AssignmentPattern", left: e3, right: t3 });
        }, t2.awaitExpression = function(e3) {
          return (0, r2.default)({ type: "AwaitExpression", argument: e3 });
        }, t2.bigIntLiteral = function(e3) {
          return (0, r2.default)({ type: "BigIntLiteral", value: e3 });
        }, t2.binaryExpression = function(e3, t3, n3) {
          return (0, r2.default)({ type: "BinaryExpression", operator: e3, left: t3, right: n3 });
        }, t2.bindExpression = function(e3, t3) {
          return (0, r2.default)({ type: "BindExpression", object: e3, callee: t3 });
        }, t2.blockStatement = function(e3, t3 = []) {
          return (0, r2.default)({ type: "BlockStatement", body: e3, directives: t3 });
        }, t2.booleanLiteral = function(e3) {
          return (0, r2.default)({ type: "BooleanLiteral", value: e3 });
        }, t2.booleanLiteralTypeAnnotation = function(e3) {
          return (0, r2.default)({ type: "BooleanLiteralTypeAnnotation", value: e3 });
        }, t2.booleanTypeAnnotation = function() {
          return { type: "BooleanTypeAnnotation" };
        }, t2.breakStatement = function(e3 = null) {
          return (0, r2.default)({ type: "BreakStatement", label: e3 });
        }, t2.callExpression = function(e3, t3) {
          return (0, r2.default)({ type: "CallExpression", callee: e3, arguments: t3 });
        }, t2.catchClause = function(e3 = null, t3) {
          return (0, r2.default)({ type: "CatchClause", param: e3, body: t3 });
        }, t2.classAccessorProperty = function(e3, t3 = null, n3 = null, i2 = null, s2 = false, a2 = false) {
          return (0, r2.default)({ type: "ClassAccessorProperty", key: e3, value: t3, typeAnnotation: n3, decorators: i2, computed: s2, static: a2 });
        }, t2.classBody = function(e3) {
          return (0, r2.default)({ type: "ClassBody", body: e3 });
        }, t2.classDeclaration = function(e3, t3 = null, n3, i2 = null) {
          return (0, r2.default)({ type: "ClassDeclaration", id: e3, superClass: t3, body: n3, decorators: i2 });
        }, t2.classExpression = function(e3 = null, t3 = null, n3, i2 = null) {
          return (0, r2.default)({ type: "ClassExpression", id: e3, superClass: t3, body: n3, decorators: i2 });
        }, t2.classImplements = function(e3, t3 = null) {
          return (0, r2.default)({ type: "ClassImplements", id: e3, typeParameters: t3 });
        }, t2.classMethod = function(e3 = "method", t3, n3, i2, s2 = false, a2 = false, o2 = false, l2 = false) {
          return (0, r2.default)({ type: "ClassMethod", kind: e3, key: t3, params: n3, body: i2, computed: s2, static: a2, generator: o2, async: l2 });
        }, t2.classPrivateMethod = function(e3 = "method", t3, n3, i2, s2 = false) {
          return (0, r2.default)({ type: "ClassPrivateMethod", kind: e3, key: t3, params: n3, body: i2, static: s2 });
        }, t2.classPrivateProperty = function(e3, t3 = null, n3 = null, i2 = false) {
          return (0, r2.default)({ type: "ClassPrivateProperty", key: e3, value: t3, decorators: n3, static: i2 });
        }, t2.classProperty = function(e3, t3 = null, n3 = null, i2 = null, s2 = false, a2 = false) {
          return (0, r2.default)({ type: "ClassProperty", key: e3, value: t3, typeAnnotation: n3, decorators: i2, computed: s2, static: a2 });
        }, t2.conditionalExpression = function(e3, t3, n3) {
          return (0, r2.default)({ type: "ConditionalExpression", test: e3, consequent: t3, alternate: n3 });
        }, t2.continueStatement = function(e3 = null) {
          return (0, r2.default)({ type: "ContinueStatement", label: e3 });
        }, t2.debuggerStatement = function() {
          return { type: "DebuggerStatement" };
        }, t2.decimalLiteral = function(e3) {
          return (0, r2.default)({ type: "DecimalLiteral", value: e3 });
        }, t2.declareClass = function(e3, t3 = null, n3 = null, i2) {
          return (0, r2.default)({ type: "DeclareClass", id: e3, typeParameters: t3, extends: n3, body: i2 });
        }, t2.declareExportAllDeclaration = function(e3) {
          return (0, r2.default)({ type: "DeclareExportAllDeclaration", source: e3 });
        }, t2.declareExportDeclaration = function(e3 = null, t3 = null, n3 = null) {
          return (0, r2.default)({ type: "DeclareExportDeclaration", declaration: e3, specifiers: t3, source: n3 });
        }, t2.declareFunction = function(e3) {
          return (0, r2.default)({ type: "DeclareFunction", id: e3 });
        }, t2.declareInterface = function(e3, t3 = null, n3 = null, i2) {
          return (0, r2.default)({ type: "DeclareInterface", id: e3, typeParameters: t3, extends: n3, body: i2 });
        }, t2.declareModule = function(e3, t3, n3 = null) {
          return (0, r2.default)({ type: "DeclareModule", id: e3, body: t3, kind: n3 });
        }, t2.declareModuleExports = function(e3) {
          return (0, r2.default)({ type: "DeclareModuleExports", typeAnnotation: e3 });
        }, t2.declareOpaqueType = function(e3, t3 = null, n3 = null) {
          return (0, r2.default)({ type: "DeclareOpaqueType", id: e3, typeParameters: t3, supertype: n3 });
        }, t2.declareTypeAlias = function(e3, t3 = null, n3) {
          return (0, r2.default)({ type: "DeclareTypeAlias", id: e3, typeParameters: t3, right: n3 });
        }, t2.declareVariable = function(e3) {
          return (0, r2.default)({ type: "DeclareVariable", id: e3 });
        }, t2.declaredPredicate = function(e3) {
          return (0, r2.default)({ type: "DeclaredPredicate", value: e3 });
        }, t2.decorator = function(e3) {
          return (0, r2.default)({ type: "Decorator", expression: e3 });
        }, t2.directive = function(e3) {
          return (0, r2.default)({ type: "Directive", value: e3 });
        }, t2.directiveLiteral = function(e3) {
          return (0, r2.default)({ type: "DirectiveLiteral", value: e3 });
        }, t2.doExpression = function(e3, t3 = false) {
          return (0, r2.default)({ type: "DoExpression", body: e3, async: t3 });
        }, t2.doWhileStatement = function(e3, t3) {
          return (0, r2.default)({ type: "DoWhileStatement", test: e3, body: t3 });
        }, t2.emptyStatement = function() {
          return { type: "EmptyStatement" };
        }, t2.emptyTypeAnnotation = function() {
          return { type: "EmptyTypeAnnotation" };
        }, t2.enumBooleanBody = function(e3) {
          return (0, r2.default)({ type: "EnumBooleanBody", members: e3, explicitType: null, hasUnknownMembers: null });
        }, t2.enumBooleanMember = function(e3) {
          return (0, r2.default)({ type: "EnumBooleanMember", id: e3, init: null });
        }, t2.enumDeclaration = function(e3, t3) {
          return (0, r2.default)({ type: "EnumDeclaration", id: e3, body: t3 });
        }, t2.enumDefaultedMember = function(e3) {
          return (0, r2.default)({ type: "EnumDefaultedMember", id: e3 });
        }, t2.enumNumberBody = function(e3) {
          return (0, r2.default)({ type: "EnumNumberBody", members: e3, explicitType: null, hasUnknownMembers: null });
        }, t2.enumNumberMember = function(e3, t3) {
          return (0, r2.default)({ type: "EnumNumberMember", id: e3, init: t3 });
        }, t2.enumStringBody = function(e3) {
          return (0, r2.default)({ type: "EnumStringBody", members: e3, explicitType: null, hasUnknownMembers: null });
        }, t2.enumStringMember = function(e3, t3) {
          return (0, r2.default)({ type: "EnumStringMember", id: e3, init: t3 });
        }, t2.enumSymbolBody = function(e3) {
          return (0, r2.default)({ type: "EnumSymbolBody", members: e3, hasUnknownMembers: null });
        }, t2.existsTypeAnnotation = function() {
          return { type: "ExistsTypeAnnotation" };
        }, t2.exportAllDeclaration = function(e3) {
          return (0, r2.default)({ type: "ExportAllDeclaration", source: e3 });
        }, t2.exportDefaultDeclaration = function(e3) {
          return (0, r2.default)({ type: "ExportDefaultDeclaration", declaration: e3 });
        }, t2.exportDefaultSpecifier = function(e3) {
          return (0, r2.default)({ type: "ExportDefaultSpecifier", exported: e3 });
        }, t2.exportNamedDeclaration = function(e3 = null, t3 = [], n3 = null) {
          return (0, r2.default)({ type: "ExportNamedDeclaration", declaration: e3, specifiers: t3, source: n3 });
        }, t2.exportNamespaceSpecifier = function(e3) {
          return (0, r2.default)({ type: "ExportNamespaceSpecifier", exported: e3 });
        }, t2.exportSpecifier = function(e3, t3) {
          return (0, r2.default)({ type: "ExportSpecifier", local: e3, exported: t3 });
        }, t2.expressionStatement = function(e3) {
          return (0, r2.default)({ type: "ExpressionStatement", expression: e3 });
        }, t2.file = function(e3, t3 = null, n3 = null) {
          return (0, r2.default)({ type: "File", program: e3, comments: t3, tokens: n3 });
        }, t2.forInStatement = function(e3, t3, n3) {
          return (0, r2.default)({ type: "ForInStatement", left: e3, right: t3, body: n3 });
        }, t2.forOfStatement = function(e3, t3, n3, i2 = false) {
          return (0, r2.default)({ type: "ForOfStatement", left: e3, right: t3, body: n3, await: i2 });
        }, t2.forStatement = function(e3 = null, t3 = null, n3 = null, i2) {
          return (0, r2.default)({ type: "ForStatement", init: e3, test: t3, update: n3, body: i2 });
        }, t2.functionDeclaration = function(e3 = null, t3, n3, i2 = false, s2 = false) {
          return (0, r2.default)({ type: "FunctionDeclaration", id: e3, params: t3, body: n3, generator: i2, async: s2 });
        }, t2.functionExpression = function(e3 = null, t3, n3, i2 = false, s2 = false) {
          return (0, r2.default)({ type: "FunctionExpression", id: e3, params: t3, body: n3, generator: i2, async: s2 });
        }, t2.functionTypeAnnotation = function(e3 = null, t3, n3 = null, i2) {
          return (0, r2.default)({ type: "FunctionTypeAnnotation", typeParameters: e3, params: t3, rest: n3, returnType: i2 });
        }, t2.functionTypeParam = function(e3 = null, t3) {
          return (0, r2.default)({ type: "FunctionTypeParam", name: e3, typeAnnotation: t3 });
        }, t2.genericTypeAnnotation = function(e3, t3 = null) {
          return (0, r2.default)({ type: "GenericTypeAnnotation", id: e3, typeParameters: t3 });
        }, t2.identifier = function(e3) {
          return (0, r2.default)({ type: "Identifier", name: e3 });
        }, t2.ifStatement = function(e3, t3, n3 = null) {
          return (0, r2.default)({ type: "IfStatement", test: e3, consequent: t3, alternate: n3 });
        }, t2.import = function() {
          return { type: "Import" };
        }, t2.importAttribute = function(e3, t3) {
          return (0, r2.default)({ type: "ImportAttribute", key: e3, value: t3 });
        }, t2.importDeclaration = function(e3, t3) {
          return (0, r2.default)({ type: "ImportDeclaration", specifiers: e3, source: t3 });
        }, t2.importDefaultSpecifier = function(e3) {
          return (0, r2.default)({ type: "ImportDefaultSpecifier", local: e3 });
        }, t2.importNamespaceSpecifier = function(e3) {
          return (0, r2.default)({ type: "ImportNamespaceSpecifier", local: e3 });
        }, t2.importSpecifier = function(e3, t3) {
          return (0, r2.default)({ type: "ImportSpecifier", local: e3, imported: t3 });
        }, t2.indexedAccessType = function(e3, t3) {
          return (0, r2.default)({ type: "IndexedAccessType", objectType: e3, indexType: t3 });
        }, t2.inferredPredicate = function() {
          return { type: "InferredPredicate" };
        }, t2.interfaceDeclaration = function(e3, t3 = null, n3 = null, i2) {
          return (0, r2.default)({ type: "InterfaceDeclaration", id: e3, typeParameters: t3, extends: n3, body: i2 });
        }, t2.interfaceExtends = function(e3, t3 = null) {
          return (0, r2.default)({ type: "InterfaceExtends", id: e3, typeParameters: t3 });
        }, t2.interfaceTypeAnnotation = function(e3 = null, t3) {
          return (0, r2.default)({ type: "InterfaceTypeAnnotation", extends: e3, body: t3 });
        }, t2.interpreterDirective = function(e3) {
          return (0, r2.default)({ type: "InterpreterDirective", value: e3 });
        }, t2.intersectionTypeAnnotation = function(e3) {
          return (0, r2.default)({ type: "IntersectionTypeAnnotation", types: e3 });
        }, t2.jSXAttribute = t2.jsxAttribute = function(e3, t3 = null) {
          return (0, r2.default)({ type: "JSXAttribute", name: e3, value: t3 });
        }, t2.jSXClosingElement = t2.jsxClosingElement = function(e3) {
          return (0, r2.default)({ type: "JSXClosingElement", name: e3 });
        }, t2.jSXClosingFragment = t2.jsxClosingFragment = function() {
          return { type: "JSXClosingFragment" };
        }, t2.jSXElement = t2.jsxElement = function(e3, t3 = null, n3, i2 = null) {
          return (0, r2.default)({ type: "JSXElement", openingElement: e3, closingElement: t3, children: n3, selfClosing: i2 });
        }, t2.jSXEmptyExpression = t2.jsxEmptyExpression = function() {
          return { type: "JSXEmptyExpression" };
        }, t2.jSXExpressionContainer = t2.jsxExpressionContainer = function(e3) {
          return (0, r2.default)({ type: "JSXExpressionContainer", expression: e3 });
        }, t2.jSXFragment = t2.jsxFragment = function(e3, t3, n3) {
          return (0, r2.default)({ type: "JSXFragment", openingFragment: e3, closingFragment: t3, children: n3 });
        }, t2.jSXIdentifier = t2.jsxIdentifier = function(e3) {
          return (0, r2.default)({ type: "JSXIdentifier", name: e3 });
        }, t2.jSXMemberExpression = t2.jsxMemberExpression = function(e3, t3) {
          return (0, r2.default)({ type: "JSXMemberExpression", object: e3, property: t3 });
        }, t2.jSXNamespacedName = t2.jsxNamespacedName = function(e3, t3) {
          return (0, r2.default)({ type: "JSXNamespacedName", namespace: e3, name: t3 });
        }, t2.jSXOpeningElement = t2.jsxOpeningElement = function(e3, t3, n3 = false) {
          return (0, r2.default)({ type: "JSXOpeningElement", name: e3, attributes: t3, selfClosing: n3 });
        }, t2.jSXOpeningFragment = t2.jsxOpeningFragment = function() {
          return { type: "JSXOpeningFragment" };
        }, t2.jSXSpreadAttribute = t2.jsxSpreadAttribute = function(e3) {
          return (0, r2.default)({ type: "JSXSpreadAttribute", argument: e3 });
        }, t2.jSXSpreadChild = t2.jsxSpreadChild = function(e3) {
          return (0, r2.default)({ type: "JSXSpreadChild", expression: e3 });
        }, t2.jSXText = t2.jsxText = function(e3) {
          return (0, r2.default)({ type: "JSXText", value: e3 });
        }, t2.labeledStatement = function(e3, t3) {
          return (0, r2.default)({ type: "LabeledStatement", label: e3, body: t3 });
        }, t2.logicalExpression = function(e3, t3, n3) {
          return (0, r2.default)({ type: "LogicalExpression", operator: e3, left: t3, right: n3 });
        }, t2.memberExpression = function(e3, t3, n3 = false, i2 = null) {
          return (0, r2.default)({ type: "MemberExpression", object: e3, property: t3, computed: n3, optional: i2 });
        }, t2.metaProperty = function(e3, t3) {
          return (0, r2.default)({ type: "MetaProperty", meta: e3, property: t3 });
        }, t2.mixedTypeAnnotation = function() {
          return { type: "MixedTypeAnnotation" };
        }, t2.moduleExpression = function(e3) {
          return (0, r2.default)({ type: "ModuleExpression", body: e3 });
        }, t2.newExpression = function(e3, t3) {
          return (0, r2.default)({ type: "NewExpression", callee: e3, arguments: t3 });
        }, t2.noop = function() {
          return { type: "Noop" };
        }, t2.nullLiteral = function() {
          return { type: "NullLiteral" };
        }, t2.nullLiteralTypeAnnotation = function() {
          return { type: "NullLiteralTypeAnnotation" };
        }, t2.nullableTypeAnnotation = function(e3) {
          return (0, r2.default)({ type: "NullableTypeAnnotation", typeAnnotation: e3 });
        }, t2.numberLiteral = function(e3) {
          return (0, i.default)("NumberLiteral", "NumericLiteral", "The node type "), s(e3);
        }, t2.numberLiteralTypeAnnotation = function(e3) {
          return (0, r2.default)({ type: "NumberLiteralTypeAnnotation", value: e3 });
        }, t2.numberTypeAnnotation = function() {
          return { type: "NumberTypeAnnotation" };
        }, t2.numericLiteral = s, t2.objectExpression = function(e3) {
          return (0, r2.default)({ type: "ObjectExpression", properties: e3 });
        }, t2.objectMethod = function(e3 = "method", t3, n3, i2, s2 = false, a2 = false, o2 = false) {
          return (0, r2.default)({ type: "ObjectMethod", kind: e3, key: t3, params: n3, body: i2, computed: s2, generator: a2, async: o2 });
        }, t2.objectPattern = function(e3) {
          return (0, r2.default)({ type: "ObjectPattern", properties: e3 });
        }, t2.objectProperty = function(e3, t3, n3 = false, i2 = false, s2 = null) {
          return (0, r2.default)({ type: "ObjectProperty", key: e3, value: t3, computed: n3, shorthand: i2, decorators: s2 });
        }, t2.objectTypeAnnotation = function(e3, t3 = [], n3 = [], i2 = [], s2 = false) {
          return (0, r2.default)({ type: "ObjectTypeAnnotation", properties: e3, indexers: t3, callProperties: n3, internalSlots: i2, exact: s2 });
        }, t2.objectTypeCallProperty = function(e3) {
          return (0, r2.default)({ type: "ObjectTypeCallProperty", value: e3, static: null });
        }, t2.objectTypeIndexer = function(e3 = null, t3, n3, i2 = null) {
          return (0, r2.default)({ type: "ObjectTypeIndexer", id: e3, key: t3, value: n3, variance: i2, static: null });
        }, t2.objectTypeInternalSlot = function(e3, t3, n3, i2, s2) {
          return (0, r2.default)({ type: "ObjectTypeInternalSlot", id: e3, value: t3, optional: n3, static: i2, method: s2 });
        }, t2.objectTypeProperty = function(e3, t3, n3 = null) {
          return (0, r2.default)({ type: "ObjectTypeProperty", key: e3, value: t3, variance: n3, kind: null, method: null, optional: null, proto: null, static: null });
        }, t2.objectTypeSpreadProperty = function(e3) {
          return (0, r2.default)({ type: "ObjectTypeSpreadProperty", argument: e3 });
        }, t2.opaqueType = function(e3, t3 = null, n3 = null, i2) {
          return (0, r2.default)({ type: "OpaqueType", id: e3, typeParameters: t3, supertype: n3, impltype: i2 });
        }, t2.optionalCallExpression = function(e3, t3, n3) {
          return (0, r2.default)({ type: "OptionalCallExpression", callee: e3, arguments: t3, optional: n3 });
        }, t2.optionalIndexedAccessType = function(e3, t3) {
          return (0, r2.default)({ type: "OptionalIndexedAccessType", objectType: e3, indexType: t3, optional: null });
        }, t2.optionalMemberExpression = function(e3, t3, n3 = false, i2) {
          return (0, r2.default)({ type: "OptionalMemberExpression", object: e3, property: t3, computed: n3, optional: i2 });
        }, t2.parenthesizedExpression = function(e3) {
          return (0, r2.default)({ type: "ParenthesizedExpression", expression: e3 });
        }, t2.pipelineBareFunction = function(e3) {
          return (0, r2.default)({ type: "PipelineBareFunction", callee: e3 });
        }, t2.pipelinePrimaryTopicReference = function() {
          return { type: "PipelinePrimaryTopicReference" };
        }, t2.pipelineTopicExpression = function(e3) {
          return (0, r2.default)({ type: "PipelineTopicExpression", expression: e3 });
        }, t2.placeholder = function(e3, t3) {
          return (0, r2.default)({ type: "Placeholder", expectedNode: e3, name: t3 });
        }, t2.privateName = function(e3) {
          return (0, r2.default)({ type: "PrivateName", id: e3 });
        }, t2.program = function(e3, t3 = [], n3 = "script", i2 = null) {
          return (0, r2.default)({ type: "Program", body: e3, directives: t3, sourceType: n3, interpreter: i2, sourceFile: null });
        }, t2.qualifiedTypeIdentifier = function(e3, t3) {
          return (0, r2.default)({ type: "QualifiedTypeIdentifier", id: e3, qualification: t3 });
        }, t2.recordExpression = function(e3) {
          return (0, r2.default)({ type: "RecordExpression", properties: e3 });
        }, t2.regExpLiteral = a, t2.regexLiteral = function(e3, t3 = "") {
          return (0, i.default)("RegexLiteral", "RegExpLiteral", "The node type "), a(e3, t3);
        }, t2.restElement = o, t2.restProperty = function(e3) {
          return (0, i.default)("RestProperty", "RestElement", "The node type "), o(e3);
        }, t2.returnStatement = function(e3 = null) {
          return (0, r2.default)({ type: "ReturnStatement", argument: e3 });
        }, t2.sequenceExpression = function(e3) {
          return (0, r2.default)({ type: "SequenceExpression", expressions: e3 });
        }, t2.spreadElement = l, t2.spreadProperty = function(e3) {
          return (0, i.default)("SpreadProperty", "SpreadElement", "The node type "), l(e3);
        }, t2.staticBlock = function(e3) {
          return (0, r2.default)({ type: "StaticBlock", body: e3 });
        }, t2.stringLiteral = function(e3) {
          return (0, r2.default)({ type: "StringLiteral", value: e3 });
        }, t2.stringLiteralTypeAnnotation = function(e3) {
          return (0, r2.default)({ type: "StringLiteralTypeAnnotation", value: e3 });
        }, t2.stringTypeAnnotation = function() {
          return { type: "StringTypeAnnotation" };
        }, t2.super = function() {
          return { type: "Super" };
        }, t2.switchCase = function(e3 = null, t3) {
          return (0, r2.default)({ type: "SwitchCase", test: e3, consequent: t3 });
        }, t2.switchStatement = function(e3, t3) {
          return (0, r2.default)({ type: "SwitchStatement", discriminant: e3, cases: t3 });
        }, t2.symbolTypeAnnotation = function() {
          return { type: "SymbolTypeAnnotation" };
        }, t2.taggedTemplateExpression = function(e3, t3) {
          return (0, r2.default)({ type: "TaggedTemplateExpression", tag: e3, quasi: t3 });
        }, t2.templateElement = function(e3, t3 = false) {
          return (0, r2.default)({ type: "TemplateElement", value: e3, tail: t3 });
        }, t2.templateLiteral = function(e3, t3) {
          return (0, r2.default)({ type: "TemplateLiteral", quasis: e3, expressions: t3 });
        }, t2.thisExpression = function() {
          return { type: "ThisExpression" };
        }, t2.thisTypeAnnotation = function() {
          return { type: "ThisTypeAnnotation" };
        }, t2.throwStatement = function(e3) {
          return (0, r2.default)({ type: "ThrowStatement", argument: e3 });
        }, t2.topicReference = function() {
          return { type: "TopicReference" };
        }, t2.tryStatement = function(e3, t3 = null, n3 = null) {
          return (0, r2.default)({ type: "TryStatement", block: e3, handler: t3, finalizer: n3 });
        }, t2.tSAnyKeyword = t2.tsAnyKeyword = function() {
          return { type: "TSAnyKeyword" };
        }, t2.tSArrayType = t2.tsArrayType = function(e3) {
          return (0, r2.default)({ type: "TSArrayType", elementType: e3 });
        }, t2.tSAsExpression = t2.tsAsExpression = function(e3, t3) {
          return (0, r2.default)({ type: "TSAsExpression", expression: e3, typeAnnotation: t3 });
        }, t2.tSBigIntKeyword = t2.tsBigIntKeyword = function() {
          return { type: "TSBigIntKeyword" };
        }, t2.tSBooleanKeyword = t2.tsBooleanKeyword = function() {
          return { type: "TSBooleanKeyword" };
        }, t2.tSCallSignatureDeclaration = t2.tsCallSignatureDeclaration = function(e3 = null, t3, n3 = null) {
          return (0, r2.default)({ type: "TSCallSignatureDeclaration", typeParameters: e3, parameters: t3, typeAnnotation: n3 });
        }, t2.tSConditionalType = t2.tsConditionalType = function(e3, t3, n3, i2) {
          return (0, r2.default)({ type: "TSConditionalType", checkType: e3, extendsType: t3, trueType: n3, falseType: i2 });
        }, t2.tSConstructSignatureDeclaration = t2.tsConstructSignatureDeclaration = function(e3 = null, t3, n3 = null) {
          return (0, r2.default)({ type: "TSConstructSignatureDeclaration", typeParameters: e3, parameters: t3, typeAnnotation: n3 });
        }, t2.tSConstructorType = t2.tsConstructorType = function(e3 = null, t3, n3 = null) {
          return (0, r2.default)({ type: "TSConstructorType", typeParameters: e3, parameters: t3, typeAnnotation: n3 });
        }, t2.tSDeclareFunction = t2.tsDeclareFunction = function(e3 = null, t3 = null, n3, i2 = null) {
          return (0, r2.default)({ type: "TSDeclareFunction", id: e3, typeParameters: t3, params: n3, returnType: i2 });
        }, t2.tSDeclareMethod = t2.tsDeclareMethod = function(e3 = null, t3, n3 = null, i2, s2 = null) {
          return (0, r2.default)({ type: "TSDeclareMethod", decorators: e3, key: t3, typeParameters: n3, params: i2, returnType: s2 });
        }, t2.tSEnumDeclaration = t2.tsEnumDeclaration = function(e3, t3) {
          return (0, r2.default)({ type: "TSEnumDeclaration", id: e3, members: t3 });
        }, t2.tSEnumMember = t2.tsEnumMember = function(e3, t3 = null) {
          return (0, r2.default)({ type: "TSEnumMember", id: e3, initializer: t3 });
        }, t2.tSExportAssignment = t2.tsExportAssignment = function(e3) {
          return (0, r2.default)({ type: "TSExportAssignment", expression: e3 });
        }, t2.tSExpressionWithTypeArguments = t2.tsExpressionWithTypeArguments = function(e3, t3 = null) {
          return (0, r2.default)({ type: "TSExpressionWithTypeArguments", expression: e3, typeParameters: t3 });
        }, t2.tSExternalModuleReference = t2.tsExternalModuleReference = function(e3) {
          return (0, r2.default)({ type: "TSExternalModuleReference", expression: e3 });
        }, t2.tSFunctionType = t2.tsFunctionType = function(e3 = null, t3, n3 = null) {
          return (0, r2.default)({ type: "TSFunctionType", typeParameters: e3, parameters: t3, typeAnnotation: n3 });
        }, t2.tSImportEqualsDeclaration = t2.tsImportEqualsDeclaration = function(e3, t3) {
          return (0, r2.default)({ type: "TSImportEqualsDeclaration", id: e3, moduleReference: t3, isExport: null });
        }, t2.tSImportType = t2.tsImportType = function(e3, t3 = null, n3 = null) {
          return (0, r2.default)({ type: "TSImportType", argument: e3, qualifier: t3, typeParameters: n3 });
        }, t2.tSIndexSignature = t2.tsIndexSignature = function(e3, t3 = null) {
          return (0, r2.default)({ type: "TSIndexSignature", parameters: e3, typeAnnotation: t3 });
        }, t2.tSIndexedAccessType = t2.tsIndexedAccessType = function(e3, t3) {
          return (0, r2.default)({ type: "TSIndexedAccessType", objectType: e3, indexType: t3 });
        }, t2.tSInferType = t2.tsInferType = function(e3) {
          return (0, r2.default)({ type: "TSInferType", typeParameter: e3 });
        }, t2.tSInstantiationExpression = t2.tsInstantiationExpression = function(e3, t3 = null) {
          return (0, r2.default)({ type: "TSInstantiationExpression", expression: e3, typeParameters: t3 });
        }, t2.tSInterfaceBody = t2.tsInterfaceBody = function(e3) {
          return (0, r2.default)({ type: "TSInterfaceBody", body: e3 });
        }, t2.tSInterfaceDeclaration = t2.tsInterfaceDeclaration = function(e3, t3 = null, n3 = null, i2) {
          return (0, r2.default)({ type: "TSInterfaceDeclaration", id: e3, typeParameters: t3, extends: n3, body: i2 });
        }, t2.tSIntersectionType = t2.tsIntersectionType = function(e3) {
          return (0, r2.default)({ type: "TSIntersectionType", types: e3 });
        }, t2.tSIntrinsicKeyword = t2.tsIntrinsicKeyword = function() {
          return { type: "TSIntrinsicKeyword" };
        }, t2.tSLiteralType = t2.tsLiteralType = function(e3) {
          return (0, r2.default)({ type: "TSLiteralType", literal: e3 });
        }, t2.tSMappedType = t2.tsMappedType = function(e3, t3 = null, n3 = null) {
          return (0, r2.default)({ type: "TSMappedType", typeParameter: e3, typeAnnotation: t3, nameType: n3 });
        }, t2.tSMethodSignature = t2.tsMethodSignature = function(e3, t3 = null, n3, i2 = null) {
          return (0, r2.default)({ type: "TSMethodSignature", key: e3, typeParameters: t3, parameters: n3, typeAnnotation: i2, kind: null });
        }, t2.tSModuleBlock = t2.tsModuleBlock = function(e3) {
          return (0, r2.default)({ type: "TSModuleBlock", body: e3 });
        }, t2.tSModuleDeclaration = t2.tsModuleDeclaration = function(e3, t3) {
          return (0, r2.default)({ type: "TSModuleDeclaration", id: e3, body: t3 });
        }, t2.tSNamedTupleMember = t2.tsNamedTupleMember = function(e3, t3, n3 = false) {
          return (0, r2.default)({ type: "TSNamedTupleMember", label: e3, elementType: t3, optional: n3 });
        }, t2.tSNamespaceExportDeclaration = t2.tsNamespaceExportDeclaration = function(e3) {
          return (0, r2.default)({ type: "TSNamespaceExportDeclaration", id: e3 });
        }, t2.tSNeverKeyword = t2.tsNeverKeyword = function() {
          return { type: "TSNeverKeyword" };
        }, t2.tSNonNullExpression = t2.tsNonNullExpression = function(e3) {
          return (0, r2.default)({ type: "TSNonNullExpression", expression: e3 });
        }, t2.tSNullKeyword = t2.tsNullKeyword = function() {
          return { type: "TSNullKeyword" };
        }, t2.tSNumberKeyword = t2.tsNumberKeyword = function() {
          return { type: "TSNumberKeyword" };
        }, t2.tSObjectKeyword = t2.tsObjectKeyword = function() {
          return { type: "TSObjectKeyword" };
        }, t2.tSOptionalType = t2.tsOptionalType = function(e3) {
          return (0, r2.default)({ type: "TSOptionalType", typeAnnotation: e3 });
        }, t2.tSParameterProperty = t2.tsParameterProperty = function(e3) {
          return (0, r2.default)({ type: "TSParameterProperty", parameter: e3 });
        }, t2.tSParenthesizedType = t2.tsParenthesizedType = function(e3) {
          return (0, r2.default)({ type: "TSParenthesizedType", typeAnnotation: e3 });
        }, t2.tSPropertySignature = t2.tsPropertySignature = function(e3, t3 = null, n3 = null) {
          return (0, r2.default)({ type: "TSPropertySignature", key: e3, typeAnnotation: t3, initializer: n3, kind: null });
        }, t2.tSQualifiedName = t2.tsQualifiedName = function(e3, t3) {
          return (0, r2.default)({ type: "TSQualifiedName", left: e3, right: t3 });
        }, t2.tSRestType = t2.tsRestType = function(e3) {
          return (0, r2.default)({ type: "TSRestType", typeAnnotation: e3 });
        }, t2.tSSatisfiesExpression = t2.tsSatisfiesExpression = function(e3, t3) {
          return (0, r2.default)({ type: "TSSatisfiesExpression", expression: e3, typeAnnotation: t3 });
        }, t2.tSStringKeyword = t2.tsStringKeyword = function() {
          return { type: "TSStringKeyword" };
        }, t2.tSSymbolKeyword = t2.tsSymbolKeyword = function() {
          return { type: "TSSymbolKeyword" };
        }, t2.tSThisType = t2.tsThisType = function() {
          return { type: "TSThisType" };
        }, t2.tSTupleType = t2.tsTupleType = function(e3) {
          return (0, r2.default)({ type: "TSTupleType", elementTypes: e3 });
        }, t2.tSTypeAliasDeclaration = t2.tsTypeAliasDeclaration = function(e3, t3 = null, n3) {
          return (0, r2.default)({ type: "TSTypeAliasDeclaration", id: e3, typeParameters: t3, typeAnnotation: n3 });
        }, t2.tSTypeAnnotation = t2.tsTypeAnnotation = function(e3) {
          return (0, r2.default)({ type: "TSTypeAnnotation", typeAnnotation: e3 });
        }, t2.tSTypeAssertion = t2.tsTypeAssertion = function(e3, t3) {
          return (0, r2.default)({ type: "TSTypeAssertion", typeAnnotation: e3, expression: t3 });
        }, t2.tSTypeLiteral = t2.tsTypeLiteral = function(e3) {
          return (0, r2.default)({ type: "TSTypeLiteral", members: e3 });
        }, t2.tSTypeOperator = t2.tsTypeOperator = function(e3) {
          return (0, r2.default)({ type: "TSTypeOperator", typeAnnotation: e3, operator: null });
        }, t2.tSTypeParameter = t2.tsTypeParameter = function(e3 = null, t3 = null, n3) {
          return (0, r2.default)({ type: "TSTypeParameter", constraint: e3, default: t3, name: n3 });
        }, t2.tSTypeParameterDeclaration = t2.tsTypeParameterDeclaration = function(e3) {
          return (0, r2.default)({ type: "TSTypeParameterDeclaration", params: e3 });
        }, t2.tSTypeParameterInstantiation = t2.tsTypeParameterInstantiation = function(e3) {
          return (0, r2.default)({ type: "TSTypeParameterInstantiation", params: e3 });
        }, t2.tSTypePredicate = t2.tsTypePredicate = function(e3, t3 = null, n3 = null) {
          return (0, r2.default)({ type: "TSTypePredicate", parameterName: e3, typeAnnotation: t3, asserts: n3 });
        }, t2.tSTypeQuery = t2.tsTypeQuery = function(e3, t3 = null) {
          return (0, r2.default)({ type: "TSTypeQuery", exprName: e3, typeParameters: t3 });
        }, t2.tSTypeReference = t2.tsTypeReference = function(e3, t3 = null) {
          return (0, r2.default)({ type: "TSTypeReference", typeName: e3, typeParameters: t3 });
        }, t2.tSUndefinedKeyword = t2.tsUndefinedKeyword = function() {
          return { type: "TSUndefinedKeyword" };
        }, t2.tSUnionType = t2.tsUnionType = function(e3) {
          return (0, r2.default)({ type: "TSUnionType", types: e3 });
        }, t2.tSUnknownKeyword = t2.tsUnknownKeyword = function() {
          return { type: "TSUnknownKeyword" };
        }, t2.tSVoidKeyword = t2.tsVoidKeyword = function() {
          return { type: "TSVoidKeyword" };
        }, t2.tupleExpression = function(e3 = []) {
          return (0, r2.default)({ type: "TupleExpression", elements: e3 });
        }, t2.tupleTypeAnnotation = function(e3) {
          return (0, r2.default)({ type: "TupleTypeAnnotation", types: e3 });
        }, t2.typeAlias = function(e3, t3 = null, n3) {
          return (0, r2.default)({ type: "TypeAlias", id: e3, typeParameters: t3, right: n3 });
        }, t2.typeAnnotation = function(e3) {
          return (0, r2.default)({ type: "TypeAnnotation", typeAnnotation: e3 });
        }, t2.typeCastExpression = function(e3, t3) {
          return (0, r2.default)({ type: "TypeCastExpression", expression: e3, typeAnnotation: t3 });
        }, t2.typeParameter = function(e3 = null, t3 = null, n3 = null) {
          return (0, r2.default)({ type: "TypeParameter", bound: e3, default: t3, variance: n3, name: null });
        }, t2.typeParameterDeclaration = function(e3) {
          return (0, r2.default)({ type: "TypeParameterDeclaration", params: e3 });
        }, t2.typeParameterInstantiation = function(e3) {
          return (0, r2.default)({ type: "TypeParameterInstantiation", params: e3 });
        }, t2.typeofTypeAnnotation = function(e3) {
          return (0, r2.default)({ type: "TypeofTypeAnnotation", argument: e3 });
        }, t2.unaryExpression = function(e3, t3, n3 = true) {
          return (0, r2.default)({ type: "UnaryExpression", operator: e3, argument: t3, prefix: n3 });
        }, t2.unionTypeAnnotation = function(e3) {
          return (0, r2.default)({ type: "UnionTypeAnnotation", types: e3 });
        }, t2.updateExpression = function(e3, t3, n3 = false) {
          return (0, r2.default)({ type: "UpdateExpression", operator: e3, argument: t3, prefix: n3 });
        }, t2.v8IntrinsicIdentifier = function(e3) {
          return (0, r2.default)({ type: "V8IntrinsicIdentifier", name: e3 });
        }, t2.variableDeclaration = function(e3, t3) {
          return (0, r2.default)({ type: "VariableDeclaration", kind: e3, declarations: t3 });
        }, t2.variableDeclarator = function(e3, t3 = null) {
          return (0, r2.default)({ type: "VariableDeclarator", id: e3, init: t3 });
        }, t2.variance = function(e3) {
          return (0, r2.default)({ type: "Variance", kind: e3 });
        }, t2.voidTypeAnnotation = function() {
          return { type: "VoidTypeAnnotation" };
        }, t2.whileStatement = function(e3, t3) {
          return (0, r2.default)({ type: "WhileStatement", test: e3, body: t3 });
        }, t2.withStatement = function(e3, t3) {
          return (0, r2.default)({ type: "WithStatement", object: e3, body: t3 });
        }, t2.yieldExpression = function(e3 = null, t3 = false) {
          return (0, r2.default)({ type: "YieldExpression", argument: e3, delegate: t3 });
        };
        var r2 = n2(6505), i = n2(4619);
        function s(e3) {
          return (0, r2.default)({ type: "NumericLiteral", value: e3 });
        }
        function a(e3, t3 = "") {
          return (0, r2.default)({ type: "RegExpLiteral", pattern: e3, flags: t3 });
        }
        function o(e3) {
          return (0, r2.default)({ type: "RestElement", argument: e3 });
        }
        function l(e3) {
          return (0, r2.default)({ type: "SpreadElement", argument: e3 });
        }
      }, 9470: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), Object.defineProperty(t2, "AnyTypeAnnotation", { enumerable: true, get: function() {
          return r2.anyTypeAnnotation;
        } }), Object.defineProperty(t2, "ArgumentPlaceholder", { enumerable: true, get: function() {
          return r2.argumentPlaceholder;
        } }), Object.defineProperty(t2, "ArrayExpression", { enumerable: true, get: function() {
          return r2.arrayExpression;
        } }), Object.defineProperty(t2, "ArrayPattern", { enumerable: true, get: function() {
          return r2.arrayPattern;
        } }), Object.defineProperty(t2, "ArrayTypeAnnotation", { enumerable: true, get: function() {
          return r2.arrayTypeAnnotation;
        } }), Object.defineProperty(t2, "ArrowFunctionExpression", { enumerable: true, get: function() {
          return r2.arrowFunctionExpression;
        } }), Object.defineProperty(t2, "AssignmentExpression", { enumerable: true, get: function() {
          return r2.assignmentExpression;
        } }), Object.defineProperty(t2, "AssignmentPattern", { enumerable: true, get: function() {
          return r2.assignmentPattern;
        } }), Object.defineProperty(t2, "AwaitExpression", { enumerable: true, get: function() {
          return r2.awaitExpression;
        } }), Object.defineProperty(t2, "BigIntLiteral", { enumerable: true, get: function() {
          return r2.bigIntLiteral;
        } }), Object.defineProperty(t2, "BinaryExpression", { enumerable: true, get: function() {
          return r2.binaryExpression;
        } }), Object.defineProperty(t2, "BindExpression", { enumerable: true, get: function() {
          return r2.bindExpression;
        } }), Object.defineProperty(t2, "BlockStatement", { enumerable: true, get: function() {
          return r2.blockStatement;
        } }), Object.defineProperty(t2, "BooleanLiteral", { enumerable: true, get: function() {
          return r2.booleanLiteral;
        } }), Object.defineProperty(t2, "BooleanLiteralTypeAnnotation", { enumerable: true, get: function() {
          return r2.booleanLiteralTypeAnnotation;
        } }), Object.defineProperty(t2, "BooleanTypeAnnotation", { enumerable: true, get: function() {
          return r2.booleanTypeAnnotation;
        } }), Object.defineProperty(t2, "BreakStatement", { enumerable: true, get: function() {
          return r2.breakStatement;
        } }), Object.defineProperty(t2, "CallExpression", { enumerable: true, get: function() {
          return r2.callExpression;
        } }), Object.defineProperty(t2, "CatchClause", { enumerable: true, get: function() {
          return r2.catchClause;
        } }), Object.defineProperty(t2, "ClassAccessorProperty", { enumerable: true, get: function() {
          return r2.classAccessorProperty;
        } }), Object.defineProperty(t2, "ClassBody", { enumerable: true, get: function() {
          return r2.classBody;
        } }), Object.defineProperty(t2, "ClassDeclaration", { enumerable: true, get: function() {
          return r2.classDeclaration;
        } }), Object.defineProperty(t2, "ClassExpression", { enumerable: true, get: function() {
          return r2.classExpression;
        } }), Object.defineProperty(t2, "ClassImplements", { enumerable: true, get: function() {
          return r2.classImplements;
        } }), Object.defineProperty(t2, "ClassMethod", { enumerable: true, get: function() {
          return r2.classMethod;
        } }), Object.defineProperty(t2, "ClassPrivateMethod", { enumerable: true, get: function() {
          return r2.classPrivateMethod;
        } }), Object.defineProperty(t2, "ClassPrivateProperty", { enumerable: true, get: function() {
          return r2.classPrivateProperty;
        } }), Object.defineProperty(t2, "ClassProperty", { enumerable: true, get: function() {
          return r2.classProperty;
        } }), Object.defineProperty(t2, "ConditionalExpression", { enumerable: true, get: function() {
          return r2.conditionalExpression;
        } }), Object.defineProperty(t2, "ContinueStatement", { enumerable: true, get: function() {
          return r2.continueStatement;
        } }), Object.defineProperty(t2, "DebuggerStatement", { enumerable: true, get: function() {
          return r2.debuggerStatement;
        } }), Object.defineProperty(t2, "DecimalLiteral", { enumerable: true, get: function() {
          return r2.decimalLiteral;
        } }), Object.defineProperty(t2, "DeclareClass", { enumerable: true, get: function() {
          return r2.declareClass;
        } }), Object.defineProperty(t2, "DeclareExportAllDeclaration", { enumerable: true, get: function() {
          return r2.declareExportAllDeclaration;
        } }), Object.defineProperty(t2, "DeclareExportDeclaration", { enumerable: true, get: function() {
          return r2.declareExportDeclaration;
        } }), Object.defineProperty(t2, "DeclareFunction", { enumerable: true, get: function() {
          return r2.declareFunction;
        } }), Object.defineProperty(t2, "DeclareInterface", { enumerable: true, get: function() {
          return r2.declareInterface;
        } }), Object.defineProperty(t2, "DeclareModule", { enumerable: true, get: function() {
          return r2.declareModule;
        } }), Object.defineProperty(t2, "DeclareModuleExports", { enumerable: true, get: function() {
          return r2.declareModuleExports;
        } }), Object.defineProperty(t2, "DeclareOpaqueType", { enumerable: true, get: function() {
          return r2.declareOpaqueType;
        } }), Object.defineProperty(t2, "DeclareTypeAlias", { enumerable: true, get: function() {
          return r2.declareTypeAlias;
        } }), Object.defineProperty(t2, "DeclareVariable", { enumerable: true, get: function() {
          return r2.declareVariable;
        } }), Object.defineProperty(t2, "DeclaredPredicate", { enumerable: true, get: function() {
          return r2.declaredPredicate;
        } }), Object.defineProperty(t2, "Decorator", { enumerable: true, get: function() {
          return r2.decorator;
        } }), Object.defineProperty(t2, "Directive", { enumerable: true, get: function() {
          return r2.directive;
        } }), Object.defineProperty(t2, "DirectiveLiteral", { enumerable: true, get: function() {
          return r2.directiveLiteral;
        } }), Object.defineProperty(t2, "DoExpression", { enumerable: true, get: function() {
          return r2.doExpression;
        } }), Object.defineProperty(t2, "DoWhileStatement", { enumerable: true, get: function() {
          return r2.doWhileStatement;
        } }), Object.defineProperty(t2, "EmptyStatement", { enumerable: true, get: function() {
          return r2.emptyStatement;
        } }), Object.defineProperty(t2, "EmptyTypeAnnotation", { enumerable: true, get: function() {
          return r2.emptyTypeAnnotation;
        } }), Object.defineProperty(t2, "EnumBooleanBody", { enumerable: true, get: function() {
          return r2.enumBooleanBody;
        } }), Object.defineProperty(t2, "EnumBooleanMember", { enumerable: true, get: function() {
          return r2.enumBooleanMember;
        } }), Object.defineProperty(t2, "EnumDeclaration", { enumerable: true, get: function() {
          return r2.enumDeclaration;
        } }), Object.defineProperty(t2, "EnumDefaultedMember", { enumerable: true, get: function() {
          return r2.enumDefaultedMember;
        } }), Object.defineProperty(t2, "EnumNumberBody", { enumerable: true, get: function() {
          return r2.enumNumberBody;
        } }), Object.defineProperty(t2, "EnumNumberMember", { enumerable: true, get: function() {
          return r2.enumNumberMember;
        } }), Object.defineProperty(t2, "EnumStringBody", { enumerable: true, get: function() {
          return r2.enumStringBody;
        } }), Object.defineProperty(t2, "EnumStringMember", { enumerable: true, get: function() {
          return r2.enumStringMember;
        } }), Object.defineProperty(t2, "EnumSymbolBody", { enumerable: true, get: function() {
          return r2.enumSymbolBody;
        } }), Object.defineProperty(t2, "ExistsTypeAnnotation", { enumerable: true, get: function() {
          return r2.existsTypeAnnotation;
        } }), Object.defineProperty(t2, "ExportAllDeclaration", { enumerable: true, get: function() {
          return r2.exportAllDeclaration;
        } }), Object.defineProperty(t2, "ExportDefaultDeclaration", { enumerable: true, get: function() {
          return r2.exportDefaultDeclaration;
        } }), Object.defineProperty(t2, "ExportDefaultSpecifier", { enumerable: true, get: function() {
          return r2.exportDefaultSpecifier;
        } }), Object.defineProperty(t2, "ExportNamedDeclaration", { enumerable: true, get: function() {
          return r2.exportNamedDeclaration;
        } }), Object.defineProperty(t2, "ExportNamespaceSpecifier", { enumerable: true, get: function() {
          return r2.exportNamespaceSpecifier;
        } }), Object.defineProperty(t2, "ExportSpecifier", { enumerable: true, get: function() {
          return r2.exportSpecifier;
        } }), Object.defineProperty(t2, "ExpressionStatement", { enumerable: true, get: function() {
          return r2.expressionStatement;
        } }), Object.defineProperty(t2, "File", { enumerable: true, get: function() {
          return r2.file;
        } }), Object.defineProperty(t2, "ForInStatement", { enumerable: true, get: function() {
          return r2.forInStatement;
        } }), Object.defineProperty(t2, "ForOfStatement", { enumerable: true, get: function() {
          return r2.forOfStatement;
        } }), Object.defineProperty(t2, "ForStatement", { enumerable: true, get: function() {
          return r2.forStatement;
        } }), Object.defineProperty(t2, "FunctionDeclaration", { enumerable: true, get: function() {
          return r2.functionDeclaration;
        } }), Object.defineProperty(t2, "FunctionExpression", { enumerable: true, get: function() {
          return r2.functionExpression;
        } }), Object.defineProperty(t2, "FunctionTypeAnnotation", { enumerable: true, get: function() {
          return r2.functionTypeAnnotation;
        } }), Object.defineProperty(t2, "FunctionTypeParam", { enumerable: true, get: function() {
          return r2.functionTypeParam;
        } }), Object.defineProperty(t2, "GenericTypeAnnotation", { enumerable: true, get: function() {
          return r2.genericTypeAnnotation;
        } }), Object.defineProperty(t2, "Identifier", { enumerable: true, get: function() {
          return r2.identifier;
        } }), Object.defineProperty(t2, "IfStatement", { enumerable: true, get: function() {
          return r2.ifStatement;
        } }), Object.defineProperty(t2, "Import", { enumerable: true, get: function() {
          return r2.import;
        } }), Object.defineProperty(t2, "ImportAttribute", { enumerable: true, get: function() {
          return r2.importAttribute;
        } }), Object.defineProperty(t2, "ImportDeclaration", { enumerable: true, get: function() {
          return r2.importDeclaration;
        } }), Object.defineProperty(t2, "ImportDefaultSpecifier", { enumerable: true, get: function() {
          return r2.importDefaultSpecifier;
        } }), Object.defineProperty(t2, "ImportNamespaceSpecifier", { enumerable: true, get: function() {
          return r2.importNamespaceSpecifier;
        } }), Object.defineProperty(t2, "ImportSpecifier", { enumerable: true, get: function() {
          return r2.importSpecifier;
        } }), Object.defineProperty(t2, "IndexedAccessType", { enumerable: true, get: function() {
          return r2.indexedAccessType;
        } }), Object.defineProperty(t2, "InferredPredicate", { enumerable: true, get: function() {
          return r2.inferredPredicate;
        } }), Object.defineProperty(t2, "InterfaceDeclaration", { enumerable: true, get: function() {
          return r2.interfaceDeclaration;
        } }), Object.defineProperty(t2, "InterfaceExtends", { enumerable: true, get: function() {
          return r2.interfaceExtends;
        } }), Object.defineProperty(t2, "InterfaceTypeAnnotation", { enumerable: true, get: function() {
          return r2.interfaceTypeAnnotation;
        } }), Object.defineProperty(t2, "InterpreterDirective", { enumerable: true, get: function() {
          return r2.interpreterDirective;
        } }), Object.defineProperty(t2, "IntersectionTypeAnnotation", { enumerable: true, get: function() {
          return r2.intersectionTypeAnnotation;
        } }), Object.defineProperty(t2, "JSXAttribute", { enumerable: true, get: function() {
          return r2.jsxAttribute;
        } }), Object.defineProperty(t2, "JSXClosingElement", { enumerable: true, get: function() {
          return r2.jsxClosingElement;
        } }), Object.defineProperty(t2, "JSXClosingFragment", { enumerable: true, get: function() {
          return r2.jsxClosingFragment;
        } }), Object.defineProperty(t2, "JSXElement", { enumerable: true, get: function() {
          return r2.jsxElement;
        } }), Object.defineProperty(t2, "JSXEmptyExpression", { enumerable: true, get: function() {
          return r2.jsxEmptyExpression;
        } }), Object.defineProperty(t2, "JSXExpressionContainer", { enumerable: true, get: function() {
          return r2.jsxExpressionContainer;
        } }), Object.defineProperty(t2, "JSXFragment", { enumerable: true, get: function() {
          return r2.jsxFragment;
        } }), Object.defineProperty(t2, "JSXIdentifier", { enumerable: true, get: function() {
          return r2.jsxIdentifier;
        } }), Object.defineProperty(t2, "JSXMemberExpression", { enumerable: true, get: function() {
          return r2.jsxMemberExpression;
        } }), Object.defineProperty(t2, "JSXNamespacedName", { enumerable: true, get: function() {
          return r2.jsxNamespacedName;
        } }), Object.defineProperty(t2, "JSXOpeningElement", { enumerable: true, get: function() {
          return r2.jsxOpeningElement;
        } }), Object.defineProperty(t2, "JSXOpeningFragment", { enumerable: true, get: function() {
          return r2.jsxOpeningFragment;
        } }), Object.defineProperty(t2, "JSXSpreadAttribute", { enumerable: true, get: function() {
          return r2.jsxSpreadAttribute;
        } }), Object.defineProperty(t2, "JSXSpreadChild", { enumerable: true, get: function() {
          return r2.jsxSpreadChild;
        } }), Object.defineProperty(t2, "JSXText", { enumerable: true, get: function() {
          return r2.jsxText;
        } }), Object.defineProperty(t2, "LabeledStatement", { enumerable: true, get: function() {
          return r2.labeledStatement;
        } }), Object.defineProperty(t2, "LogicalExpression", { enumerable: true, get: function() {
          return r2.logicalExpression;
        } }), Object.defineProperty(t2, "MemberExpression", { enumerable: true, get: function() {
          return r2.memberExpression;
        } }), Object.defineProperty(t2, "MetaProperty", { enumerable: true, get: function() {
          return r2.metaProperty;
        } }), Object.defineProperty(t2, "MixedTypeAnnotation", { enumerable: true, get: function() {
          return r2.mixedTypeAnnotation;
        } }), Object.defineProperty(t2, "ModuleExpression", { enumerable: true, get: function() {
          return r2.moduleExpression;
        } }), Object.defineProperty(t2, "NewExpression", { enumerable: true, get: function() {
          return r2.newExpression;
        } }), Object.defineProperty(t2, "Noop", { enumerable: true, get: function() {
          return r2.noop;
        } }), Object.defineProperty(t2, "NullLiteral", { enumerable: true, get: function() {
          return r2.nullLiteral;
        } }), Object.defineProperty(t2, "NullLiteralTypeAnnotation", { enumerable: true, get: function() {
          return r2.nullLiteralTypeAnnotation;
        } }), Object.defineProperty(t2, "NullableTypeAnnotation", { enumerable: true, get: function() {
          return r2.nullableTypeAnnotation;
        } }), Object.defineProperty(t2, "NumberLiteral", { enumerable: true, get: function() {
          return r2.numberLiteral;
        } }), Object.defineProperty(t2, "NumberLiteralTypeAnnotation", { enumerable: true, get: function() {
          return r2.numberLiteralTypeAnnotation;
        } }), Object.defineProperty(t2, "NumberTypeAnnotation", { enumerable: true, get: function() {
          return r2.numberTypeAnnotation;
        } }), Object.defineProperty(t2, "NumericLiteral", { enumerable: true, get: function() {
          return r2.numericLiteral;
        } }), Object.defineProperty(t2, "ObjectExpression", { enumerable: true, get: function() {
          return r2.objectExpression;
        } }), Object.defineProperty(t2, "ObjectMethod", { enumerable: true, get: function() {
          return r2.objectMethod;
        } }), Object.defineProperty(t2, "ObjectPattern", { enumerable: true, get: function() {
          return r2.objectPattern;
        } }), Object.defineProperty(t2, "ObjectProperty", { enumerable: true, get: function() {
          return r2.objectProperty;
        } }), Object.defineProperty(t2, "ObjectTypeAnnotation", { enumerable: true, get: function() {
          return r2.objectTypeAnnotation;
        } }), Object.defineProperty(t2, "ObjectTypeCallProperty", { enumerable: true, get: function() {
          return r2.objectTypeCallProperty;
        } }), Object.defineProperty(t2, "ObjectTypeIndexer", { enumerable: true, get: function() {
          return r2.objectTypeIndexer;
        } }), Object.defineProperty(t2, "ObjectTypeInternalSlot", { enumerable: true, get: function() {
          return r2.objectTypeInternalSlot;
        } }), Object.defineProperty(t2, "ObjectTypeProperty", { enumerable: true, get: function() {
          return r2.objectTypeProperty;
        } }), Object.defineProperty(t2, "ObjectTypeSpreadProperty", { enumerable: true, get: function() {
          return r2.objectTypeSpreadProperty;
        } }), Object.defineProperty(t2, "OpaqueType", { enumerable: true, get: function() {
          return r2.opaqueType;
        } }), Object.defineProperty(t2, "OptionalCallExpression", { enumerable: true, get: function() {
          return r2.optionalCallExpression;
        } }), Object.defineProperty(t2, "OptionalIndexedAccessType", { enumerable: true, get: function() {
          return r2.optionalIndexedAccessType;
        } }), Object.defineProperty(t2, "OptionalMemberExpression", { enumerable: true, get: function() {
          return r2.optionalMemberExpression;
        } }), Object.defineProperty(t2, "ParenthesizedExpression", { enumerable: true, get: function() {
          return r2.parenthesizedExpression;
        } }), Object.defineProperty(t2, "PipelineBareFunction", { enumerable: true, get: function() {
          return r2.pipelineBareFunction;
        } }), Object.defineProperty(t2, "PipelinePrimaryTopicReference", { enumerable: true, get: function() {
          return r2.pipelinePrimaryTopicReference;
        } }), Object.defineProperty(t2, "PipelineTopicExpression", { enumerable: true, get: function() {
          return r2.pipelineTopicExpression;
        } }), Object.defineProperty(t2, "Placeholder", { enumerable: true, get: function() {
          return r2.placeholder;
        } }), Object.defineProperty(t2, "PrivateName", { enumerable: true, get: function() {
          return r2.privateName;
        } }), Object.defineProperty(t2, "Program", { enumerable: true, get: function() {
          return r2.program;
        } }), Object.defineProperty(t2, "QualifiedTypeIdentifier", { enumerable: true, get: function() {
          return r2.qualifiedTypeIdentifier;
        } }), Object.defineProperty(t2, "RecordExpression", { enumerable: true, get: function() {
          return r2.recordExpression;
        } }), Object.defineProperty(t2, "RegExpLiteral", { enumerable: true, get: function() {
          return r2.regExpLiteral;
        } }), Object.defineProperty(t2, "RegexLiteral", { enumerable: true, get: function() {
          return r2.regexLiteral;
        } }), Object.defineProperty(t2, "RestElement", { enumerable: true, get: function() {
          return r2.restElement;
        } }), Object.defineProperty(t2, "RestProperty", { enumerable: true, get: function() {
          return r2.restProperty;
        } }), Object.defineProperty(t2, "ReturnStatement", { enumerable: true, get: function() {
          return r2.returnStatement;
        } }), Object.defineProperty(t2, "SequenceExpression", { enumerable: true, get: function() {
          return r2.sequenceExpression;
        } }), Object.defineProperty(t2, "SpreadElement", { enumerable: true, get: function() {
          return r2.spreadElement;
        } }), Object.defineProperty(t2, "SpreadProperty", { enumerable: true, get: function() {
          return r2.spreadProperty;
        } }), Object.defineProperty(t2, "StaticBlock", { enumerable: true, get: function() {
          return r2.staticBlock;
        } }), Object.defineProperty(t2, "StringLiteral", { enumerable: true, get: function() {
          return r2.stringLiteral;
        } }), Object.defineProperty(t2, "StringLiteralTypeAnnotation", { enumerable: true, get: function() {
          return r2.stringLiteralTypeAnnotation;
        } }), Object.defineProperty(t2, "StringTypeAnnotation", { enumerable: true, get: function() {
          return r2.stringTypeAnnotation;
        } }), Object.defineProperty(t2, "Super", { enumerable: true, get: function() {
          return r2.super;
        } }), Object.defineProperty(t2, "SwitchCase", { enumerable: true, get: function() {
          return r2.switchCase;
        } }), Object.defineProperty(t2, "SwitchStatement", { enumerable: true, get: function() {
          return r2.switchStatement;
        } }), Object.defineProperty(t2, "SymbolTypeAnnotation", { enumerable: true, get: function() {
          return r2.symbolTypeAnnotation;
        } }), Object.defineProperty(t2, "TSAnyKeyword", { enumerable: true, get: function() {
          return r2.tsAnyKeyword;
        } }), Object.defineProperty(t2, "TSArrayType", { enumerable: true, get: function() {
          return r2.tsArrayType;
        } }), Object.defineProperty(t2, "TSAsExpression", { enumerable: true, get: function() {
          return r2.tsAsExpression;
        } }), Object.defineProperty(t2, "TSBigIntKeyword", { enumerable: true, get: function() {
          return r2.tsBigIntKeyword;
        } }), Object.defineProperty(t2, "TSBooleanKeyword", { enumerable: true, get: function() {
          return r2.tsBooleanKeyword;
        } }), Object.defineProperty(t2, "TSCallSignatureDeclaration", { enumerable: true, get: function() {
          return r2.tsCallSignatureDeclaration;
        } }), Object.defineProperty(t2, "TSConditionalType", { enumerable: true, get: function() {
          return r2.tsConditionalType;
        } }), Object.defineProperty(t2, "TSConstructSignatureDeclaration", { enumerable: true, get: function() {
          return r2.tsConstructSignatureDeclaration;
        } }), Object.defineProperty(t2, "TSConstructorType", { enumerable: true, get: function() {
          return r2.tsConstructorType;
        } }), Object.defineProperty(t2, "TSDeclareFunction", { enumerable: true, get: function() {
          return r2.tsDeclareFunction;
        } }), Object.defineProperty(t2, "TSDeclareMethod", { enumerable: true, get: function() {
          return r2.tsDeclareMethod;
        } }), Object.defineProperty(t2, "TSEnumDeclaration", { enumerable: true, get: function() {
          return r2.tsEnumDeclaration;
        } }), Object.defineProperty(t2, "TSEnumMember", { enumerable: true, get: function() {
          return r2.tsEnumMember;
        } }), Object.defineProperty(t2, "TSExportAssignment", { enumerable: true, get: function() {
          return r2.tsExportAssignment;
        } }), Object.defineProperty(t2, "TSExpressionWithTypeArguments", { enumerable: true, get: function() {
          return r2.tsExpressionWithTypeArguments;
        } }), Object.defineProperty(t2, "TSExternalModuleReference", { enumerable: true, get: function() {
          return r2.tsExternalModuleReference;
        } }), Object.defineProperty(t2, "TSFunctionType", { enumerable: true, get: function() {
          return r2.tsFunctionType;
        } }), Object.defineProperty(t2, "TSImportEqualsDeclaration", { enumerable: true, get: function() {
          return r2.tsImportEqualsDeclaration;
        } }), Object.defineProperty(t2, "TSImportType", { enumerable: true, get: function() {
          return r2.tsImportType;
        } }), Object.defineProperty(t2, "TSIndexSignature", { enumerable: true, get: function() {
          return r2.tsIndexSignature;
        } }), Object.defineProperty(t2, "TSIndexedAccessType", { enumerable: true, get: function() {
          return r2.tsIndexedAccessType;
        } }), Object.defineProperty(t2, "TSInferType", { enumerable: true, get: function() {
          return r2.tsInferType;
        } }), Object.defineProperty(t2, "TSInstantiationExpression", { enumerable: true, get: function() {
          return r2.tsInstantiationExpression;
        } }), Object.defineProperty(t2, "TSInterfaceBody", { enumerable: true, get: function() {
          return r2.tsInterfaceBody;
        } }), Object.defineProperty(t2, "TSInterfaceDeclaration", { enumerable: true, get: function() {
          return r2.tsInterfaceDeclaration;
        } }), Object.defineProperty(t2, "TSIntersectionType", { enumerable: true, get: function() {
          return r2.tsIntersectionType;
        } }), Object.defineProperty(t2, "TSIntrinsicKeyword", { enumerable: true, get: function() {
          return r2.tsIntrinsicKeyword;
        } }), Object.defineProperty(t2, "TSLiteralType", { enumerable: true, get: function() {
          return r2.tsLiteralType;
        } }), Object.defineProperty(t2, "TSMappedType", { enumerable: true, get: function() {
          return r2.tsMappedType;
        } }), Object.defineProperty(t2, "TSMethodSignature", { enumerable: true, get: function() {
          return r2.tsMethodSignature;
        } }), Object.defineProperty(t2, "TSModuleBlock", { enumerable: true, get: function() {
          return r2.tsModuleBlock;
        } }), Object.defineProperty(t2, "TSModuleDeclaration", { enumerable: true, get: function() {
          return r2.tsModuleDeclaration;
        } }), Object.defineProperty(t2, "TSNamedTupleMember", { enumerable: true, get: function() {
          return r2.tsNamedTupleMember;
        } }), Object.defineProperty(t2, "TSNamespaceExportDeclaration", { enumerable: true, get: function() {
          return r2.tsNamespaceExportDeclaration;
        } }), Object.defineProperty(t2, "TSNeverKeyword", { enumerable: true, get: function() {
          return r2.tsNeverKeyword;
        } }), Object.defineProperty(t2, "TSNonNullExpression", { enumerable: true, get: function() {
          return r2.tsNonNullExpression;
        } }), Object.defineProperty(t2, "TSNullKeyword", { enumerable: true, get: function() {
          return r2.tsNullKeyword;
        } }), Object.defineProperty(t2, "TSNumberKeyword", { enumerable: true, get: function() {
          return r2.tsNumberKeyword;
        } }), Object.defineProperty(t2, "TSObjectKeyword", { enumerable: true, get: function() {
          return r2.tsObjectKeyword;
        } }), Object.defineProperty(t2, "TSOptionalType", { enumerable: true, get: function() {
          return r2.tsOptionalType;
        } }), Object.defineProperty(t2, "TSParameterProperty", { enumerable: true, get: function() {
          return r2.tsParameterProperty;
        } }), Object.defineProperty(t2, "TSParenthesizedType", { enumerable: true, get: function() {
          return r2.tsParenthesizedType;
        } }), Object.defineProperty(t2, "TSPropertySignature", { enumerable: true, get: function() {
          return r2.tsPropertySignature;
        } }), Object.defineProperty(t2, "TSQualifiedName", { enumerable: true, get: function() {
          return r2.tsQualifiedName;
        } }), Object.defineProperty(t2, "TSRestType", { enumerable: true, get: function() {
          return r2.tsRestType;
        } }), Object.defineProperty(t2, "TSSatisfiesExpression", { enumerable: true, get: function() {
          return r2.tsSatisfiesExpression;
        } }), Object.defineProperty(t2, "TSStringKeyword", { enumerable: true, get: function() {
          return r2.tsStringKeyword;
        } }), Object.defineProperty(t2, "TSSymbolKeyword", { enumerable: true, get: function() {
          return r2.tsSymbolKeyword;
        } }), Object.defineProperty(t2, "TSThisType", { enumerable: true, get: function() {
          return r2.tsThisType;
        } }), Object.defineProperty(t2, "TSTupleType", { enumerable: true, get: function() {
          return r2.tsTupleType;
        } }), Object.defineProperty(t2, "TSTypeAliasDeclaration", { enumerable: true, get: function() {
          return r2.tsTypeAliasDeclaration;
        } }), Object.defineProperty(t2, "TSTypeAnnotation", { enumerable: true, get: function() {
          return r2.tsTypeAnnotation;
        } }), Object.defineProperty(t2, "TSTypeAssertion", { enumerable: true, get: function() {
          return r2.tsTypeAssertion;
        } }), Object.defineProperty(t2, "TSTypeLiteral", { enumerable: true, get: function() {
          return r2.tsTypeLiteral;
        } }), Object.defineProperty(t2, "TSTypeOperator", { enumerable: true, get: function() {
          return r2.tsTypeOperator;
        } }), Object.defineProperty(t2, "TSTypeParameter", { enumerable: true, get: function() {
          return r2.tsTypeParameter;
        } }), Object.defineProperty(t2, "TSTypeParameterDeclaration", { enumerable: true, get: function() {
          return r2.tsTypeParameterDeclaration;
        } }), Object.defineProperty(t2, "TSTypeParameterInstantiation", { enumerable: true, get: function() {
          return r2.tsTypeParameterInstantiation;
        } }), Object.defineProperty(t2, "TSTypePredicate", { enumerable: true, get: function() {
          return r2.tsTypePredicate;
        } }), Object.defineProperty(t2, "TSTypeQuery", { enumerable: true, get: function() {
          return r2.tsTypeQuery;
        } }), Object.defineProperty(t2, "TSTypeReference", { enumerable: true, get: function() {
          return r2.tsTypeReference;
        } }), Object.defineProperty(t2, "TSUndefinedKeyword", { enumerable: true, get: function() {
          return r2.tsUndefinedKeyword;
        } }), Object.defineProperty(t2, "TSUnionType", { enumerable: true, get: function() {
          return r2.tsUnionType;
        } }), Object.defineProperty(t2, "TSUnknownKeyword", { enumerable: true, get: function() {
          return r2.tsUnknownKeyword;
        } }), Object.defineProperty(t2, "TSVoidKeyword", { enumerable: true, get: function() {
          return r2.tsVoidKeyword;
        } }), Object.defineProperty(t2, "TaggedTemplateExpression", { enumerable: true, get: function() {
          return r2.taggedTemplateExpression;
        } }), Object.defineProperty(t2, "TemplateElement", { enumerable: true, get: function() {
          return r2.templateElement;
        } }), Object.defineProperty(t2, "TemplateLiteral", { enumerable: true, get: function() {
          return r2.templateLiteral;
        } }), Object.defineProperty(t2, "ThisExpression", { enumerable: true, get: function() {
          return r2.thisExpression;
        } }), Object.defineProperty(t2, "ThisTypeAnnotation", { enumerable: true, get: function() {
          return r2.thisTypeAnnotation;
        } }), Object.defineProperty(t2, "ThrowStatement", { enumerable: true, get: function() {
          return r2.throwStatement;
        } }), Object.defineProperty(t2, "TopicReference", { enumerable: true, get: function() {
          return r2.topicReference;
        } }), Object.defineProperty(t2, "TryStatement", { enumerable: true, get: function() {
          return r2.tryStatement;
        } }), Object.defineProperty(t2, "TupleExpression", { enumerable: true, get: function() {
          return r2.tupleExpression;
        } }), Object.defineProperty(t2, "TupleTypeAnnotation", { enumerable: true, get: function() {
          return r2.tupleTypeAnnotation;
        } }), Object.defineProperty(t2, "TypeAlias", { enumerable: true, get: function() {
          return r2.typeAlias;
        } }), Object.defineProperty(t2, "TypeAnnotation", { enumerable: true, get: function() {
          return r2.typeAnnotation;
        } }), Object.defineProperty(t2, "TypeCastExpression", { enumerable: true, get: function() {
          return r2.typeCastExpression;
        } }), Object.defineProperty(t2, "TypeParameter", { enumerable: true, get: function() {
          return r2.typeParameter;
        } }), Object.defineProperty(t2, "TypeParameterDeclaration", { enumerable: true, get: function() {
          return r2.typeParameterDeclaration;
        } }), Object.defineProperty(t2, "TypeParameterInstantiation", { enumerable: true, get: function() {
          return r2.typeParameterInstantiation;
        } }), Object.defineProperty(t2, "TypeofTypeAnnotation", { enumerable: true, get: function() {
          return r2.typeofTypeAnnotation;
        } }), Object.defineProperty(t2, "UnaryExpression", { enumerable: true, get: function() {
          return r2.unaryExpression;
        } }), Object.defineProperty(t2, "UnionTypeAnnotation", { enumerable: true, get: function() {
          return r2.unionTypeAnnotation;
        } }), Object.defineProperty(t2, "UpdateExpression", { enumerable: true, get: function() {
          return r2.updateExpression;
        } }), Object.defineProperty(t2, "V8IntrinsicIdentifier", { enumerable: true, get: function() {
          return r2.v8IntrinsicIdentifier;
        } }), Object.defineProperty(t2, "VariableDeclaration", { enumerable: true, get: function() {
          return r2.variableDeclaration;
        } }), Object.defineProperty(t2, "VariableDeclarator", { enumerable: true, get: function() {
          return r2.variableDeclarator;
        } }), Object.defineProperty(t2, "Variance", { enumerable: true, get: function() {
          return r2.variance;
        } }), Object.defineProperty(t2, "VoidTypeAnnotation", { enumerable: true, get: function() {
          return r2.voidTypeAnnotation;
        } }), Object.defineProperty(t2, "WhileStatement", { enumerable: true, get: function() {
          return r2.whileStatement;
        } }), Object.defineProperty(t2, "WithStatement", { enumerable: true, get: function() {
          return r2.withStatement;
        } }), Object.defineProperty(t2, "YieldExpression", { enumerable: true, get: function() {
          return r2.yieldExpression;
        } });
        var r2 = n2(1411);
      }, 4225: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
          const t3 = [];
          for (let n3 = 0; n3 < e3.children.length; n3++) {
            let s = e3.children[n3];
            (0, r2.isJSXText)(s) ? (0, i.default)(s, t3) : ((0, r2.isJSXExpressionContainer)(s) && (s = s.expression), (0, r2.isJSXEmptyExpression)(s) || t3.push(s));
          }
          return t3;
        };
        var r2 = n2(9869), i = n2(8730);
      }, 6752: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
          const t3 = e3.map((e4) => (0, s.isTSTypeAnnotation)(e4) ? e4.typeAnnotation : e4), n3 = (0, i.default)(t3);
          return 1 === n3.length ? n3[0] : (0, r2.tsUnionType)(n3);
        };
        var r2 = n2(1411), i = n2(2819), s = n2(9869);
      }, 6505: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
          const t3 = i.BUILDER_KEYS[e3.type];
          for (const n3 of t3) (0, r2.default)(e3, n3, e3[n3]);
          return e3;
        };
        var r2 = n2(7750), i = n2(6067);
      }, 8229: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
          return (0, r2.default)(e3, false);
        };
        var r2 = n2(2419);
      }, 8030: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
          return (0, r2.default)(e3);
        };
        var r2 = n2(2419);
      }, 8519: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
          return (0, r2.default)(e3, true, true);
        };
        var r2 = n2(2419);
      }, 2419: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3 = true, n3 = false) {
          return l(e3, t3, n3, /* @__PURE__ */ new Map());
        };
        var r2 = n2(1678), i = n2(9869);
        const s = Function.call.bind(Object.prototype.hasOwnProperty);
        function a(e3, t3, n3, r3) {
          return e3 && "string" == typeof e3.type ? l(e3, t3, n3, r3) : e3;
        }
        function o(e3, t3, n3, r3) {
          return Array.isArray(e3) ? e3.map((e4) => a(e4, t3, n3, r3)) : a(e3, t3, n3, r3);
        }
        function l(e3, t3 = true, n3 = false, a2) {
          if (!e3) return e3;
          const { type: l2 } = e3, u = { type: e3.type };
          if ((0, i.isIdentifier)(e3)) u.name = e3.name, s(e3, "optional") && "boolean" == typeof e3.optional && (u.optional = e3.optional), s(e3, "typeAnnotation") && (u.typeAnnotation = t3 ? o(e3.typeAnnotation, true, n3, a2) : e3.typeAnnotation);
          else {
            if (!s(r2.NODE_FIELDS, l2)) throw new Error(`Unknown node type: "${l2}"`);
            for (const p of Object.keys(r2.NODE_FIELDS[l2])) s(e3, p) && (u[p] = t3 ? (0, i.isFile)(e3) && "comments" === p ? c(e3.comments, t3, n3, a2) : o(e3[p], true, n3, a2) : e3[p]);
          }
          return s(e3, "loc") && (u.loc = n3 ? null : e3.loc), s(e3, "leadingComments") && (u.leadingComments = c(e3.leadingComments, t3, n3, a2)), s(e3, "innerComments") && (u.innerComments = c(e3.innerComments, t3, n3, a2)), s(e3, "trailingComments") && (u.trailingComments = c(e3.trailingComments, t3, n3, a2)), s(e3, "extra") && (u.extra = Object.assign({}, e3.extra)), u;
        }
        function c(e3, t3, n3, r3) {
          return e3 && t3 ? e3.map((e4) => {
            const t4 = r3.get(e4);
            if (t4) return t4;
            const { type: i2, value: s2, loc: a2 } = e4, o2 = { type: i2, value: s2, loc: a2 };
            return n3 && (o2.loc = null), r3.set(e4, o2), o2;
          }) : e3;
        }
      }, 9381: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
          return (0, r2.default)(e3, false, true);
        };
        var r2 = n2(2419);
      }, 109: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, n3, i) {
          return (0, r2.default)(e3, t3, [{ type: i ? "CommentLine" : "CommentBlock", value: n3 }]);
        };
        var r2 = n2(8647);
      }, 8647: (e2, t2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, n2) {
          if (!n2 || !e3) return e3;
          const r2 = `${t3}Comments`;
          return e3[r2] ? "leading" === t3 ? e3[r2] = n2.concat(e3[r2]) : e3[r2].push(...n2) : e3[r2] = n2, e3;
        };
      }, 2823: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
          (0, r2.default)("innerComments", e3, t3);
        };
        var r2 = n2(9906);
      }, 8930: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
          (0, r2.default)("leadingComments", e3, t3);
        };
        var r2 = n2(9906);
      }, 2714: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
          (0, r2.default)("trailingComments", e3, t3);
        };
        var r2 = n2(9906);
      }, 9134: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
          return (0, r2.default)(e3, t3), (0, i.default)(e3, t3), (0, s.default)(e3, t3), e3;
        };
        var r2 = n2(2714), i = n2(8930), s = n2(2823);
      }, 698: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
          return r2.COMMENT_KEYS.forEach((t3) => {
            e3[t3] = null;
          }), e3;
        };
        var r2 = n2(3725);
      }, 4998: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.WHILE_TYPES = t2.USERWHITESPACABLE_TYPES = t2.UNARYLIKE_TYPES = t2.TYPESCRIPT_TYPES = t2.TSTYPE_TYPES = t2.TSTYPEELEMENT_TYPES = t2.TSENTITYNAME_TYPES = t2.TSBASETYPE_TYPES = t2.TERMINATORLESS_TYPES = t2.STATEMENT_TYPES = t2.STANDARDIZED_TYPES = t2.SCOPABLE_TYPES = t2.PUREISH_TYPES = t2.PROPERTY_TYPES = t2.PRIVATE_TYPES = t2.PATTERN_TYPES = t2.PATTERNLIKE_TYPES = t2.OBJECTMEMBER_TYPES = t2.MODULESPECIFIER_TYPES = t2.MODULEDECLARATION_TYPES = t2.MISCELLANEOUS_TYPES = t2.METHOD_TYPES = t2.LVAL_TYPES = t2.LOOP_TYPES = t2.LITERAL_TYPES = t2.JSX_TYPES = t2.IMPORTOREXPORTDECLARATION_TYPES = t2.IMMUTABLE_TYPES = t2.FUNCTION_TYPES = t2.FUNCTIONPARENT_TYPES = t2.FOR_TYPES = t2.FORXSTATEMENT_TYPES = t2.FLOW_TYPES = t2.FLOWTYPE_TYPES = t2.FLOWPREDICATE_TYPES = t2.FLOWDECLARATION_TYPES = t2.FLOWBASEANNOTATION_TYPES = t2.EXPRESSION_TYPES = t2.EXPRESSIONWRAPPER_TYPES = t2.EXPORTDECLARATION_TYPES = t2.ENUMMEMBER_TYPES = t2.ENUMBODY_TYPES = t2.DECLARATION_TYPES = t2.CONDITIONAL_TYPES = t2.COMPLETIONSTATEMENT_TYPES = t2.CLASS_TYPES = t2.BLOCK_TYPES = t2.BLOCKPARENT_TYPES = t2.BINARY_TYPES = t2.ACCESSOR_TYPES = void 0;
        var r2 = n2(1678);
        const i = r2.FLIPPED_ALIAS_KEYS.Standardized;
        t2.STANDARDIZED_TYPES = i;
        const s = r2.FLIPPED_ALIAS_KEYS.Expression;
        t2.EXPRESSION_TYPES = s;
        const a = r2.FLIPPED_ALIAS_KEYS.Binary;
        t2.BINARY_TYPES = a;
        const o = r2.FLIPPED_ALIAS_KEYS.Scopable;
        t2.SCOPABLE_TYPES = o;
        const l = r2.FLIPPED_ALIAS_KEYS.BlockParent;
        t2.BLOCKPARENT_TYPES = l;
        const c = r2.FLIPPED_ALIAS_KEYS.Block;
        t2.BLOCK_TYPES = c;
        const u = r2.FLIPPED_ALIAS_KEYS.Statement;
        t2.STATEMENT_TYPES = u;
        const p = r2.FLIPPED_ALIAS_KEYS.Terminatorless;
        t2.TERMINATORLESS_TYPES = p;
        const h = r2.FLIPPED_ALIAS_KEYS.CompletionStatement;
        t2.COMPLETIONSTATEMENT_TYPES = h;
        const d = r2.FLIPPED_ALIAS_KEYS.Conditional;
        t2.CONDITIONAL_TYPES = d;
        const f = r2.FLIPPED_ALIAS_KEYS.Loop;
        t2.LOOP_TYPES = f;
        const y = r2.FLIPPED_ALIAS_KEYS.While;
        t2.WHILE_TYPES = y;
        const m = r2.FLIPPED_ALIAS_KEYS.ExpressionWrapper;
        t2.EXPRESSIONWRAPPER_TYPES = m;
        const T = r2.FLIPPED_ALIAS_KEYS.For;
        t2.FOR_TYPES = T;
        const g = r2.FLIPPED_ALIAS_KEYS.ForXStatement;
        t2.FORXSTATEMENT_TYPES = g;
        const b = r2.FLIPPED_ALIAS_KEYS.Function;
        t2.FUNCTION_TYPES = b;
        const E = r2.FLIPPED_ALIAS_KEYS.FunctionParent;
        t2.FUNCTIONPARENT_TYPES = E;
        const S = r2.FLIPPED_ALIAS_KEYS.Pureish;
        t2.PUREISH_TYPES = S;
        const P = r2.FLIPPED_ALIAS_KEYS.Declaration;
        t2.DECLARATION_TYPES = P;
        const x = r2.FLIPPED_ALIAS_KEYS.PatternLike;
        t2.PATTERNLIKE_TYPES = x;
        const D = r2.FLIPPED_ALIAS_KEYS.LVal;
        t2.LVAL_TYPES = D;
        const A = r2.FLIPPED_ALIAS_KEYS.TSEntityName;
        t2.TSENTITYNAME_TYPES = A;
        const v = r2.FLIPPED_ALIAS_KEYS.Literal;
        t2.LITERAL_TYPES = v;
        const C = r2.FLIPPED_ALIAS_KEYS.Immutable;
        t2.IMMUTABLE_TYPES = C;
        const w = r2.FLIPPED_ALIAS_KEYS.UserWhitespacable;
        t2.USERWHITESPACABLE_TYPES = w;
        const O = r2.FLIPPED_ALIAS_KEYS.Method;
        t2.METHOD_TYPES = O;
        const I = r2.FLIPPED_ALIAS_KEYS.ObjectMember;
        t2.OBJECTMEMBER_TYPES = I;
        const N = r2.FLIPPED_ALIAS_KEYS.Property;
        t2.PROPERTY_TYPES = N;
        const F = r2.FLIPPED_ALIAS_KEYS.UnaryLike;
        t2.UNARYLIKE_TYPES = F;
        const k = r2.FLIPPED_ALIAS_KEYS.Pattern;
        t2.PATTERN_TYPES = k;
        const L = r2.FLIPPED_ALIAS_KEYS.Class;
        t2.CLASS_TYPES = L;
        const _ = r2.FLIPPED_ALIAS_KEYS.ImportOrExportDeclaration;
        t2.IMPORTOREXPORTDECLARATION_TYPES = _;
        const M = r2.FLIPPED_ALIAS_KEYS.ExportDeclaration;
        t2.EXPORTDECLARATION_TYPES = M;
        const B = r2.FLIPPED_ALIAS_KEYS.ModuleSpecifier;
        t2.MODULESPECIFIER_TYPES = B;
        const j = r2.FLIPPED_ALIAS_KEYS.Accessor;
        t2.ACCESSOR_TYPES = j;
        const R = r2.FLIPPED_ALIAS_KEYS.Private;
        t2.PRIVATE_TYPES = R;
        const U = r2.FLIPPED_ALIAS_KEYS.Flow;
        t2.FLOW_TYPES = U;
        const V = r2.FLIPPED_ALIAS_KEYS.FlowType;
        t2.FLOWTYPE_TYPES = V;
        const K = r2.FLIPPED_ALIAS_KEYS.FlowBaseAnnotation;
        t2.FLOWBASEANNOTATION_TYPES = K;
        const W = r2.FLIPPED_ALIAS_KEYS.FlowDeclaration;
        t2.FLOWDECLARATION_TYPES = W;
        const X = r2.FLIPPED_ALIAS_KEYS.FlowPredicate;
        t2.FLOWPREDICATE_TYPES = X;
        const Y = r2.FLIPPED_ALIAS_KEYS.EnumBody;
        t2.ENUMBODY_TYPES = Y;
        const q = r2.FLIPPED_ALIAS_KEYS.EnumMember;
        t2.ENUMMEMBER_TYPES = q;
        const H = r2.FLIPPED_ALIAS_KEYS.JSX;
        t2.JSX_TYPES = H;
        const J = r2.FLIPPED_ALIAS_KEYS.Miscellaneous;
        t2.MISCELLANEOUS_TYPES = J;
        const $ = r2.FLIPPED_ALIAS_KEYS.TypeScript;
        t2.TYPESCRIPT_TYPES = $;
        const G = r2.FLIPPED_ALIAS_KEYS.TSTypeElement;
        t2.TSTYPEELEMENT_TYPES = G;
        const z = r2.FLIPPED_ALIAS_KEYS.TSType;
        t2.TSTYPE_TYPES = z;
        const Q = r2.FLIPPED_ALIAS_KEYS.TSBaseType;
        t2.TSBASETYPE_TYPES = Q;
        const Z = _;
        t2.MODULEDECLARATION_TYPES = Z;
      }, 3725: (e2, t2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.UPDATE_OPERATORS = t2.UNARY_OPERATORS = t2.STRING_UNARY_OPERATORS = t2.STATEMENT_OR_BLOCK_KEYS = t2.NUMBER_UNARY_OPERATORS = t2.NUMBER_BINARY_OPERATORS = t2.NOT_LOCAL_BINDING = t2.LOGICAL_OPERATORS = t2.INHERIT_KEYS = t2.FOR_INIT_KEYS = t2.FLATTENABLE_KEYS = t2.EQUALITY_BINARY_OPERATORS = t2.COMPARISON_BINARY_OPERATORS = t2.COMMENT_KEYS = t2.BOOLEAN_UNARY_OPERATORS = t2.BOOLEAN_NUMBER_BINARY_OPERATORS = t2.BOOLEAN_BINARY_OPERATORS = t2.BLOCK_SCOPED_SYMBOL = t2.BINARY_OPERATORS = t2.ASSIGNMENT_OPERATORS = void 0, t2.STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"], t2.FLATTENABLE_KEYS = ["body", "expressions"], t2.FOR_INIT_KEYS = ["left", "init"], t2.COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];
        const n2 = ["||", "&&", "??"];
        t2.LOGICAL_OPERATORS = n2, t2.UPDATE_OPERATORS = ["++", "--"];
        const r2 = [">", "<", ">=", "<="];
        t2.BOOLEAN_NUMBER_BINARY_OPERATORS = r2;
        const i = ["==", "===", "!=", "!=="];
        t2.EQUALITY_BINARY_OPERATORS = i;
        const s = [...i, "in", "instanceof"];
        t2.COMPARISON_BINARY_OPERATORS = s;
        const a = [...s, ...r2];
        t2.BOOLEAN_BINARY_OPERATORS = a;
        const o = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"];
        t2.NUMBER_BINARY_OPERATORS = o;
        const l = ["+", ...o, ...a, "|>"];
        t2.BINARY_OPERATORS = l;
        const c = ["=", "+=", ...o.map((e3) => e3 + "="), ...n2.map((e3) => e3 + "=")];
        t2.ASSIGNMENT_OPERATORS = c;
        const u = ["delete", "!"];
        t2.BOOLEAN_UNARY_OPERATORS = u;
        const p = ["+", "-", "~"];
        t2.NUMBER_UNARY_OPERATORS = p;
        const h = ["typeof"];
        t2.STRING_UNARY_OPERATORS = h;
        const d = ["void", "throw", ...u, ...p, ...h];
        t2.UNARY_OPERATORS = d, t2.INHERIT_KEYS = { optional: ["typeAnnotation", "typeParameters", "returnType"], force: ["start", "loc", "end"] };
        const f = Symbol.for("var used to be block scoped");
        t2.BLOCK_SCOPED_SYMBOL = f;
        const y = Symbol.for("should not be considered a local binding");
        t2.NOT_LOCAL_BINDING = y;
      }, 8560: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3 = "body") {
          const n3 = (0, r2.default)(e3[t3], e3);
          return e3[t3] = n3, n3;
        };
        var r2 = n2(9988);
      }, 3556: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function e3(t3, n3, o) {
          const l = [];
          let c = true;
          for (const u of t3) if ((0, i.isEmptyStatement)(u) || (c = false), (0, i.isExpression)(u)) l.push(u);
          else if ((0, i.isExpressionStatement)(u)) l.push(u.expression);
          else if ((0, i.isVariableDeclaration)(u)) {
            if ("var" !== u.kind) return;
            for (const e4 of u.declarations) {
              const t4 = (0, r2.default)(e4);
              for (const e5 of Object.keys(t4)) o.push({ kind: u.kind, id: (0, a.default)(t4[e5]) });
              e4.init && l.push((0, s.assignmentExpression)("=", e4.id, e4.init));
            }
            c = true;
          } else if ((0, i.isIfStatement)(u)) {
            const t4 = u.consequent ? e3([u.consequent], n3, o) : n3.buildUndefinedNode(), r3 = u.alternate ? e3([u.alternate], n3, o) : n3.buildUndefinedNode();
            if (!t4 || !r3) return;
            l.push((0, s.conditionalExpression)(u.test, t4, r3));
          } else if ((0, i.isBlockStatement)(u)) {
            const t4 = e3(u.body, n3, o);
            if (!t4) return;
            l.push(t4);
          } else {
            if (!(0, i.isEmptyStatement)(u)) return;
            0 === t3.indexOf(u) && (c = true);
          }
          return c && l.push(n3.buildUndefinedNode()), 1 === l.length ? l[0] : (0, s.sequenceExpression)(l);
        };
        var r2 = n2(984), i = n2(9869), s = n2(1411), a = n2(2419);
      }, 5200: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
          return "eval" !== (e3 = (0, r2.default)(e3)) && "arguments" !== e3 || (e3 = "_" + e3), e3;
        };
        var r2 = n2(7885);
      }, 9988: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
          if ((0, r2.isBlockStatement)(e3)) return e3;
          let n3 = [];
          return (0, r2.isEmptyStatement)(e3) ? n3 = [] : ((0, r2.isStatement)(e3) || (e3 = (0, r2.isFunction)(t3) ? (0, i.returnStatement)(e3) : (0, i.expressionStatement)(e3)), n3 = [e3]), (0, i.blockStatement)(n3);
        };
        var r2 = n2(9869), i = n2(1411);
      }, 3816: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3 = e3.key || e3.property) {
          return !e3.computed && (0, r2.isIdentifier)(t3) && (t3 = (0, i.stringLiteral)(t3.name)), t3;
        };
        var r2 = n2(9869), i = n2(1411);
      }, 5317: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var r2 = n2(9869);
        t2.default = function(e3) {
          if ((0, r2.isExpressionStatement)(e3) && (e3 = e3.expression), (0, r2.isExpression)(e3)) return e3;
          if ((0, r2.isClass)(e3) ? e3.type = "ClassExpression" : (0, r2.isFunction)(e3) && (e3.type = "FunctionExpression"), !(0, r2.isExpression)(e3)) throw new Error(`cannot turn ${e3.type} to an expression`);
          return e3;
        };
      }, 7885: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
          e3 += "";
          let t3 = "";
          for (const n3 of e3) t3 += (0, i.isIdentifierChar)(n3.codePointAt(0)) ? n3 : "-";
          return t3 = t3.replace(/^[-0-9]+/, ""), t3 = t3.replace(/[-\s]+(.)?/g, function(e4, t4) {
            return t4 ? t4.toUpperCase() : "";
          }), (0, r2.default)(t3) || (t3 = `_${t3}`), t3 || "_";
        };
        var r2 = n2(5820), i = n2(9649);
      }, 5046: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = a;
        var r2 = n2(9869), i = n2(2419), s = n2(857);
        function a(e3, t3 = e3.key) {
          let n3;
          return "method" === e3.kind ? a.increment() + "" : (n3 = (0, r2.isIdentifier)(t3) ? t3.name : (0, r2.isStringLiteral)(t3) ? JSON.stringify(t3.value) : JSON.stringify((0, s.default)((0, i.default)(t3))), e3.computed && (n3 = `[${n3}]`), e3.static && (n3 = `static:${n3}`), n3);
        }
        a.uid = 0, a.increment = function() {
          return a.uid >= Number.MAX_SAFE_INTEGER ? a.uid = 0 : a.uid++;
        };
      }, 2473: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
          if (null == e3 || !e3.length) return;
          const n3 = [], i = (0, r2.default)(e3, t3, n3);
          if (i) {
            for (const e4 of n3) t3.push(e4);
            return i;
          }
        };
        var r2 = n2(3556);
      }, 350: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var r2 = n2(9869), i = n2(1411);
        t2.default = function(e3, t3) {
          if ((0, r2.isStatement)(e3)) return e3;
          let n3, s = false;
          if ((0, r2.isClass)(e3)) s = true, n3 = "ClassDeclaration";
          else if ((0, r2.isFunction)(e3)) s = true, n3 = "FunctionDeclaration";
          else if ((0, r2.isAssignmentExpression)(e3)) return (0, i.expressionStatement)(e3);
          if (s && !e3.id && (n3 = false), !n3) {
            if (t3) return false;
            throw new Error(`cannot turn ${e3.type} to a statement`);
          }
          return e3.type = n3, e3;
        };
      }, 1382: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var r2 = n2(5820), i = n2(1411);
        t2.default = function e3(t3) {
          if (void 0 === t3) return (0, i.identifier)("undefined");
          if (true === t3 || false === t3) return (0, i.booleanLiteral)(t3);
          if (null === t3) return (0, i.nullLiteral)();
          if ("string" == typeof t3) return (0, i.stringLiteral)(t3);
          if ("number" == typeof t3) {
            let e4;
            if (Number.isFinite(t3)) e4 = (0, i.numericLiteral)(Math.abs(t3));
            else {
              let n3;
              n3 = Number.isNaN(t3) ? (0, i.numericLiteral)(0) : (0, i.numericLiteral)(1), e4 = (0, i.binaryExpression)("/", n3, (0, i.numericLiteral)(0));
            }
            return (t3 < 0 || Object.is(t3, -0)) && (e4 = (0, i.unaryExpression)("-", e4)), e4;
          }
          if (function(e4) {
            return "[object RegExp]" === s(e4);
          }(t3)) {
            const e4 = t3.source, n3 = t3.toString().match(/\/([a-z]+|)$/)[1];
            return (0, i.regExpLiteral)(e4, n3);
          }
          if (Array.isArray(t3)) return (0, i.arrayExpression)(t3.map(e3));
          if (function(e4) {
            if ("object" != typeof e4 || null === e4 || "[object Object]" !== Object.prototype.toString.call(e4)) return false;
            const t4 = Object.getPrototypeOf(e4);
            return null === t4 || null === Object.getPrototypeOf(t4);
          }(t3)) {
            const n3 = [];
            for (const s2 of Object.keys(t3)) {
              let a;
              a = (0, r2.default)(s2) ? (0, i.identifier)(s2) : (0, i.stringLiteral)(s2), n3.push((0, i.objectProperty)(a, e3(t3[s2])));
            }
            return (0, i.objectExpression)(n3);
          }
          throw new Error("don't know how to turn this value into a node");
        };
        const s = Function.call.bind(Object.prototype.toString);
      }, 8248: (e2, t2, n2) => {
        "use strict";
        var r2 = n2(4155);
        Object.defineProperty(t2, "__esModule", { value: true }), t2.patternLikeCommon = t2.functionTypeAnnotationCommon = t2.functionDeclarationCommon = t2.functionCommon = t2.classMethodOrPropertyCommon = t2.classMethodOrDeclareMethodCommon = void 0;
        var i = n2(5171), s = n2(5820), a = n2(9649), o = n2(7648), l = n2(3725), c = n2(1514);
        const u = (0, c.defineAliasedType)("Standardized");
        u("ArrayExpression", { fields: { elements: { validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeOrValueType)("null", "Expression", "SpreadElement"))), default: r2.env.BABEL_TYPES_8_BREAKING ? void 0 : [] } }, visitor: ["elements"], aliases: ["Expression"] }), u("AssignmentExpression", { fields: { operator: { validate: function() {
          if (!r2.env.BABEL_TYPES_8_BREAKING) return (0, c.assertValueType)("string");
          const e3 = (0, c.assertOneOf)(...l.ASSIGNMENT_OPERATORS), t3 = (0, c.assertOneOf)("=");
          return function(n3, r3, s2) {
            ((0, i.default)("Pattern", n3.left) ? t3 : e3)(n3, r3, s2);
          };
        }() }, left: { validate: r2.env.BABEL_TYPES_8_BREAKING ? (0, c.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, c.assertNodeType)("LVal") }, right: { validate: (0, c.assertNodeType)("Expression") } }, builder: ["operator", "left", "right"], visitor: ["left", "right"], aliases: ["Expression"] }), u("BinaryExpression", { builder: ["operator", "left", "right"], fields: { operator: { validate: (0, c.assertOneOf)(...l.BINARY_OPERATORS) }, left: { validate: function() {
          const e3 = (0, c.assertNodeType)("Expression"), t3 = (0, c.assertNodeType)("Expression", "PrivateName");
          return Object.assign(function(n3, r3, i2) {
            ("in" === n3.operator ? t3 : e3)(n3, r3, i2);
          }, { oneOfNodeTypes: ["Expression", "PrivateName"] });
        }() }, right: { validate: (0, c.assertNodeType)("Expression") } }, visitor: ["left", "right"], aliases: ["Binary", "Expression"] }), u("InterpreterDirective", { builder: ["value"], fields: { value: { validate: (0, c.assertValueType)("string") } } }), u("Directive", { visitor: ["value"], fields: { value: { validate: (0, c.assertNodeType)("DirectiveLiteral") } } }), u("DirectiveLiteral", { builder: ["value"], fields: { value: { validate: (0, c.assertValueType)("string") } } }), u("BlockStatement", { builder: ["body", "directives"], visitor: ["directives", "body"], fields: { directives: { validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("Directive"))), default: [] }, body: { validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("Statement"))) } }, aliases: ["Scopable", "BlockParent", "Block", "Statement"] }), u("BreakStatement", { visitor: ["label"], fields: { label: { validate: (0, c.assertNodeType)("Identifier"), optional: true } }, aliases: ["Statement", "Terminatorless", "CompletionStatement"] }), u("CallExpression", { visitor: ["callee", "arguments", "typeParameters", "typeArguments"], builder: ["callee", "arguments"], aliases: ["Expression"], fields: Object.assign({ callee: { validate: (0, c.assertNodeType)("Expression", "Super", "V8IntrinsicIdentifier") }, arguments: { validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder"))) } }, r2.env.BABEL_TYPES_8_BREAKING ? {} : { optional: { validate: (0, c.assertOneOf)(true, false), optional: true } }, { typeArguments: { validate: (0, c.assertNodeType)("TypeParameterInstantiation"), optional: true }, typeParameters: { validate: (0, c.assertNodeType)("TSTypeParameterInstantiation"), optional: true } }) }), u("CatchClause", { visitor: ["param", "body"], fields: { param: { validate: (0, c.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"), optional: true }, body: { validate: (0, c.assertNodeType)("BlockStatement") } }, aliases: ["Scopable", "BlockParent"] }), u("ConditionalExpression", { visitor: ["test", "consequent", "alternate"], fields: { test: { validate: (0, c.assertNodeType)("Expression") }, consequent: { validate: (0, c.assertNodeType)("Expression") }, alternate: { validate: (0, c.assertNodeType)("Expression") } }, aliases: ["Expression", "Conditional"] }), u("ContinueStatement", { visitor: ["label"], fields: { label: { validate: (0, c.assertNodeType)("Identifier"), optional: true } }, aliases: ["Statement", "Terminatorless", "CompletionStatement"] }), u("DebuggerStatement", { aliases: ["Statement"] }), u("DoWhileStatement", { visitor: ["test", "body"], fields: { test: { validate: (0, c.assertNodeType)("Expression") }, body: { validate: (0, c.assertNodeType)("Statement") } }, aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"] }), u("EmptyStatement", { aliases: ["Statement"] }), u("ExpressionStatement", { visitor: ["expression"], fields: { expression: { validate: (0, c.assertNodeType)("Expression") } }, aliases: ["Statement", "ExpressionWrapper"] }), u("File", { builder: ["program", "comments", "tokens"], visitor: ["program"], fields: { program: { validate: (0, c.assertNodeType)("Program") }, comments: { validate: r2.env.BABEL_TYPES_8_BREAKING ? (0, c.assertEach)((0, c.assertNodeType)("CommentBlock", "CommentLine")) : Object.assign(() => {
        }, { each: { oneOfNodeTypes: ["CommentBlock", "CommentLine"] } }), optional: true }, tokens: { validate: (0, c.assertEach)(Object.assign(() => {
        }, { type: "any" })), optional: true } } }), u("ForInStatement", { visitor: ["left", "right", "body"], aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"], fields: { left: { validate: r2.env.BABEL_TYPES_8_BREAKING ? (0, c.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, c.assertNodeType)("VariableDeclaration", "LVal") }, right: { validate: (0, c.assertNodeType)("Expression") }, body: { validate: (0, c.assertNodeType)("Statement") } } }), u("ForStatement", { visitor: ["init", "test", "update", "body"], aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"], fields: { init: { validate: (0, c.assertNodeType)("VariableDeclaration", "Expression"), optional: true }, test: { validate: (0, c.assertNodeType)("Expression"), optional: true }, update: { validate: (0, c.assertNodeType)("Expression"), optional: true }, body: { validate: (0, c.assertNodeType)("Statement") } } });
        const p = () => ({ params: { validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("Identifier", "Pattern", "RestElement"))) }, generator: { default: false }, async: { default: false } });
        t2.functionCommon = p;
        const h = () => ({ returnType: { validate: (0, c.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"), optional: true }, typeParameters: { validate: (0, c.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"), optional: true } });
        t2.functionTypeAnnotationCommon = h;
        const d = () => Object.assign({}, p(), { declare: { validate: (0, c.assertValueType)("boolean"), optional: true }, id: { validate: (0, c.assertNodeType)("Identifier"), optional: true } });
        t2.functionDeclarationCommon = d, u("FunctionDeclaration", { builder: ["id", "params", "body", "generator", "async"], visitor: ["id", "params", "body", "returnType", "typeParameters"], fields: Object.assign({}, d(), h(), { body: { validate: (0, c.assertNodeType)("BlockStatement") }, predicate: { validate: (0, c.assertNodeType)("DeclaredPredicate", "InferredPredicate"), optional: true } }), aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"], validate: function() {
          if (!r2.env.BABEL_TYPES_8_BREAKING) return () => {
          };
          const e3 = (0, c.assertNodeType)("Identifier");
          return function(t3, n3, r3) {
            (0, i.default)("ExportDefaultDeclaration", t3) || e3(r3, "id", r3.id);
          };
        }() }), u("FunctionExpression", { inherits: "FunctionDeclaration", aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"], fields: Object.assign({}, p(), h(), { id: { validate: (0, c.assertNodeType)("Identifier"), optional: true }, body: { validate: (0, c.assertNodeType)("BlockStatement") }, predicate: { validate: (0, c.assertNodeType)("DeclaredPredicate", "InferredPredicate"), optional: true } }) });
        const f = () => ({ typeAnnotation: { validate: (0, c.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"), optional: true }, optional: { validate: (0, c.assertValueType)("boolean"), optional: true }, decorators: { validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("Decorator"))), optional: true } });
        t2.patternLikeCommon = f, u("Identifier", { builder: ["name"], visitor: ["typeAnnotation", "decorators"], aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"], fields: Object.assign({}, f(), { name: { validate: (0, c.chain)((0, c.assertValueType)("string"), Object.assign(function(e3, t3, n3) {
          if (r2.env.BABEL_TYPES_8_BREAKING && !(0, s.default)(n3, false)) throw new TypeError(`"${n3}" is not a valid identifier name`);
        }, { type: "string" })) } }), validate(e3, t3, n3) {
          if (!r2.env.BABEL_TYPES_8_BREAKING) return;
          const s2 = /\.(\w+)$/.exec(t3);
          if (!s2) return;
          const [, o2] = s2, l2 = { computed: false };
          if ("property" === o2) {
            if ((0, i.default)("MemberExpression", e3, l2)) return;
            if ((0, i.default)("OptionalMemberExpression", e3, l2)) return;
          } else if ("key" === o2) {
            if ((0, i.default)("Property", e3, l2)) return;
            if ((0, i.default)("Method", e3, l2)) return;
          } else if ("exported" === o2) {
            if ((0, i.default)("ExportSpecifier", e3)) return;
          } else if ("imported" === o2) {
            if ((0, i.default)("ImportSpecifier", e3, { imported: n3 })) return;
          } else if ("meta" === o2 && (0, i.default)("MetaProperty", e3, { meta: n3 })) return;
          if (((0, a.isKeyword)(n3.name) || (0, a.isReservedWord)(n3.name, false)) && "this" !== n3.name) throw new TypeError(`"${n3.name}" is not a valid identifier`);
        } }), u("IfStatement", { visitor: ["test", "consequent", "alternate"], aliases: ["Statement", "Conditional"], fields: { test: { validate: (0, c.assertNodeType)("Expression") }, consequent: { validate: (0, c.assertNodeType)("Statement") }, alternate: { optional: true, validate: (0, c.assertNodeType)("Statement") } } }), u("LabeledStatement", { visitor: ["label", "body"], aliases: ["Statement"], fields: { label: { validate: (0, c.assertNodeType)("Identifier") }, body: { validate: (0, c.assertNodeType)("Statement") } } }), u("StringLiteral", { builder: ["value"], fields: { value: { validate: (0, c.assertValueType)("string") } }, aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), u("NumericLiteral", { builder: ["value"], deprecatedAlias: "NumberLiteral", fields: { value: { validate: (0, c.chain)((0, c.assertValueType)("number"), Object.assign(function(e3, t3, n3) {
          (1 / n3 < 0 || !Number.isFinite(n3)) && new Error(`NumericLiterals must be non-negative finite numbers. You can use t.valueToNode(${n3}) instead.`);
        }, { type: "number" })) } }, aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), u("NullLiteral", { aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), u("BooleanLiteral", { builder: ["value"], fields: { value: { validate: (0, c.assertValueType)("boolean") } }, aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), u("RegExpLiteral", { builder: ["pattern", "flags"], deprecatedAlias: "RegexLiteral", aliases: ["Expression", "Pureish", "Literal"], fields: { pattern: { validate: (0, c.assertValueType)("string") }, flags: { validate: (0, c.chain)((0, c.assertValueType)("string"), Object.assign(function(e3, t3, n3) {
          if (!r2.env.BABEL_TYPES_8_BREAKING) return;
          const i2 = /[^gimsuy]/.exec(n3);
          if (i2) throw new TypeError(`"${i2[0]}" is not a valid RegExp flag`);
        }, { type: "string" })), default: "" } } }), u("LogicalExpression", { builder: ["operator", "left", "right"], visitor: ["left", "right"], aliases: ["Binary", "Expression"], fields: { operator: { validate: (0, c.assertOneOf)(...l.LOGICAL_OPERATORS) }, left: { validate: (0, c.assertNodeType)("Expression") }, right: { validate: (0, c.assertNodeType)("Expression") } } }), u("MemberExpression", { builder: ["object", "property", "computed", ...r2.env.BABEL_TYPES_8_BREAKING ? [] : ["optional"]], visitor: ["object", "property"], aliases: ["Expression", "LVal"], fields: Object.assign({ object: { validate: (0, c.assertNodeType)("Expression", "Super") }, property: { validate: function() {
          const e3 = (0, c.assertNodeType)("Identifier", "PrivateName"), t3 = (0, c.assertNodeType)("Expression"), n3 = function(n4, r3, i2) {
            (n4.computed ? t3 : e3)(n4, r3, i2);
          };
          return n3.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"], n3;
        }() }, computed: { default: false } }, r2.env.BABEL_TYPES_8_BREAKING ? {} : { optional: { validate: (0, c.assertOneOf)(true, false), optional: true } }) }), u("NewExpression", { inherits: "CallExpression" }), u("Program", { visitor: ["directives", "body"], builder: ["body", "directives", "sourceType", "interpreter"], fields: { sourceFile: { validate: (0, c.assertValueType)("string") }, sourceType: { validate: (0, c.assertOneOf)("script", "module"), default: "script" }, interpreter: { validate: (0, c.assertNodeType)("InterpreterDirective"), default: null, optional: true }, directives: { validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("Directive"))), default: [] }, body: { validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("Statement"))) } }, aliases: ["Scopable", "BlockParent", "Block"] }), u("ObjectExpression", { visitor: ["properties"], aliases: ["Expression"], fields: { properties: { validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("ObjectMethod", "ObjectProperty", "SpreadElement"))) } } }), u("ObjectMethod", { builder: ["kind", "key", "params", "body", "computed", "generator", "async"], fields: Object.assign({}, p(), h(), { kind: Object.assign({ validate: (0, c.assertOneOf)("method", "get", "set") }, r2.env.BABEL_TYPES_8_BREAKING ? {} : { default: "method" }), computed: { default: false }, key: { validate: function() {
          const e3 = (0, c.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), t3 = (0, c.assertNodeType)("Expression"), n3 = function(n4, r3, i2) {
            (n4.computed ? t3 : e3)(n4, r3, i2);
          };
          return n3.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"], n3;
        }() }, decorators: { validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("Decorator"))), optional: true }, body: { validate: (0, c.assertNodeType)("BlockStatement") } }), visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"], aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"] }), u("ObjectProperty", { builder: ["key", "value", "computed", "shorthand", ...r2.env.BABEL_TYPES_8_BREAKING ? [] : ["decorators"]], fields: { computed: { default: false }, key: { validate: function() {
          const e3 = (0, c.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"), t3 = (0, c.assertNodeType)("Expression");
          return Object.assign(function(n3, r3, i2) {
            (n3.computed ? t3 : e3)(n3, r3, i2);
          }, { oneOfNodeTypes: ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"] });
        }() }, value: { validate: (0, c.assertNodeType)("Expression", "PatternLike") }, shorthand: { validate: (0, c.chain)((0, c.assertValueType)("boolean"), Object.assign(function(e3, t3, n3) {
          if (r2.env.BABEL_TYPES_8_BREAKING && n3 && e3.computed) throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
        }, { type: "boolean" }), function(e3, t3, n3) {
          if (r2.env.BABEL_TYPES_8_BREAKING && n3 && !(0, i.default)("Identifier", e3.key)) throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
        }), default: false }, decorators: { validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("Decorator"))), optional: true } }, visitor: ["key", "value", "decorators"], aliases: ["UserWhitespacable", "Property", "ObjectMember"], validate: function() {
          const e3 = (0, c.assertNodeType)("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssertion"), t3 = (0, c.assertNodeType)("Expression");
          return function(n3, s2, a2) {
            r2.env.BABEL_TYPES_8_BREAKING && ((0, i.default)("ObjectPattern", n3) ? e3 : t3)(a2, "value", a2.value);
          };
        }() }), u("RestElement", { visitor: ["argument", "typeAnnotation"], builder: ["argument"], aliases: ["LVal", "PatternLike"], deprecatedAlias: "RestProperty", fields: Object.assign({}, f(), { argument: { validate: r2.env.BABEL_TYPES_8_BREAKING ? (0, c.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, c.assertNodeType)("LVal") } }), validate(e3, t3) {
          if (!r2.env.BABEL_TYPES_8_BREAKING) return;
          const n3 = /(\w+)\[(\d+)\]/.exec(t3);
          if (!n3) throw new Error("Internal Babel error: malformed key.");
          const [, i2, s2] = n3;
          if (e3[i2].length > +s2 + 1) throw new TypeError(`RestElement must be last element of ${i2}`);
        } }), u("ReturnStatement", { visitor: ["argument"], aliases: ["Statement", "Terminatorless", "CompletionStatement"], fields: { argument: { validate: (0, c.assertNodeType)("Expression"), optional: true } } }), u("SequenceExpression", { visitor: ["expressions"], fields: { expressions: { validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("Expression"))) } }, aliases: ["Expression"] }), u("ParenthesizedExpression", { visitor: ["expression"], aliases: ["Expression", "ExpressionWrapper"], fields: { expression: { validate: (0, c.assertNodeType)("Expression") } } }), u("SwitchCase", { visitor: ["test", "consequent"], fields: { test: { validate: (0, c.assertNodeType)("Expression"), optional: true }, consequent: { validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("Statement"))) } } }), u("SwitchStatement", { visitor: ["discriminant", "cases"], aliases: ["Statement", "BlockParent", "Scopable"], fields: { discriminant: { validate: (0, c.assertNodeType)("Expression") }, cases: { validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("SwitchCase"))) } } }), u("ThisExpression", { aliases: ["Expression"] }), u("ThrowStatement", { visitor: ["argument"], aliases: ["Statement", "Terminatorless", "CompletionStatement"], fields: { argument: { validate: (0, c.assertNodeType)("Expression") } } }), u("TryStatement", { visitor: ["block", "handler", "finalizer"], aliases: ["Statement"], fields: { block: { validate: (0, c.chain)((0, c.assertNodeType)("BlockStatement"), Object.assign(function(e3) {
          if (r2.env.BABEL_TYPES_8_BREAKING && !e3.handler && !e3.finalizer) throw new TypeError("TryStatement expects either a handler or finalizer, or both");
        }, { oneOfNodeTypes: ["BlockStatement"] })) }, handler: { optional: true, validate: (0, c.assertNodeType)("CatchClause") }, finalizer: { optional: true, validate: (0, c.assertNodeType)("BlockStatement") } } }), u("UnaryExpression", { builder: ["operator", "argument", "prefix"], fields: { prefix: { default: true }, argument: { validate: (0, c.assertNodeType)("Expression") }, operator: { validate: (0, c.assertOneOf)(...l.UNARY_OPERATORS) } }, visitor: ["argument"], aliases: ["UnaryLike", "Expression"] }), u("UpdateExpression", { builder: ["operator", "argument", "prefix"], fields: { prefix: { default: false }, argument: { validate: r2.env.BABEL_TYPES_8_BREAKING ? (0, c.assertNodeType)("Identifier", "MemberExpression") : (0, c.assertNodeType)("Expression") }, operator: { validate: (0, c.assertOneOf)(...l.UPDATE_OPERATORS) } }, visitor: ["argument"], aliases: ["Expression"] }), u("VariableDeclaration", { builder: ["kind", "declarations"], visitor: ["declarations"], aliases: ["Statement", "Declaration"], fields: { declare: { validate: (0, c.assertValueType)("boolean"), optional: true }, kind: { validate: (0, c.assertOneOf)("var", "let", "const", "using", "await using") }, declarations: { validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("VariableDeclarator"))) } }, validate(e3, t3, n3) {
          if (r2.env.BABEL_TYPES_8_BREAKING && (0, i.default)("ForXStatement", e3, { left: n3 }) && 1 !== n3.declarations.length) throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${e3.type}`);
        } }), u("VariableDeclarator", { visitor: ["id", "init"], fields: { id: { validate: function() {
          if (!r2.env.BABEL_TYPES_8_BREAKING) return (0, c.assertNodeType)("LVal");
          const e3 = (0, c.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"), t3 = (0, c.assertNodeType)("Identifier");
          return function(n3, r3, i2) {
            (n3.init ? e3 : t3)(n3, r3, i2);
          };
        }() }, definite: { optional: true, validate: (0, c.assertValueType)("boolean") }, init: { optional: true, validate: (0, c.assertNodeType)("Expression") } } }), u("WhileStatement", { visitor: ["test", "body"], aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"], fields: { test: { validate: (0, c.assertNodeType)("Expression") }, body: { validate: (0, c.assertNodeType)("Statement") } } }), u("WithStatement", { visitor: ["object", "body"], aliases: ["Statement"], fields: { object: { validate: (0, c.assertNodeType)("Expression") }, body: { validate: (0, c.assertNodeType)("Statement") } } }), u("AssignmentPattern", { visitor: ["left", "right", "decorators"], builder: ["left", "right"], aliases: ["Pattern", "PatternLike", "LVal"], fields: Object.assign({}, f(), { left: { validate: (0, c.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") }, right: { validate: (0, c.assertNodeType)("Expression") }, decorators: { validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("Decorator"))), optional: true } }) }), u("ArrayPattern", { visitor: ["elements", "typeAnnotation"], builder: ["elements"], aliases: ["Pattern", "PatternLike", "LVal"], fields: Object.assign({}, f(), { elements: { validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeOrValueType)("null", "PatternLike", "LVal"))) } }) }), u("ArrowFunctionExpression", { builder: ["params", "body", "async"], visitor: ["params", "body", "returnType", "typeParameters"], aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"], fields: Object.assign({}, p(), h(), { expression: { validate: (0, c.assertValueType)("boolean") }, body: { validate: (0, c.assertNodeType)("BlockStatement", "Expression") }, predicate: { validate: (0, c.assertNodeType)("DeclaredPredicate", "InferredPredicate"), optional: true } }) }), u("ClassBody", { visitor: ["body"], fields: { body: { validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty", "TSDeclareMethod", "TSIndexSignature", "StaticBlock"))) } } }), u("ClassExpression", { builder: ["id", "superClass", "body", "decorators"], visitor: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators"], aliases: ["Scopable", "Class", "Expression"], fields: { id: { validate: (0, c.assertNodeType)("Identifier"), optional: true }, typeParameters: { validate: (0, c.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"), optional: true }, body: { validate: (0, c.assertNodeType)("ClassBody") }, superClass: { optional: true, validate: (0, c.assertNodeType)("Expression") }, superTypeParameters: { validate: (0, c.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"), optional: true }, implements: { validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))), optional: true }, decorators: { validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("Decorator"))), optional: true }, mixins: { validate: (0, c.assertNodeType)("InterfaceExtends"), optional: true } } }), u("ClassDeclaration", { inherits: "ClassExpression", aliases: ["Scopable", "Class", "Statement", "Declaration"], fields: { id: { validate: (0, c.assertNodeType)("Identifier") }, typeParameters: { validate: (0, c.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"), optional: true }, body: { validate: (0, c.assertNodeType)("ClassBody") }, superClass: { optional: true, validate: (0, c.assertNodeType)("Expression") }, superTypeParameters: { validate: (0, c.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"), optional: true }, implements: { validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))), optional: true }, decorators: { validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("Decorator"))), optional: true }, mixins: { validate: (0, c.assertNodeType)("InterfaceExtends"), optional: true }, declare: { validate: (0, c.assertValueType)("boolean"), optional: true }, abstract: { validate: (0, c.assertValueType)("boolean"), optional: true } }, validate: function() {
          const e3 = (0, c.assertNodeType)("Identifier");
          return function(t3, n3, s2) {
            r2.env.BABEL_TYPES_8_BREAKING && ((0, i.default)("ExportDefaultDeclaration", t3) || e3(s2, "id", s2.id));
          };
        }() }), u("ExportAllDeclaration", { builder: ["source"], visitor: ["source", "attributes", "assertions"], aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"], fields: { source: { validate: (0, c.assertNodeType)("StringLiteral") }, exportKind: (0, c.validateOptional)((0, c.assertOneOf)("type", "value")), attributes: { optional: true, validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("ImportAttribute"))) }, assertions: { optional: true, validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("ImportAttribute"))) } } }), u("ExportDefaultDeclaration", { visitor: ["declaration"], aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"], fields: { declaration: { validate: (0, c.assertNodeType)("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression") }, exportKind: (0, c.validateOptional)((0, c.assertOneOf)("value")) } }), u("ExportNamedDeclaration", { builder: ["declaration", "specifiers", "source"], visitor: ["declaration", "specifiers", "source", "attributes", "assertions"], aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"], fields: { declaration: { optional: true, validate: (0, c.chain)((0, c.assertNodeType)("Declaration"), Object.assign(function(e3, t3, n3) {
          if (r2.env.BABEL_TYPES_8_BREAKING && n3 && e3.specifiers.length) throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
        }, { oneOfNodeTypes: ["Declaration"] }), function(e3, t3, n3) {
          if (r2.env.BABEL_TYPES_8_BREAKING && n3 && e3.source) throw new TypeError("Cannot export a declaration from a source");
        }) }, attributes: { optional: true, validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("ImportAttribute"))) }, assertions: { optional: true, validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("ImportAttribute"))) }, specifiers: { default: [], validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)(function() {
          const e3 = (0, c.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier"), t3 = (0, c.assertNodeType)("ExportSpecifier");
          return r2.env.BABEL_TYPES_8_BREAKING ? function(n3, r3, i2) {
            (n3.source ? e3 : t3)(n3, r3, i2);
          } : e3;
        }())) }, source: { validate: (0, c.assertNodeType)("StringLiteral"), optional: true }, exportKind: (0, c.validateOptional)((0, c.assertOneOf)("type", "value")) } }), u("ExportSpecifier", { visitor: ["local", "exported"], aliases: ["ModuleSpecifier"], fields: { local: { validate: (0, c.assertNodeType)("Identifier") }, exported: { validate: (0, c.assertNodeType)("Identifier", "StringLiteral") }, exportKind: { validate: (0, c.assertOneOf)("type", "value"), optional: true } } }), u("ForOfStatement", { visitor: ["left", "right", "body"], builder: ["left", "right", "body", "await"], aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"], fields: { left: { validate: function() {
          if (!r2.env.BABEL_TYPES_8_BREAKING) return (0, c.assertNodeType)("VariableDeclaration", "LVal");
          const e3 = (0, c.assertNodeType)("VariableDeclaration"), t3 = (0, c.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression");
          return function(n3, r3, s2) {
            (0, i.default)("VariableDeclaration", s2) ? e3(n3, r3, s2) : t3(n3, r3, s2);
          };
        }() }, right: { validate: (0, c.assertNodeType)("Expression") }, body: { validate: (0, c.assertNodeType)("Statement") }, await: { default: false } } }), u("ImportDeclaration", { builder: ["specifiers", "source"], visitor: ["specifiers", "source", "attributes", "assertions"], aliases: ["Statement", "Declaration", "ImportOrExportDeclaration"], fields: { attributes: { optional: true, validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("ImportAttribute"))) }, assertions: { optional: true, validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("ImportAttribute"))) }, module: { optional: true, validate: (0, c.assertValueType)("boolean") }, specifiers: { validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier"))) }, source: { validate: (0, c.assertNodeType)("StringLiteral") }, importKind: { validate: (0, c.assertOneOf)("type", "typeof", "value"), optional: true } } }), u("ImportDefaultSpecifier", { visitor: ["local"], aliases: ["ModuleSpecifier"], fields: { local: { validate: (0, c.assertNodeType)("Identifier") } } }), u("ImportNamespaceSpecifier", { visitor: ["local"], aliases: ["ModuleSpecifier"], fields: { local: { validate: (0, c.assertNodeType)("Identifier") } } }), u("ImportSpecifier", { visitor: ["local", "imported"], aliases: ["ModuleSpecifier"], fields: { local: { validate: (0, c.assertNodeType)("Identifier") }, imported: { validate: (0, c.assertNodeType)("Identifier", "StringLiteral") }, importKind: { validate: (0, c.assertOneOf)("type", "typeof", "value"), optional: true } } }), u("MetaProperty", { visitor: ["meta", "property"], aliases: ["Expression"], fields: { meta: { validate: (0, c.chain)((0, c.assertNodeType)("Identifier"), Object.assign(function(e3, t3, n3) {
          if (!r2.env.BABEL_TYPES_8_BREAKING) return;
          let s2;
          switch (n3.name) {
            case "function":
              s2 = "sent";
              break;
            case "new":
              s2 = "target";
              break;
            case "import":
              s2 = "meta";
          }
          if (!(0, i.default)("Identifier", e3.property, { name: s2 })) throw new TypeError("Unrecognised MetaProperty");
        }, { oneOfNodeTypes: ["Identifier"] })) }, property: { validate: (0, c.assertNodeType)("Identifier") } } });
        const y = () => ({ abstract: { validate: (0, c.assertValueType)("boolean"), optional: true }, accessibility: { validate: (0, c.assertOneOf)("public", "private", "protected"), optional: true }, static: { default: false }, override: { default: false }, computed: { default: false }, optional: { validate: (0, c.assertValueType)("boolean"), optional: true }, key: { validate: (0, c.chain)(function() {
          const e3 = (0, c.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral"), t3 = (0, c.assertNodeType)("Expression");
          return function(n3, r3, i2) {
            (n3.computed ? t3 : e3)(n3, r3, i2);
          };
        }(), (0, c.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression")) } });
        t2.classMethodOrPropertyCommon = y;
        const m = () => Object.assign({}, p(), y(), { params: { validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("Identifier", "Pattern", "RestElement", "TSParameterProperty"))) }, kind: { validate: (0, c.assertOneOf)("get", "set", "method", "constructor"), default: "method" }, access: { validate: (0, c.chain)((0, c.assertValueType)("string"), (0, c.assertOneOf)("public", "private", "protected")), optional: true }, decorators: { validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("Decorator"))), optional: true } });
        t2.classMethodOrDeclareMethodCommon = m, u("ClassMethod", { aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"], builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"], visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"], fields: Object.assign({}, m(), h(), { body: { validate: (0, c.assertNodeType)("BlockStatement") } }) }), u("ObjectPattern", { visitor: ["properties", "typeAnnotation", "decorators"], builder: ["properties"], aliases: ["Pattern", "PatternLike", "LVal"], fields: Object.assign({}, f(), { properties: { validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("RestElement", "ObjectProperty"))) } }) }), u("SpreadElement", { visitor: ["argument"], aliases: ["UnaryLike"], deprecatedAlias: "SpreadProperty", fields: { argument: { validate: (0, c.assertNodeType)("Expression") } } }), u("Super", { aliases: ["Expression"] }), u("TaggedTemplateExpression", { visitor: ["tag", "quasi", "typeParameters"], builder: ["tag", "quasi"], aliases: ["Expression"], fields: { tag: { validate: (0, c.assertNodeType)("Expression") }, quasi: { validate: (0, c.assertNodeType)("TemplateLiteral") }, typeParameters: { validate: (0, c.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"), optional: true } } }), u("TemplateElement", { builder: ["value", "tail"], fields: { value: { validate: (0, c.chain)((0, c.assertShape)({ raw: { validate: (0, c.assertValueType)("string") }, cooked: { validate: (0, c.assertValueType)("string"), optional: true } }), function(e3) {
          const t3 = e3.value.raw;
          let n3 = false;
          const r3 = () => {
            throw new Error("Internal @babel/types error.");
          }, { str: i2, firstInvalidLoc: s2 } = (0, o.readStringContents)("template", t3, 0, 0, 0, { unterminated() {
            n3 = true;
          }, strictNumericEscape: r3, invalidEscapeSequence: r3, numericSeparatorInEscapeSequence: r3, unexpectedNumericSeparator: r3, invalidDigit: r3, invalidCodePoint: r3 });
          if (!n3) throw new Error("Invalid raw");
          e3.value.cooked = s2 ? null : i2;
        }) }, tail: { default: false } } }), u("TemplateLiteral", { visitor: ["quasis", "expressions"], aliases: ["Expression", "Literal"], fields: { quasis: { validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("TemplateElement"))) }, expressions: { validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("Expression", "TSType")), function(e3, t3, n3) {
          if (e3.quasis.length !== n3.length + 1) throw new TypeError(`Number of ${e3.type} quasis should be exactly one more than the number of expressions.
Expected ${n3.length + 1} quasis but got ${e3.quasis.length}`);
        }) } } }), u("YieldExpression", { builder: ["argument", "delegate"], visitor: ["argument"], aliases: ["Expression", "Terminatorless"], fields: { delegate: { validate: (0, c.chain)((0, c.assertValueType)("boolean"), Object.assign(function(e3, t3, n3) {
          if (r2.env.BABEL_TYPES_8_BREAKING && n3 && !e3.argument) throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
        }, { type: "boolean" })), default: false }, argument: { optional: true, validate: (0, c.assertNodeType)("Expression") } } }), u("AwaitExpression", { builder: ["argument"], visitor: ["argument"], aliases: ["Expression", "Terminatorless"], fields: { argument: { validate: (0, c.assertNodeType)("Expression") } } }), u("Import", { aliases: ["Expression"] }), u("BigIntLiteral", { builder: ["value"], fields: { value: { validate: (0, c.assertValueType)("string") } }, aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), u("ExportNamespaceSpecifier", { visitor: ["exported"], aliases: ["ModuleSpecifier"], fields: { exported: { validate: (0, c.assertNodeType)("Identifier") } } }), u("OptionalMemberExpression", { builder: ["object", "property", "computed", "optional"], visitor: ["object", "property"], aliases: ["Expression"], fields: { object: { validate: (0, c.assertNodeType)("Expression") }, property: { validate: function() {
          const e3 = (0, c.assertNodeType)("Identifier"), t3 = (0, c.assertNodeType)("Expression");
          return Object.assign(function(n3, r3, i2) {
            (n3.computed ? t3 : e3)(n3, r3, i2);
          }, { oneOfNodeTypes: ["Expression", "Identifier"] });
        }() }, computed: { default: false }, optional: { validate: r2.env.BABEL_TYPES_8_BREAKING ? (0, c.chain)((0, c.assertValueType)("boolean"), (0, c.assertOptionalChainStart)()) : (0, c.assertValueType)("boolean") } } }), u("OptionalCallExpression", { visitor: ["callee", "arguments", "typeParameters", "typeArguments"], builder: ["callee", "arguments", "optional"], aliases: ["Expression"], fields: { callee: { validate: (0, c.assertNodeType)("Expression") }, arguments: { validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder"))) }, optional: { validate: r2.env.BABEL_TYPES_8_BREAKING ? (0, c.chain)((0, c.assertValueType)("boolean"), (0, c.assertOptionalChainStart)()) : (0, c.assertValueType)("boolean") }, typeArguments: { validate: (0, c.assertNodeType)("TypeParameterInstantiation"), optional: true }, typeParameters: { validate: (0, c.assertNodeType)("TSTypeParameterInstantiation"), optional: true } } }), u("ClassProperty", { visitor: ["key", "value", "typeAnnotation", "decorators"], builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"], aliases: ["Property"], fields: Object.assign({}, y(), { value: { validate: (0, c.assertNodeType)("Expression"), optional: true }, definite: { validate: (0, c.assertValueType)("boolean"), optional: true }, typeAnnotation: { validate: (0, c.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"), optional: true }, decorators: { validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("Decorator"))), optional: true }, readonly: { validate: (0, c.assertValueType)("boolean"), optional: true }, declare: { validate: (0, c.assertValueType)("boolean"), optional: true }, variance: { validate: (0, c.assertNodeType)("Variance"), optional: true } }) }), u("ClassAccessorProperty", { visitor: ["key", "value", "typeAnnotation", "decorators"], builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"], aliases: ["Property", "Accessor"], fields: Object.assign({}, y(), { key: { validate: (0, c.chain)(function() {
          const e3 = (0, c.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName"), t3 = (0, c.assertNodeType)("Expression");
          return function(n3, r3, i2) {
            (n3.computed ? t3 : e3)(n3, r3, i2);
          };
        }(), (0, c.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName")) }, value: { validate: (0, c.assertNodeType)("Expression"), optional: true }, definite: { validate: (0, c.assertValueType)("boolean"), optional: true }, typeAnnotation: { validate: (0, c.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"), optional: true }, decorators: { validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("Decorator"))), optional: true }, readonly: { validate: (0, c.assertValueType)("boolean"), optional: true }, declare: { validate: (0, c.assertValueType)("boolean"), optional: true }, variance: { validate: (0, c.assertNodeType)("Variance"), optional: true } }) }), u("ClassPrivateProperty", { visitor: ["key", "value", "decorators", "typeAnnotation"], builder: ["key", "value", "decorators", "static"], aliases: ["Property", "Private"], fields: { key: { validate: (0, c.assertNodeType)("PrivateName") }, value: { validate: (0, c.assertNodeType)("Expression"), optional: true }, typeAnnotation: { validate: (0, c.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"), optional: true }, decorators: { validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("Decorator"))), optional: true }, static: { validate: (0, c.assertValueType)("boolean"), default: false }, readonly: { validate: (0, c.assertValueType)("boolean"), optional: true }, definite: { validate: (0, c.assertValueType)("boolean"), optional: true }, variance: { validate: (0, c.assertNodeType)("Variance"), optional: true } } }), u("ClassPrivateMethod", { builder: ["kind", "key", "params", "body", "static"], visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"], aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"], fields: Object.assign({}, m(), h(), { kind: { validate: (0, c.assertOneOf)("get", "set", "method"), default: "method" }, key: { validate: (0, c.assertNodeType)("PrivateName") }, body: { validate: (0, c.assertNodeType)("BlockStatement") } }) }), u("PrivateName", { visitor: ["id"], aliases: ["Private"], fields: { id: { validate: (0, c.assertNodeType)("Identifier") } } }), u("StaticBlock", { visitor: ["body"], fields: { body: { validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("Statement"))) } }, aliases: ["Scopable", "BlockParent", "FunctionParent"] });
      }, 6937: (e2, t2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.DEPRECATED_ALIASES = void 0, t2.DEPRECATED_ALIASES = { ModuleDeclaration: "ImportOrExportDeclaration" };
      }, 1190: (e2, t2, n2) => {
        "use strict";
        var r2 = n2(4155), i = n2(1514);
        (0, i.default)("ArgumentPlaceholder", {}), (0, i.default)("BindExpression", { visitor: ["object", "callee"], aliases: ["Expression"], fields: r2.env.BABEL_TYPES_8_BREAKING ? { object: { validate: (0, i.assertNodeType)("Expression") }, callee: { validate: (0, i.assertNodeType)("Expression") } } : { object: { validate: Object.assign(() => {
        }, { oneOfNodeTypes: ["Expression"] }) }, callee: { validate: Object.assign(() => {
        }, { oneOfNodeTypes: ["Expression"] }) } } }), (0, i.default)("ImportAttribute", { visitor: ["key", "value"], fields: { key: { validate: (0, i.assertNodeType)("Identifier", "StringLiteral") }, value: { validate: (0, i.assertNodeType)("StringLiteral") } } }), (0, i.default)("Decorator", { visitor: ["expression"], fields: { expression: { validate: (0, i.assertNodeType)("Expression") } } }), (0, i.default)("DoExpression", { visitor: ["body"], builder: ["body", "async"], aliases: ["Expression"], fields: { body: { validate: (0, i.assertNodeType)("BlockStatement") }, async: { validate: (0, i.assertValueType)("boolean"), default: false } } }), (0, i.default)("ExportDefaultSpecifier", { visitor: ["exported"], aliases: ["ModuleSpecifier"], fields: { exported: { validate: (0, i.assertNodeType)("Identifier") } } }), (0, i.default)("RecordExpression", { visitor: ["properties"], aliases: ["Expression"], fields: { properties: { validate: (0, i.chain)((0, i.assertValueType)("array"), (0, i.assertEach)((0, i.assertNodeType)("ObjectProperty", "SpreadElement"))) } } }), (0, i.default)("TupleExpression", { fields: { elements: { validate: (0, i.chain)((0, i.assertValueType)("array"), (0, i.assertEach)((0, i.assertNodeType)("Expression", "SpreadElement"))), default: [] } }, visitor: ["elements"], aliases: ["Expression"] }), (0, i.default)("DecimalLiteral", { builder: ["value"], fields: { value: { validate: (0, i.assertValueType)("string") } }, aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), (0, i.default)("ModuleExpression", { visitor: ["body"], fields: { body: { validate: (0, i.assertNodeType)("Program") } }, aliases: ["Expression"] }), (0, i.default)("TopicReference", { aliases: ["Expression"] }), (0, i.default)("PipelineTopicExpression", { builder: ["expression"], visitor: ["expression"], fields: { expression: { validate: (0, i.assertNodeType)("Expression") } }, aliases: ["Expression"] }), (0, i.default)("PipelineBareFunction", { builder: ["callee"], visitor: ["callee"], fields: { callee: { validate: (0, i.assertNodeType)("Expression") } }, aliases: ["Expression"] }), (0, i.default)("PipelinePrimaryTopicReference", { aliases: ["Expression"] });
      }, 3940: (e2, t2, n2) => {
        "use strict";
        var r2 = n2(1514);
        const i = (0, r2.defineAliasedType)("Flow"), s = (e3) => {
          const t3 = "DeclareClass" === e3;
          i(e3, { builder: ["id", "typeParameters", "extends", "body"], visitor: ["id", "typeParameters", "extends", ...t3 ? ["mixins", "implements"] : [], "body"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: Object.assign({ id: (0, r2.validateType)("Identifier"), typeParameters: (0, r2.validateOptionalType)("TypeParameterDeclaration"), extends: (0, r2.validateOptional)((0, r2.arrayOfType)("InterfaceExtends")) }, t3 ? { mixins: (0, r2.validateOptional)((0, r2.arrayOfType)("InterfaceExtends")), implements: (0, r2.validateOptional)((0, r2.arrayOfType)("ClassImplements")) } : {}, { body: (0, r2.validateType)("ObjectTypeAnnotation") }) });
        };
        i("AnyTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), i("ArrayTypeAnnotation", { visitor: ["elementType"], aliases: ["FlowType"], fields: { elementType: (0, r2.validateType)("FlowType") } }), i("BooleanTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), i("BooleanLiteralTypeAnnotation", { builder: ["value"], aliases: ["FlowType"], fields: { value: (0, r2.validate)((0, r2.assertValueType)("boolean")) } }), i("NullLiteralTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), i("ClassImplements", { visitor: ["id", "typeParameters"], fields: { id: (0, r2.validateType)("Identifier"), typeParameters: (0, r2.validateOptionalType)("TypeParameterInstantiation") } }), s("DeclareClass"), i("DeclareFunction", { visitor: ["id"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, r2.validateType)("Identifier"), predicate: (0, r2.validateOptionalType)("DeclaredPredicate") } }), s("DeclareInterface"), i("DeclareModule", { builder: ["id", "body", "kind"], visitor: ["id", "body"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, r2.validateType)(["Identifier", "StringLiteral"]), body: (0, r2.validateType)("BlockStatement"), kind: (0, r2.validateOptional)((0, r2.assertOneOf)("CommonJS", "ES")) } }), i("DeclareModuleExports", { visitor: ["typeAnnotation"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { typeAnnotation: (0, r2.validateType)("TypeAnnotation") } }), i("DeclareTypeAlias", { visitor: ["id", "typeParameters", "right"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, r2.validateType)("Identifier"), typeParameters: (0, r2.validateOptionalType)("TypeParameterDeclaration"), right: (0, r2.validateType)("FlowType") } }), i("DeclareOpaqueType", { visitor: ["id", "typeParameters", "supertype"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, r2.validateType)("Identifier"), typeParameters: (0, r2.validateOptionalType)("TypeParameterDeclaration"), supertype: (0, r2.validateOptionalType)("FlowType"), impltype: (0, r2.validateOptionalType)("FlowType") } }), i("DeclareVariable", { visitor: ["id"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, r2.validateType)("Identifier") } }), i("DeclareExportDeclaration", { visitor: ["declaration", "specifiers", "source"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { declaration: (0, r2.validateOptionalType)("Flow"), specifiers: (0, r2.validateOptional)((0, r2.arrayOfType)(["ExportSpecifier", "ExportNamespaceSpecifier"])), source: (0, r2.validateOptionalType)("StringLiteral"), default: (0, r2.validateOptional)((0, r2.assertValueType)("boolean")) } }), i("DeclareExportAllDeclaration", { visitor: ["source"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { source: (0, r2.validateType)("StringLiteral"), exportKind: (0, r2.validateOptional)((0, r2.assertOneOf)("type", "value")) } }), i("DeclaredPredicate", { visitor: ["value"], aliases: ["FlowPredicate"], fields: { value: (0, r2.validateType)("Flow") } }), i("ExistsTypeAnnotation", { aliases: ["FlowType"] }), i("FunctionTypeAnnotation", { visitor: ["typeParameters", "params", "rest", "returnType"], aliases: ["FlowType"], fields: { typeParameters: (0, r2.validateOptionalType)("TypeParameterDeclaration"), params: (0, r2.validate)((0, r2.arrayOfType)("FunctionTypeParam")), rest: (0, r2.validateOptionalType)("FunctionTypeParam"), this: (0, r2.validateOptionalType)("FunctionTypeParam"), returnType: (0, r2.validateType)("FlowType") } }), i("FunctionTypeParam", { visitor: ["name", "typeAnnotation"], fields: { name: (0, r2.validateOptionalType)("Identifier"), typeAnnotation: (0, r2.validateType)("FlowType"), optional: (0, r2.validateOptional)((0, r2.assertValueType)("boolean")) } }), i("GenericTypeAnnotation", { visitor: ["id", "typeParameters"], aliases: ["FlowType"], fields: { id: (0, r2.validateType)(["Identifier", "QualifiedTypeIdentifier"]), typeParameters: (0, r2.validateOptionalType)("TypeParameterInstantiation") } }), i("InferredPredicate", { aliases: ["FlowPredicate"] }), i("InterfaceExtends", { visitor: ["id", "typeParameters"], fields: { id: (0, r2.validateType)(["Identifier", "QualifiedTypeIdentifier"]), typeParameters: (0, r2.validateOptionalType)("TypeParameterInstantiation") } }), s("InterfaceDeclaration"), i("InterfaceTypeAnnotation", { visitor: ["extends", "body"], aliases: ["FlowType"], fields: { extends: (0, r2.validateOptional)((0, r2.arrayOfType)("InterfaceExtends")), body: (0, r2.validateType)("ObjectTypeAnnotation") } }), i("IntersectionTypeAnnotation", { visitor: ["types"], aliases: ["FlowType"], fields: { types: (0, r2.validate)((0, r2.arrayOfType)("FlowType")) } }), i("MixedTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), i("EmptyTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), i("NullableTypeAnnotation", { visitor: ["typeAnnotation"], aliases: ["FlowType"], fields: { typeAnnotation: (0, r2.validateType)("FlowType") } }), i("NumberLiteralTypeAnnotation", { builder: ["value"], aliases: ["FlowType"], fields: { value: (0, r2.validate)((0, r2.assertValueType)("number")) } }), i("NumberTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), i("ObjectTypeAnnotation", { visitor: ["properties", "indexers", "callProperties", "internalSlots"], aliases: ["FlowType"], builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"], fields: { properties: (0, r2.validate)((0, r2.arrayOfType)(["ObjectTypeProperty", "ObjectTypeSpreadProperty"])), indexers: { validate: (0, r2.arrayOfType)("ObjectTypeIndexer"), optional: true, default: [] }, callProperties: { validate: (0, r2.arrayOfType)("ObjectTypeCallProperty"), optional: true, default: [] }, internalSlots: { validate: (0, r2.arrayOfType)("ObjectTypeInternalSlot"), optional: true, default: [] }, exact: { validate: (0, r2.assertValueType)("boolean"), default: false }, inexact: (0, r2.validateOptional)((0, r2.assertValueType)("boolean")) } }), i("ObjectTypeInternalSlot", { visitor: ["id", "value", "optional", "static", "method"], aliases: ["UserWhitespacable"], fields: { id: (0, r2.validateType)("Identifier"), value: (0, r2.validateType)("FlowType"), optional: (0, r2.validate)((0, r2.assertValueType)("boolean")), static: (0, r2.validate)((0, r2.assertValueType)("boolean")), method: (0, r2.validate)((0, r2.assertValueType)("boolean")) } }), i("ObjectTypeCallProperty", { visitor: ["value"], aliases: ["UserWhitespacable"], fields: { value: (0, r2.validateType)("FlowType"), static: (0, r2.validate)((0, r2.assertValueType)("boolean")) } }), i("ObjectTypeIndexer", { visitor: ["id", "key", "value", "variance"], aliases: ["UserWhitespacable"], fields: { id: (0, r2.validateOptionalType)("Identifier"), key: (0, r2.validateType)("FlowType"), value: (0, r2.validateType)("FlowType"), static: (0, r2.validate)((0, r2.assertValueType)("boolean")), variance: (0, r2.validateOptionalType)("Variance") } }), i("ObjectTypeProperty", { visitor: ["key", "value", "variance"], aliases: ["UserWhitespacable"], fields: { key: (0, r2.validateType)(["Identifier", "StringLiteral"]), value: (0, r2.validateType)("FlowType"), kind: (0, r2.validate)((0, r2.assertOneOf)("init", "get", "set")), static: (0, r2.validate)((0, r2.assertValueType)("boolean")), proto: (0, r2.validate)((0, r2.assertValueType)("boolean")), optional: (0, r2.validate)((0, r2.assertValueType)("boolean")), variance: (0, r2.validateOptionalType)("Variance"), method: (0, r2.validate)((0, r2.assertValueType)("boolean")) } }), i("ObjectTypeSpreadProperty", { visitor: ["argument"], aliases: ["UserWhitespacable"], fields: { argument: (0, r2.validateType)("FlowType") } }), i("OpaqueType", { visitor: ["id", "typeParameters", "supertype", "impltype"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, r2.validateType)("Identifier"), typeParameters: (0, r2.validateOptionalType)("TypeParameterDeclaration"), supertype: (0, r2.validateOptionalType)("FlowType"), impltype: (0, r2.validateType)("FlowType") } }), i("QualifiedTypeIdentifier", { visitor: ["id", "qualification"], fields: { id: (0, r2.validateType)("Identifier"), qualification: (0, r2.validateType)(["Identifier", "QualifiedTypeIdentifier"]) } }), i("StringLiteralTypeAnnotation", { builder: ["value"], aliases: ["FlowType"], fields: { value: (0, r2.validate)((0, r2.assertValueType)("string")) } }), i("StringTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), i("SymbolTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), i("ThisTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), i("TupleTypeAnnotation", { visitor: ["types"], aliases: ["FlowType"], fields: { types: (0, r2.validate)((0, r2.arrayOfType)("FlowType")) } }), i("TypeofTypeAnnotation", { visitor: ["argument"], aliases: ["FlowType"], fields: { argument: (0, r2.validateType)("FlowType") } }), i("TypeAlias", { visitor: ["id", "typeParameters", "right"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, r2.validateType)("Identifier"), typeParameters: (0, r2.validateOptionalType)("TypeParameterDeclaration"), right: (0, r2.validateType)("FlowType") } }), i("TypeAnnotation", { visitor: ["typeAnnotation"], fields: { typeAnnotation: (0, r2.validateType)("FlowType") } }), i("TypeCastExpression", { visitor: ["expression", "typeAnnotation"], aliases: ["ExpressionWrapper", "Expression"], fields: { expression: (0, r2.validateType)("Expression"), typeAnnotation: (0, r2.validateType)("TypeAnnotation") } }), i("TypeParameter", { visitor: ["bound", "default", "variance"], fields: { name: (0, r2.validate)((0, r2.assertValueType)("string")), bound: (0, r2.validateOptionalType)("TypeAnnotation"), default: (0, r2.validateOptionalType)("FlowType"), variance: (0, r2.validateOptionalType)("Variance") } }), i("TypeParameterDeclaration", { visitor: ["params"], fields: { params: (0, r2.validate)((0, r2.arrayOfType)("TypeParameter")) } }), i("TypeParameterInstantiation", { visitor: ["params"], fields: { params: (0, r2.validate)((0, r2.arrayOfType)("FlowType")) } }), i("UnionTypeAnnotation", { visitor: ["types"], aliases: ["FlowType"], fields: { types: (0, r2.validate)((0, r2.arrayOfType)("FlowType")) } }), i("Variance", { builder: ["kind"], fields: { kind: (0, r2.validate)((0, r2.assertOneOf)("minus", "plus")) } }), i("VoidTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), i("EnumDeclaration", { aliases: ["Statement", "Declaration"], visitor: ["id", "body"], fields: { id: (0, r2.validateType)("Identifier"), body: (0, r2.validateType)(["EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody"]) } }), i("EnumBooleanBody", { aliases: ["EnumBody"], visitor: ["members"], fields: { explicitType: (0, r2.validate)((0, r2.assertValueType)("boolean")), members: (0, r2.validateArrayOfType)("EnumBooleanMember"), hasUnknownMembers: (0, r2.validate)((0, r2.assertValueType)("boolean")) } }), i("EnumNumberBody", { aliases: ["EnumBody"], visitor: ["members"], fields: { explicitType: (0, r2.validate)((0, r2.assertValueType)("boolean")), members: (0, r2.validateArrayOfType)("EnumNumberMember"), hasUnknownMembers: (0, r2.validate)((0, r2.assertValueType)("boolean")) } }), i("EnumStringBody", { aliases: ["EnumBody"], visitor: ["members"], fields: { explicitType: (0, r2.validate)((0, r2.assertValueType)("boolean")), members: (0, r2.validateArrayOfType)(["EnumStringMember", "EnumDefaultedMember"]), hasUnknownMembers: (0, r2.validate)((0, r2.assertValueType)("boolean")) } }), i("EnumSymbolBody", { aliases: ["EnumBody"], visitor: ["members"], fields: { members: (0, r2.validateArrayOfType)("EnumDefaultedMember"), hasUnknownMembers: (0, r2.validate)((0, r2.assertValueType)("boolean")) } }), i("EnumBooleanMember", { aliases: ["EnumMember"], visitor: ["id"], fields: { id: (0, r2.validateType)("Identifier"), init: (0, r2.validateType)("BooleanLiteral") } }), i("EnumNumberMember", { aliases: ["EnumMember"], visitor: ["id", "init"], fields: { id: (0, r2.validateType)("Identifier"), init: (0, r2.validateType)("NumericLiteral") } }), i("EnumStringMember", { aliases: ["EnumMember"], visitor: ["id", "init"], fields: { id: (0, r2.validateType)("Identifier"), init: (0, r2.validateType)("StringLiteral") } }), i("EnumDefaultedMember", { aliases: ["EnumMember"], visitor: ["id"], fields: { id: (0, r2.validateType)("Identifier") } }), i("IndexedAccessType", { visitor: ["objectType", "indexType"], aliases: ["FlowType"], fields: { objectType: (0, r2.validateType)("FlowType"), indexType: (0, r2.validateType)("FlowType") } }), i("OptionalIndexedAccessType", { visitor: ["objectType", "indexType"], aliases: ["FlowType"], fields: { objectType: (0, r2.validateType)("FlowType"), indexType: (0, r2.validateType)("FlowType"), optional: (0, r2.validate)((0, r2.assertValueType)("boolean")) } });
      }, 1678: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), Object.defineProperty(t2, "ALIAS_KEYS", { enumerable: true, get: function() {
          return i.ALIAS_KEYS;
        } }), Object.defineProperty(t2, "BUILDER_KEYS", { enumerable: true, get: function() {
          return i.BUILDER_KEYS;
        } }), Object.defineProperty(t2, "DEPRECATED_ALIASES", { enumerable: true, get: function() {
          return a.DEPRECATED_ALIASES;
        } }), Object.defineProperty(t2, "DEPRECATED_KEYS", { enumerable: true, get: function() {
          return i.DEPRECATED_KEYS;
        } }), Object.defineProperty(t2, "FLIPPED_ALIAS_KEYS", { enumerable: true, get: function() {
          return i.FLIPPED_ALIAS_KEYS;
        } }), Object.defineProperty(t2, "NODE_FIELDS", { enumerable: true, get: function() {
          return i.NODE_FIELDS;
        } }), Object.defineProperty(t2, "NODE_PARENT_VALIDATIONS", { enumerable: true, get: function() {
          return i.NODE_PARENT_VALIDATIONS;
        } }), Object.defineProperty(t2, "PLACEHOLDERS", { enumerable: true, get: function() {
          return s.PLACEHOLDERS;
        } }), Object.defineProperty(t2, "PLACEHOLDERS_ALIAS", { enumerable: true, get: function() {
          return s.PLACEHOLDERS_ALIAS;
        } }), Object.defineProperty(t2, "PLACEHOLDERS_FLIPPED_ALIAS", { enumerable: true, get: function() {
          return s.PLACEHOLDERS_FLIPPED_ALIAS;
        } }), t2.TYPES = void 0, Object.defineProperty(t2, "VISITOR_KEYS", { enumerable: true, get: function() {
          return i.VISITOR_KEYS;
        } });
        var r2 = n2(3164);
        n2(8248), n2(3940), n2(1410), n2(3858), n2(1190), n2(4);
        var i = n2(1514), s = n2(7389), a = n2(6937);
        Object.keys(a.DEPRECATED_ALIASES).forEach((e3) => {
          i.FLIPPED_ALIAS_KEYS[e3] = i.FLIPPED_ALIAS_KEYS[a.DEPRECATED_ALIASES[e3]];
        }), r2(i.VISITOR_KEYS), r2(i.ALIAS_KEYS), r2(i.FLIPPED_ALIAS_KEYS), r2(i.NODE_FIELDS), r2(i.BUILDER_KEYS), r2(i.DEPRECATED_KEYS), r2(s.PLACEHOLDERS_ALIAS), r2(s.PLACEHOLDERS_FLIPPED_ALIAS);
        const o = [].concat(Object.keys(i.VISITOR_KEYS), Object.keys(i.FLIPPED_ALIAS_KEYS), Object.keys(i.DEPRECATED_KEYS));
        t2.TYPES = o;
      }, 1410: (e2, t2, n2) => {
        "use strict";
        var r2 = n2(1514);
        const i = (0, r2.defineAliasedType)("JSX");
        i("JSXAttribute", { visitor: ["name", "value"], aliases: ["Immutable"], fields: { name: { validate: (0, r2.assertNodeType)("JSXIdentifier", "JSXNamespacedName") }, value: { optional: true, validate: (0, r2.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer") } } }), i("JSXClosingElement", { visitor: ["name"], aliases: ["Immutable"], fields: { name: { validate: (0, r2.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName") } } }), i("JSXElement", { builder: ["openingElement", "closingElement", "children", "selfClosing"], visitor: ["openingElement", "children", "closingElement"], aliases: ["Immutable", "Expression"], fields: Object.assign({ openingElement: { validate: (0, r2.assertNodeType)("JSXOpeningElement") }, closingElement: { optional: true, validate: (0, r2.assertNodeType)("JSXClosingElement") }, children: { validate: (0, r2.chain)((0, r2.assertValueType)("array"), (0, r2.assertEach)((0, r2.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment"))) } }, { selfClosing: { validate: (0, r2.assertValueType)("boolean"), optional: true } }) }), i("JSXEmptyExpression", {}), i("JSXExpressionContainer", { visitor: ["expression"], aliases: ["Immutable"], fields: { expression: { validate: (0, r2.assertNodeType)("Expression", "JSXEmptyExpression") } } }), i("JSXSpreadChild", { visitor: ["expression"], aliases: ["Immutable"], fields: { expression: { validate: (0, r2.assertNodeType)("Expression") } } }), i("JSXIdentifier", { builder: ["name"], fields: { name: { validate: (0, r2.assertValueType)("string") } } }), i("JSXMemberExpression", { visitor: ["object", "property"], fields: { object: { validate: (0, r2.assertNodeType)("JSXMemberExpression", "JSXIdentifier") }, property: { validate: (0, r2.assertNodeType)("JSXIdentifier") } } }), i("JSXNamespacedName", { visitor: ["namespace", "name"], fields: { namespace: { validate: (0, r2.assertNodeType)("JSXIdentifier") }, name: { validate: (0, r2.assertNodeType)("JSXIdentifier") } } }), i("JSXOpeningElement", { builder: ["name", "attributes", "selfClosing"], visitor: ["name", "attributes"], aliases: ["Immutable"], fields: { name: { validate: (0, r2.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName") }, selfClosing: { default: false }, attributes: { validate: (0, r2.chain)((0, r2.assertValueType)("array"), (0, r2.assertEach)((0, r2.assertNodeType)("JSXAttribute", "JSXSpreadAttribute"))) }, typeParameters: { validate: (0, r2.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"), optional: true } } }), i("JSXSpreadAttribute", { visitor: ["argument"], fields: { argument: { validate: (0, r2.assertNodeType)("Expression") } } }), i("JSXText", { aliases: ["Immutable"], builder: ["value"], fields: { value: { validate: (0, r2.assertValueType)("string") } } }), i("JSXFragment", { builder: ["openingFragment", "closingFragment", "children"], visitor: ["openingFragment", "children", "closingFragment"], aliases: ["Immutable", "Expression"], fields: { openingFragment: { validate: (0, r2.assertNodeType)("JSXOpeningFragment") }, closingFragment: { validate: (0, r2.assertNodeType)("JSXClosingFragment") }, children: { validate: (0, r2.chain)((0, r2.assertValueType)("array"), (0, r2.assertEach)((0, r2.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment"))) } } }), i("JSXOpeningFragment", { aliases: ["Immutable"] }), i("JSXClosingFragment", { aliases: ["Immutable"] });
      }, 3858: (e2, t2, n2) => {
        "use strict";
        var r2 = n2(1514), i = n2(7389);
        const s = (0, r2.defineAliasedType)("Miscellaneous");
        s("Noop", { visitor: [] }), s("Placeholder", { visitor: [], builder: ["expectedNode", "name"], fields: { name: { validate: (0, r2.assertNodeType)("Identifier") }, expectedNode: { validate: (0, r2.assertOneOf)(...i.PLACEHOLDERS) } } }), s("V8IntrinsicIdentifier", { builder: ["name"], fields: { name: { validate: (0, r2.assertValueType)("string") } } });
      }, 7389: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.PLACEHOLDERS_FLIPPED_ALIAS = t2.PLACEHOLDERS_ALIAS = t2.PLACEHOLDERS = void 0;
        var r2 = n2(1514);
        const i = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBody", "Pattern"];
        t2.PLACEHOLDERS = i;
        const s = { Declaration: ["Statement"], Pattern: ["PatternLike", "LVal"] };
        t2.PLACEHOLDERS_ALIAS = s;
        for (const e3 of i) {
          const t3 = r2.ALIAS_KEYS[e3];
          null != t3 && t3.length && (s[e3] = t3);
        }
        const a = {};
        t2.PLACEHOLDERS_FLIPPED_ALIAS = a, Object.keys(s).forEach((e3) => {
          s[e3].forEach((t3) => {
            Object.hasOwnProperty.call(a, t3) || (a[t3] = []), a[t3].push(e3);
          });
        });
      }, 4: (e2, t2, n2) => {
        "use strict";
        var r2 = n2(1514), i = n2(8248), s = n2(5171);
        const a = (0, r2.defineAliasedType)("TypeScript"), o = (0, r2.assertValueType)("boolean"), l = () => ({ returnType: { validate: (0, r2.assertNodeType)("TSTypeAnnotation", "Noop"), optional: true }, typeParameters: { validate: (0, r2.assertNodeType)("TSTypeParameterDeclaration", "Noop"), optional: true } });
        a("TSParameterProperty", { aliases: ["LVal"], visitor: ["parameter"], fields: { accessibility: { validate: (0, r2.assertOneOf)("public", "private", "protected"), optional: true }, readonly: { validate: (0, r2.assertValueType)("boolean"), optional: true }, parameter: { validate: (0, r2.assertNodeType)("Identifier", "AssignmentPattern") }, override: { validate: (0, r2.assertValueType)("boolean"), optional: true }, decorators: { validate: (0, r2.chain)((0, r2.assertValueType)("array"), (0, r2.assertEach)((0, r2.assertNodeType)("Decorator"))), optional: true } } }), a("TSDeclareFunction", { aliases: ["Statement", "Declaration"], visitor: ["id", "typeParameters", "params", "returnType"], fields: Object.assign({}, (0, i.functionDeclarationCommon)(), l()) }), a("TSDeclareMethod", { visitor: ["decorators", "key", "typeParameters", "params", "returnType"], fields: Object.assign({}, (0, i.classMethodOrDeclareMethodCommon)(), l()) }), a("TSQualifiedName", { aliases: ["TSEntityName"], visitor: ["left", "right"], fields: { left: (0, r2.validateType)("TSEntityName"), right: (0, r2.validateType)("Identifier") } });
        const c = () => ({ typeParameters: (0, r2.validateOptionalType)("TSTypeParameterDeclaration"), parameters: (0, r2.validateArrayOfType)(["ArrayPattern", "Identifier", "ObjectPattern", "RestElement"]), typeAnnotation: (0, r2.validateOptionalType)("TSTypeAnnotation") }), u = { aliases: ["TSTypeElement"], visitor: ["typeParameters", "parameters", "typeAnnotation"], fields: c() };
        a("TSCallSignatureDeclaration", u), a("TSConstructSignatureDeclaration", u);
        const p = () => ({ key: (0, r2.validateType)("Expression"), computed: { default: false }, optional: (0, r2.validateOptional)(o) });
        a("TSPropertySignature", { aliases: ["TSTypeElement"], visitor: ["key", "typeAnnotation", "initializer"], fields: Object.assign({}, p(), { readonly: (0, r2.validateOptional)(o), typeAnnotation: (0, r2.validateOptionalType)("TSTypeAnnotation"), initializer: (0, r2.validateOptionalType)("Expression"), kind: { validate: (0, r2.assertOneOf)("get", "set") } }) }), a("TSMethodSignature", { aliases: ["TSTypeElement"], visitor: ["key", "typeParameters", "parameters", "typeAnnotation"], fields: Object.assign({}, c(), p(), { kind: { validate: (0, r2.assertOneOf)("method", "get", "set") } }) }), a("TSIndexSignature", { aliases: ["TSTypeElement"], visitor: ["parameters", "typeAnnotation"], fields: { readonly: (0, r2.validateOptional)(o), static: (0, r2.validateOptional)(o), parameters: (0, r2.validateArrayOfType)("Identifier"), typeAnnotation: (0, r2.validateOptionalType)("TSTypeAnnotation") } });
        const h = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];
        for (const e3 of h) a(e3, { aliases: ["TSType", "TSBaseType"], visitor: [], fields: {} });
        a("TSThisType", { aliases: ["TSType", "TSBaseType"], visitor: [], fields: {} });
        const d = { aliases: ["TSType"], visitor: ["typeParameters", "parameters", "typeAnnotation"] };
        a("TSFunctionType", Object.assign({}, d, { fields: c() })), a("TSConstructorType", Object.assign({}, d, { fields: Object.assign({}, c(), { abstract: (0, r2.validateOptional)(o) }) })), a("TSTypeReference", { aliases: ["TSType"], visitor: ["typeName", "typeParameters"], fields: { typeName: (0, r2.validateType)("TSEntityName"), typeParameters: (0, r2.validateOptionalType)("TSTypeParameterInstantiation") } }), a("TSTypePredicate", { aliases: ["TSType"], visitor: ["parameterName", "typeAnnotation"], builder: ["parameterName", "typeAnnotation", "asserts"], fields: { parameterName: (0, r2.validateType)(["Identifier", "TSThisType"]), typeAnnotation: (0, r2.validateOptionalType)("TSTypeAnnotation"), asserts: (0, r2.validateOptional)(o) } }), a("TSTypeQuery", { aliases: ["TSType"], visitor: ["exprName", "typeParameters"], fields: { exprName: (0, r2.validateType)(["TSEntityName", "TSImportType"]), typeParameters: (0, r2.validateOptionalType)("TSTypeParameterInstantiation") } }), a("TSTypeLiteral", { aliases: ["TSType"], visitor: ["members"], fields: { members: (0, r2.validateArrayOfType)("TSTypeElement") } }), a("TSArrayType", { aliases: ["TSType"], visitor: ["elementType"], fields: { elementType: (0, r2.validateType)("TSType") } }), a("TSTupleType", { aliases: ["TSType"], visitor: ["elementTypes"], fields: { elementTypes: (0, r2.validateArrayOfType)(["TSType", "TSNamedTupleMember"]) } }), a("TSOptionalType", { aliases: ["TSType"], visitor: ["typeAnnotation"], fields: { typeAnnotation: (0, r2.validateType)("TSType") } }), a("TSRestType", { aliases: ["TSType"], visitor: ["typeAnnotation"], fields: { typeAnnotation: (0, r2.validateType)("TSType") } }), a("TSNamedTupleMember", { visitor: ["label", "elementType"], builder: ["label", "elementType", "optional"], fields: { label: (0, r2.validateType)("Identifier"), optional: { validate: o, default: false }, elementType: (0, r2.validateType)("TSType") } });
        const f = { aliases: ["TSType"], visitor: ["types"], fields: { types: (0, r2.validateArrayOfType)("TSType") } };
        a("TSUnionType", f), a("TSIntersectionType", f), a("TSConditionalType", { aliases: ["TSType"], visitor: ["checkType", "extendsType", "trueType", "falseType"], fields: { checkType: (0, r2.validateType)("TSType"), extendsType: (0, r2.validateType)("TSType"), trueType: (0, r2.validateType)("TSType"), falseType: (0, r2.validateType)("TSType") } }), a("TSInferType", { aliases: ["TSType"], visitor: ["typeParameter"], fields: { typeParameter: (0, r2.validateType)("TSTypeParameter") } }), a("TSParenthesizedType", { aliases: ["TSType"], visitor: ["typeAnnotation"], fields: { typeAnnotation: (0, r2.validateType)("TSType") } }), a("TSTypeOperator", { aliases: ["TSType"], visitor: ["typeAnnotation"], fields: { operator: (0, r2.validate)((0, r2.assertValueType)("string")), typeAnnotation: (0, r2.validateType)("TSType") } }), a("TSIndexedAccessType", { aliases: ["TSType"], visitor: ["objectType", "indexType"], fields: { objectType: (0, r2.validateType)("TSType"), indexType: (0, r2.validateType)("TSType") } }), a("TSMappedType", { aliases: ["TSType"], visitor: ["typeParameter", "typeAnnotation", "nameType"], fields: { readonly: (0, r2.validateOptional)((0, r2.assertOneOf)(true, false, "+", "-")), typeParameter: (0, r2.validateType)("TSTypeParameter"), optional: (0, r2.validateOptional)((0, r2.assertOneOf)(true, false, "+", "-")), typeAnnotation: (0, r2.validateOptionalType)("TSType"), nameType: (0, r2.validateOptionalType)("TSType") } }), a("TSLiteralType", { aliases: ["TSType", "TSBaseType"], visitor: ["literal"], fields: { literal: { validate: function() {
          const e3 = (0, r2.assertNodeType)("NumericLiteral", "BigIntLiteral"), t3 = (0, r2.assertOneOf)("-"), n3 = (0, r2.assertNodeType)("NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral");
          function i2(r3, i3, a2) {
            (0, s.default)("UnaryExpression", a2) ? (t3(a2, "operator", a2.operator), e3(a2, "argument", a2.argument)) : n3(r3, i3, a2);
          }
          return i2.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral", "UnaryExpression"], i2;
        }() } } }), a("TSExpressionWithTypeArguments", { aliases: ["TSType"], visitor: ["expression", "typeParameters"], fields: { expression: (0, r2.validateType)("TSEntityName"), typeParameters: (0, r2.validateOptionalType)("TSTypeParameterInstantiation") } }), a("TSInterfaceDeclaration", { aliases: ["Statement", "Declaration"], visitor: ["id", "typeParameters", "extends", "body"], fields: { declare: (0, r2.validateOptional)(o), id: (0, r2.validateType)("Identifier"), typeParameters: (0, r2.validateOptionalType)("TSTypeParameterDeclaration"), extends: (0, r2.validateOptional)((0, r2.arrayOfType)("TSExpressionWithTypeArguments")), body: (0, r2.validateType)("TSInterfaceBody") } }), a("TSInterfaceBody", { visitor: ["body"], fields: { body: (0, r2.validateArrayOfType)("TSTypeElement") } }), a("TSTypeAliasDeclaration", { aliases: ["Statement", "Declaration"], visitor: ["id", "typeParameters", "typeAnnotation"], fields: { declare: (0, r2.validateOptional)(o), id: (0, r2.validateType)("Identifier"), typeParameters: (0, r2.validateOptionalType)("TSTypeParameterDeclaration"), typeAnnotation: (0, r2.validateType)("TSType") } }), a("TSInstantiationExpression", { aliases: ["Expression"], visitor: ["expression", "typeParameters"], fields: { expression: (0, r2.validateType)("Expression"), typeParameters: (0, r2.validateOptionalType)("TSTypeParameterInstantiation") } });
        const y = { aliases: ["Expression", "LVal", "PatternLike"], visitor: ["expression", "typeAnnotation"], fields: { expression: (0, r2.validateType)("Expression"), typeAnnotation: (0, r2.validateType)("TSType") } };
        a("TSAsExpression", y), a("TSSatisfiesExpression", y), a("TSTypeAssertion", { aliases: ["Expression", "LVal", "PatternLike"], visitor: ["typeAnnotation", "expression"], fields: { typeAnnotation: (0, r2.validateType)("TSType"), expression: (0, r2.validateType)("Expression") } }), a("TSEnumDeclaration", { aliases: ["Statement", "Declaration"], visitor: ["id", "members"], fields: { declare: (0, r2.validateOptional)(o), const: (0, r2.validateOptional)(o), id: (0, r2.validateType)("Identifier"), members: (0, r2.validateArrayOfType)("TSEnumMember"), initializer: (0, r2.validateOptionalType)("Expression") } }), a("TSEnumMember", { visitor: ["id", "initializer"], fields: { id: (0, r2.validateType)(["Identifier", "StringLiteral"]), initializer: (0, r2.validateOptionalType)("Expression") } }), a("TSModuleDeclaration", { aliases: ["Statement", "Declaration"], visitor: ["id", "body"], fields: { declare: (0, r2.validateOptional)(o), global: (0, r2.validateOptional)(o), id: (0, r2.validateType)(["Identifier", "StringLiteral"]), body: (0, r2.validateType)(["TSModuleBlock", "TSModuleDeclaration"]) } }), a("TSModuleBlock", { aliases: ["Scopable", "Block", "BlockParent", "FunctionParent"], visitor: ["body"], fields: { body: (0, r2.validateArrayOfType)("Statement") } }), a("TSImportType", { aliases: ["TSType"], visitor: ["argument", "qualifier", "typeParameters"], fields: { argument: (0, r2.validateType)("StringLiteral"), qualifier: (0, r2.validateOptionalType)("TSEntityName"), typeParameters: (0, r2.validateOptionalType)("TSTypeParameterInstantiation") } }), a("TSImportEqualsDeclaration", { aliases: ["Statement"], visitor: ["id", "moduleReference"], fields: { isExport: (0, r2.validate)(o), id: (0, r2.validateType)("Identifier"), moduleReference: (0, r2.validateType)(["TSEntityName", "TSExternalModuleReference"]), importKind: { validate: (0, r2.assertOneOf)("type", "value"), optional: true } } }), a("TSExternalModuleReference", { visitor: ["expression"], fields: { expression: (0, r2.validateType)("StringLiteral") } }), a("TSNonNullExpression", { aliases: ["Expression", "LVal", "PatternLike"], visitor: ["expression"], fields: { expression: (0, r2.validateType)("Expression") } }), a("TSExportAssignment", { aliases: ["Statement"], visitor: ["expression"], fields: { expression: (0, r2.validateType)("Expression") } }), a("TSNamespaceExportDeclaration", { aliases: ["Statement"], visitor: ["id"], fields: { id: (0, r2.validateType)("Identifier") } }), a("TSTypeAnnotation", { visitor: ["typeAnnotation"], fields: { typeAnnotation: { validate: (0, r2.assertNodeType)("TSType") } } }), a("TSTypeParameterInstantiation", { visitor: ["params"], fields: { params: { validate: (0, r2.chain)((0, r2.assertValueType)("array"), (0, r2.assertEach)((0, r2.assertNodeType)("TSType"))) } } }), a("TSTypeParameterDeclaration", { visitor: ["params"], fields: { params: { validate: (0, r2.chain)((0, r2.assertValueType)("array"), (0, r2.assertEach)((0, r2.assertNodeType)("TSTypeParameter"))) } } }), a("TSTypeParameter", { builder: ["constraint", "default", "name"], visitor: ["constraint", "default"], fields: { name: { validate: (0, r2.assertValueType)("string") }, in: { validate: (0, r2.assertValueType)("boolean"), optional: true }, out: { validate: (0, r2.assertValueType)("boolean"), optional: true }, const: { validate: (0, r2.assertValueType)("boolean"), optional: true }, constraint: { validate: (0, r2.assertNodeType)("TSType"), optional: true }, default: { validate: (0, r2.assertNodeType)("TSType"), optional: true } } });
      }, 1514: (e2, t2, n2) => {
        "use strict";
        var r2 = n2(4155);
        Object.defineProperty(t2, "__esModule", { value: true }), t2.VISITOR_KEYS = t2.NODE_PARENT_VALIDATIONS = t2.NODE_FIELDS = t2.FLIPPED_ALIAS_KEYS = t2.DEPRECATED_KEYS = t2.BUILDER_KEYS = t2.ALIAS_KEYS = void 0, t2.arrayOf = m, t2.arrayOfType = T, t2.assertEach = g, t2.assertNodeOrValueType = function(...e3) {
          function t3(t4, n3, r3) {
            for (const a2 of e3) if (d(r3) === a2 || (0, i.default)(a2, r3)) return void (0, s.validateChild)(t4, n3, r3);
            throw new TypeError(`Property ${n3} of ${t4.type} expected node to be of a type ${JSON.stringify(e3)} but instead got ${JSON.stringify(null == r3 ? void 0 : r3.type)}`);
          }
          return t3.oneOfNodeOrValueTypes = e3, t3;
        }, t2.assertNodeType = b, t2.assertOneOf = function(...e3) {
          function t3(t4, n3, r3) {
            if (e3.indexOf(r3) < 0) throw new TypeError(`Property ${n3} expected value to be one of ${JSON.stringify(e3)} but got ${JSON.stringify(r3)}`);
          }
          return t3.oneOf = e3, t3;
        }, t2.assertOptionalChainStart = function() {
          return function(e3) {
            var t3;
            let n3 = e3;
            for (; e3; ) {
              const { type: e4 } = n3;
              if ("OptionalCallExpression" !== e4) {
                if ("OptionalMemberExpression" !== e4) break;
                if (n3.optional) return;
                n3 = n3.object;
              } else {
                if (n3.optional) return;
                n3 = n3.callee;
              }
            }
            throw new TypeError(`Non-optional ${e3.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${null == (t3 = n3) ? void 0 : t3.type}`);
          };
        }, t2.assertShape = function(e3) {
          function t3(t4, n3, r3) {
            const i2 = [];
            for (const n4 of Object.keys(e3)) try {
              (0, s.validateField)(t4, n4, r3[n4], e3[n4]);
            } catch (e4) {
              if (e4 instanceof TypeError) {
                i2.push(e4.message);
                continue;
              }
              throw e4;
            }
            if (i2.length) throw new TypeError(`Property ${n3} of ${t4.type} expected to have the following:
${i2.join("\n")}`);
          }
          return t3.shapeOf = e3, t3;
        }, t2.assertValueType = E, t2.chain = S, t2.default = A, t2.defineAliasedType = function(...e3) {
          return (t3, n3 = {}) => {
            let r3 = n3.aliases;
            var i2;
            r3 || (n3.inherits && (r3 = null == (i2 = D[n3.inherits].aliases) ? void 0 : i2.slice()), null != r3 || (r3 = []), n3.aliases = r3);
            const s2 = e3.filter((e4) => !r3.includes(e4));
            r3.unshift(...s2), A(t3, n3);
          };
        }, t2.typeIs = y, t2.validate = f, t2.validateArrayOfType = function(e3) {
          return f(T(e3));
        }, t2.validateOptional = function(e3) {
          return { validate: e3, optional: true };
        }, t2.validateOptionalType = function(e3) {
          return { validate: y(e3), optional: true };
        }, t2.validateType = function(e3) {
          return f(y(e3));
        };
        var i = n2(5171), s = n2(7750);
        const a = {};
        t2.VISITOR_KEYS = a;
        const o = {};
        t2.ALIAS_KEYS = o;
        const l = {};
        t2.FLIPPED_ALIAS_KEYS = l;
        const c = {};
        t2.NODE_FIELDS = c;
        const u = {};
        t2.BUILDER_KEYS = u;
        const p = {};
        t2.DEPRECATED_KEYS = p;
        const h = {};
        function d(e3) {
          return Array.isArray(e3) ? "array" : null === e3 ? "null" : typeof e3;
        }
        function f(e3) {
          return { validate: e3 };
        }
        function y(e3) {
          return "string" == typeof e3 ? b(e3) : b(...e3);
        }
        function m(e3) {
          return S(E("array"), g(e3));
        }
        function T(e3) {
          return m(y(e3));
        }
        function g(e3) {
          function t3(t4, n3, i2) {
            if (Array.isArray(i2)) for (let a2 = 0; a2 < i2.length; a2++) {
              const o2 = `${n3}[${a2}]`, l2 = i2[a2];
              e3(t4, o2, l2), r2.env.BABEL_TYPES_8_BREAKING && (0, s.validateChild)(t4, o2, l2);
            }
          }
          return t3.each = e3, t3;
        }
        function b(...e3) {
          function t3(t4, n3, r3) {
            for (const a2 of e3) if ((0, i.default)(a2, r3)) return void (0, s.validateChild)(t4, n3, r3);
            throw new TypeError(`Property ${n3} of ${t4.type} expected node to be of a type ${JSON.stringify(e3)} but instead got ${JSON.stringify(null == r3 ? void 0 : r3.type)}`);
          }
          return t3.oneOfNodeTypes = e3, t3;
        }
        function E(e3) {
          function t3(t4, n3, r3) {
            if (d(r3) !== e3) throw new TypeError(`Property ${n3} expected type of ${e3} but got ${d(r3)}`);
          }
          return t3.type = e3, t3;
        }
        function S(...e3) {
          function t3(...t4) {
            for (const n3 of e3) n3(...t4);
          }
          if (t3.chainOf = e3, e3.length >= 2 && "type" in e3[0] && "array" === e3[0].type && !("each" in e3[1])) throw new Error('An assertValueType("array") validator can only be followed by an assertEach(...) validator.');
          return t3;
        }
        t2.NODE_PARENT_VALIDATIONS = h;
        const P = ["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"], x = ["default", "optional", "deprecated", "validate"], D = {};
        function A(e3, t3 = {}) {
          const n3 = t3.inherits && D[t3.inherits] || {};
          let r3 = t3.fields;
          if (!r3 && (r3 = {}, n3.fields)) {
            const e4 = Object.getOwnPropertyNames(n3.fields);
            for (const t4 of e4) {
              const e5 = n3.fields[t4], i3 = e5.default;
              if (Array.isArray(i3) ? i3.length > 0 : i3 && "object" == typeof i3) throw new Error("field defaults can only be primitives or empty arrays currently");
              r3[t4] = { default: Array.isArray(i3) ? [] : i3, optional: e5.optional, deprecated: e5.deprecated, validate: e5.validate };
            }
          }
          const i2 = t3.visitor || n3.visitor || [], s2 = t3.aliases || n3.aliases || [], f2 = t3.builder || n3.builder || t3.visitor || [];
          for (const n4 of Object.keys(t3)) if (-1 === P.indexOf(n4)) throw new Error(`Unknown type option "${n4}" on ${e3}`);
          t3.deprecatedAlias && (p[t3.deprecatedAlias] = e3);
          for (const e4 of i2.concat(f2)) r3[e4] = r3[e4] || {};
          for (const t4 of Object.keys(r3)) {
            const n4 = r3[t4];
            void 0 !== n4.default && -1 === f2.indexOf(t4) && (n4.optional = true), void 0 === n4.default ? n4.default = null : n4.validate || null == n4.default || (n4.validate = E(d(n4.default)));
            for (const r4 of Object.keys(n4)) if (-1 === x.indexOf(r4)) throw new Error(`Unknown field key "${r4}" on ${e3}.${t4}`);
          }
          a[e3] = t3.visitor = i2, u[e3] = t3.builder = f2, c[e3] = t3.fields = r3, o[e3] = t3.aliases = s2, s2.forEach((t4) => {
            l[t4] = l[t4] || [], l[t4].push(e3);
          }), t3.validate && (h[e3] = t3.validate), D[e3] = t3;
        }
      }, 6067: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true });
        var r2 = { react: true, assertNode: true, createTypeAnnotationBasedOnTypeof: true, createUnionTypeAnnotation: true, createFlowUnionType: true, createTSUnionType: true, cloneNode: true, clone: true, cloneDeep: true, cloneDeepWithoutLoc: true, cloneWithoutLoc: true, addComment: true, addComments: true, inheritInnerComments: true, inheritLeadingComments: true, inheritsComments: true, inheritTrailingComments: true, removeComments: true, ensureBlock: true, toBindingIdentifierName: true, toBlock: true, toComputedKey: true, toExpression: true, toIdentifier: true, toKeyAlias: true, toSequenceExpression: true, toStatement: true, valueToNode: true, appendToMemberExpression: true, inherits: true, prependToMemberExpression: true, removeProperties: true, removePropertiesDeep: true, removeTypeDuplicates: true, getBindingIdentifiers: true, getOuterBindingIdentifiers: true, traverse: true, traverseFast: true, shallowEqual: true, is: true, isBinding: true, isBlockScoped: true, isImmutable: true, isLet: true, isNode: true, isNodesEquivalent: true, isPlaceholderType: true, isReferenced: true, isScope: true, isSpecifierDefault: true, isType: true, isValidES3Identifier: true, isValidIdentifier: true, isVar: true, matchesPattern: true, validate: true, buildMatchMemberExpression: true, __internal__deprecationWarning: true };
        Object.defineProperty(t2, "__internal__deprecationWarning", { enumerable: true, get: function() {
          return ye.default;
        } }), Object.defineProperty(t2, "addComment", { enumerable: true, get: function() {
          return b.default;
        } }), Object.defineProperty(t2, "addComments", { enumerable: true, get: function() {
          return E.default;
        } }), Object.defineProperty(t2, "appendToMemberExpression", { enumerable: true, get: function() {
          return R.default;
        } }), Object.defineProperty(t2, "assertNode", { enumerable: true, get: function() {
          return o.default;
        } }), Object.defineProperty(t2, "buildMatchMemberExpression", { enumerable: true, get: function() {
          return de.default;
        } }), Object.defineProperty(t2, "clone", { enumerable: true, get: function() {
          return y.default;
        } }), Object.defineProperty(t2, "cloneDeep", { enumerable: true, get: function() {
          return m.default;
        } }), Object.defineProperty(t2, "cloneDeepWithoutLoc", { enumerable: true, get: function() {
          return T.default;
        } }), Object.defineProperty(t2, "cloneNode", { enumerable: true, get: function() {
          return f.default;
        } }), Object.defineProperty(t2, "cloneWithoutLoc", { enumerable: true, get: function() {
          return g.default;
        } }), Object.defineProperty(t2, "createFlowUnionType", { enumerable: true, get: function() {
          return u.default;
        } }), Object.defineProperty(t2, "createTSUnionType", { enumerable: true, get: function() {
          return p.default;
        } }), Object.defineProperty(t2, "createTypeAnnotationBasedOnTypeof", { enumerable: true, get: function() {
          return c.default;
        } }), Object.defineProperty(t2, "createUnionTypeAnnotation", { enumerable: true, get: function() {
          return u.default;
        } }), Object.defineProperty(t2, "ensureBlock", { enumerable: true, get: function() {
          return w.default;
        } }), Object.defineProperty(t2, "getBindingIdentifiers", { enumerable: true, get: function() {
          return Y.default;
        } }), Object.defineProperty(t2, "getOuterBindingIdentifiers", { enumerable: true, get: function() {
          return q.default;
        } }), Object.defineProperty(t2, "inheritInnerComments", { enumerable: true, get: function() {
          return S.default;
        } }), Object.defineProperty(t2, "inheritLeadingComments", { enumerable: true, get: function() {
          return P.default;
        } }), Object.defineProperty(t2, "inheritTrailingComments", { enumerable: true, get: function() {
          return D.default;
        } }), Object.defineProperty(t2, "inherits", { enumerable: true, get: function() {
          return U.default;
        } }), Object.defineProperty(t2, "inheritsComments", { enumerable: true, get: function() {
          return x.default;
        } }), Object.defineProperty(t2, "is", { enumerable: true, get: function() {
          return G.default;
        } }), Object.defineProperty(t2, "isBinding", { enumerable: true, get: function() {
          return z.default;
        } }), Object.defineProperty(t2, "isBlockScoped", { enumerable: true, get: function() {
          return Q.default;
        } }), Object.defineProperty(t2, "isImmutable", { enumerable: true, get: function() {
          return Z.default;
        } }), Object.defineProperty(t2, "isLet", { enumerable: true, get: function() {
          return ee.default;
        } }), Object.defineProperty(t2, "isNode", { enumerable: true, get: function() {
          return te.default;
        } }), Object.defineProperty(t2, "isNodesEquivalent", { enumerable: true, get: function() {
          return ne.default;
        } }), Object.defineProperty(t2, "isPlaceholderType", { enumerable: true, get: function() {
          return re.default;
        } }), Object.defineProperty(t2, "isReferenced", { enumerable: true, get: function() {
          return ie.default;
        } }), Object.defineProperty(t2, "isScope", { enumerable: true, get: function() {
          return se.default;
        } }), Object.defineProperty(t2, "isSpecifierDefault", { enumerable: true, get: function() {
          return ae.default;
        } }), Object.defineProperty(t2, "isType", { enumerable: true, get: function() {
          return oe.default;
        } }), Object.defineProperty(t2, "isValidES3Identifier", { enumerable: true, get: function() {
          return le.default;
        } }), Object.defineProperty(t2, "isValidIdentifier", { enumerable: true, get: function() {
          return ce.default;
        } }), Object.defineProperty(t2, "isVar", { enumerable: true, get: function() {
          return ue.default;
        } }), Object.defineProperty(t2, "matchesPattern", { enumerable: true, get: function() {
          return pe.default;
        } }), Object.defineProperty(t2, "prependToMemberExpression", { enumerable: true, get: function() {
          return V.default;
        } }), t2.react = void 0, Object.defineProperty(t2, "removeComments", { enumerable: true, get: function() {
          return A.default;
        } }), Object.defineProperty(t2, "removeProperties", { enumerable: true, get: function() {
          return K.default;
        } }), Object.defineProperty(t2, "removePropertiesDeep", { enumerable: true, get: function() {
          return W.default;
        } }), Object.defineProperty(t2, "removeTypeDuplicates", { enumerable: true, get: function() {
          return X.default;
        } }), Object.defineProperty(t2, "shallowEqual", { enumerable: true, get: function() {
          return $.default;
        } }), Object.defineProperty(t2, "toBindingIdentifierName", { enumerable: true, get: function() {
          return O.default;
        } }), Object.defineProperty(t2, "toBlock", { enumerable: true, get: function() {
          return I.default;
        } }), Object.defineProperty(t2, "toComputedKey", { enumerable: true, get: function() {
          return N.default;
        } }), Object.defineProperty(t2, "toExpression", { enumerable: true, get: function() {
          return F.default;
        } }), Object.defineProperty(t2, "toIdentifier", { enumerable: true, get: function() {
          return k.default;
        } }), Object.defineProperty(t2, "toKeyAlias", { enumerable: true, get: function() {
          return L.default;
        } }), Object.defineProperty(t2, "toSequenceExpression", { enumerable: true, get: function() {
          return _.default;
        } }), Object.defineProperty(t2, "toStatement", { enumerable: true, get: function() {
          return M.default;
        } }), Object.defineProperty(t2, "traverse", { enumerable: true, get: function() {
          return H.default;
        } }), Object.defineProperty(t2, "traverseFast", { enumerable: true, get: function() {
          return J.default;
        } }), Object.defineProperty(t2, "validate", { enumerable: true, get: function() {
          return he.default;
        } }), Object.defineProperty(t2, "valueToNode", { enumerable: true, get: function() {
          return B.default;
        } });
        var i = n2(4229), s = n2(9733), a = n2(4225), o = n2(391), l = n2(163);
        Object.keys(l).forEach(function(e3) {
          "default" !== e3 && "__esModule" !== e3 && (Object.prototype.hasOwnProperty.call(r2, e3) || e3 in t2 && t2[e3] === l[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
            return l[e3];
          } }));
        });
        var c = n2(5976), u = n2(7625), p = n2(6752), h = n2(1411);
        Object.keys(h).forEach(function(e3) {
          "default" !== e3 && "__esModule" !== e3 && (Object.prototype.hasOwnProperty.call(r2, e3) || e3 in t2 && t2[e3] === h[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
            return h[e3];
          } }));
        });
        var d = n2(9470);
        Object.keys(d).forEach(function(e3) {
          "default" !== e3 && "__esModule" !== e3 && (Object.prototype.hasOwnProperty.call(r2, e3) || e3 in t2 && t2[e3] === d[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
            return d[e3];
          } }));
        });
        var f = n2(2419), y = n2(8229), m = n2(8030), T = n2(8519), g = n2(9381), b = n2(109), E = n2(8647), S = n2(2823), P = n2(8930), x = n2(9134), D = n2(2714), A = n2(698), v = n2(4998);
        Object.keys(v).forEach(function(e3) {
          "default" !== e3 && "__esModule" !== e3 && (Object.prototype.hasOwnProperty.call(r2, e3) || e3 in t2 && t2[e3] === v[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
            return v[e3];
          } }));
        });
        var C = n2(3725);
        Object.keys(C).forEach(function(e3) {
          "default" !== e3 && "__esModule" !== e3 && (Object.prototype.hasOwnProperty.call(r2, e3) || e3 in t2 && t2[e3] === C[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
            return C[e3];
          } }));
        });
        var w = n2(8560), O = n2(5200), I = n2(9988), N = n2(3816), F = n2(5317), k = n2(7885), L = n2(5046), _ = n2(2473), M = n2(350), B = n2(1382), j = n2(1678);
        Object.keys(j).forEach(function(e3) {
          "default" !== e3 && "__esModule" !== e3 && (Object.prototype.hasOwnProperty.call(r2, e3) || e3 in t2 && t2[e3] === j[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
            return j[e3];
          } }));
        });
        var R = n2(2115), U = n2(4151), V = n2(2369), K = n2(7665), W = n2(857), X = n2(8874), Y = n2(984), q = n2(179), H = n2(9787);
        Object.keys(H).forEach(function(e3) {
          "default" !== e3 && "__esModule" !== e3 && (Object.prototype.hasOwnProperty.call(r2, e3) || e3 in t2 && t2[e3] === H[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
            return H[e3];
          } }));
        });
        var J = n2(5139), $ = n2(9960), G = n2(5171), z = n2(8443), Q = n2(964), Z = n2(1689), ee = n2(3066), te = n2(4814), ne = n2(7997), re = n2(8894), ie = n2(3683), se = n2(2126), ae = n2(8691), oe = n2(5179), le = n2(7879), ce = n2(5820), ue = n2(3358), pe = n2(2693), he = n2(7750), de = n2(2051), fe = n2(9869);
        Object.keys(fe).forEach(function(e3) {
          "default" !== e3 && "__esModule" !== e3 && (Object.prototype.hasOwnProperty.call(r2, e3) || e3 in t2 && t2[e3] === fe[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
            return fe[e3];
          } }));
        });
        var ye = n2(4619);
        const me = { isReactComponent: i.default, isCompatTag: s.default, buildChildren: a.default };
        t2.react = me;
      }, 2115: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, n3 = false) {
          return e3.object = (0, r2.memberExpression)(e3.object, e3.property, e3.computed), e3.property = t3, e3.computed = !!n3, e3;
        };
        var r2 = n2(1411);
      }, 8874: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function e3(t3) {
          const n3 = Array.from(t3), s = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Set(), l = [];
          for (let t4 = 0; t4 < n3.length; t4++) {
            const c = n3[t4];
            if (c && !(l.indexOf(c) >= 0)) {
              if ((0, r2.isAnyTypeAnnotation)(c)) return [c];
              if ((0, r2.isFlowBaseAnnotation)(c)) a.set(c.type, c);
              else if ((0, r2.isUnionTypeAnnotation)(c)) o.has(c.types) || (n3.push(...c.types), o.add(c.types));
              else if ((0, r2.isGenericTypeAnnotation)(c)) {
                const t5 = i(c.id);
                if (s.has(t5)) {
                  let n4 = s.get(t5);
                  n4.typeParameters ? c.typeParameters && (n4.typeParameters.params.push(...c.typeParameters.params), n4.typeParameters.params = e3(n4.typeParameters.params)) : n4 = c.typeParameters;
                } else s.set(t5, c);
              } else l.push(c);
            }
          }
          for (const [, e4] of a) l.push(e4);
          for (const [, e4] of s) l.push(e4);
          return l;
        };
        var r2 = n2(9869);
        function i(e3) {
          return (0, r2.isIdentifier)(e3) ? e3.name : `${e3.id.name}.${i(e3.qualification)}`;
        }
      }, 4151: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
          if (!e3 || !t3) return e3;
          for (const n3 of r2.INHERIT_KEYS.optional) null == e3[n3] && (e3[n3] = t3[n3]);
          for (const n3 of Object.keys(t3)) "_" === n3[0] && "__clone" !== n3 && (e3[n3] = t3[n3]);
          for (const n3 of r2.INHERIT_KEYS.force) e3[n3] = t3[n3];
          return (0, i.default)(e3, t3), e3;
        };
        var r2 = n2(3725), i = n2(9134);
      }, 2369: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
          if ((0, i.isSuper)(e3.object)) throw new Error("Cannot prepend node to super property access (`super.foo`).");
          return e3.object = (0, r2.memberExpression)(t3, e3.object), e3;
        };
        var r2 = n2(1411), i = n2(6067);
      }, 7665: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3 = {}) {
          const n3 = t3.preserveComments ? i : s;
          for (const t4 of n3) null != e3[t4] && (e3[t4] = void 0);
          for (const t4 of Object.keys(e3)) "_" === t4[0] && null != e3[t4] && (e3[t4] = void 0);
          const r3 = Object.getOwnPropertySymbols(e3);
          for (const t4 of r3) e3[t4] = null;
        };
        var r2 = n2(3725);
        const i = ["tokens", "start", "end", "loc", "raw", "rawValue"], s = [...r2.COMMENT_KEYS, "comments", ...i];
      }, 857: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
          return (0, r2.default)(e3, i.default, t3), e3;
        };
        var r2 = n2(5139), i = n2(7665);
      }, 2819: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function e3(t3) {
          const n3 = Array.from(t3), s = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Set(), l = [];
          for (let t4 = 0; t4 < n3.length; t4++) {
            const c = n3[t4];
            if (c && !(l.indexOf(c) >= 0)) {
              if ((0, r2.isTSAnyKeyword)(c)) return [c];
              if ((0, r2.isTSBaseType)(c)) a.set(c.type, c);
              else if ((0, r2.isTSUnionType)(c)) o.has(c.types) || (n3.push(...c.types), o.add(c.types));
              else if ((0, r2.isTSTypeReference)(c) && c.typeParameters) {
                const t5 = i(c.typeName);
                if (s.has(t5)) {
                  let n4 = s.get(t5);
                  n4.typeParameters ? c.typeParameters && (n4.typeParameters.params.push(...c.typeParameters.params), n4.typeParameters.params = e3(n4.typeParameters.params)) : n4 = c.typeParameters;
                } else s.set(t5, c);
              } else l.push(c);
            }
          }
          for (const [, e4] of a) l.push(e4);
          for (const [, e4] of s) l.push(e4);
          return l;
        };
        var r2 = n2(9869);
        function i(e3) {
          return (0, r2.isIdentifier)(e3) ? e3.name : `${e3.right.name}.${i(e3.left)}`;
        }
      }, 984: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = i;
        var r2 = n2(9869);
        function i(e3, t3, n3) {
          const s = [].concat(e3), a = /* @__PURE__ */ Object.create(null);
          for (; s.length; ) {
            const e4 = s.shift();
            if (!e4) continue;
            const o = i.keys[e4.type];
            if ((0, r2.isIdentifier)(e4)) t3 ? (a[e4.name] = a[e4.name] || []).push(e4) : a[e4.name] = e4;
            else if (!(0, r2.isExportDeclaration)(e4) || (0, r2.isExportAllDeclaration)(e4)) {
              if (n3) {
                if ((0, r2.isFunctionDeclaration)(e4)) {
                  s.push(e4.id);
                  continue;
                }
                if ((0, r2.isFunctionExpression)(e4)) continue;
              }
              if (o) for (let t4 = 0; t4 < o.length; t4++) {
                const n4 = e4[o[t4]];
                n4 && (Array.isArray(n4) ? s.push(...n4) : s.push(n4));
              }
            } else (0, r2.isDeclaration)(e4.declaration) && s.push(e4.declaration);
          }
          return a;
        }
        i.keys = { DeclareClass: ["id"], DeclareFunction: ["id"], DeclareModule: ["id"], DeclareVariable: ["id"], DeclareInterface: ["id"], DeclareTypeAlias: ["id"], DeclareOpaqueType: ["id"], InterfaceDeclaration: ["id"], TypeAlias: ["id"], OpaqueType: ["id"], CatchClause: ["param"], LabeledStatement: ["label"], UnaryExpression: ["argument"], AssignmentExpression: ["left"], ImportSpecifier: ["local"], ImportNamespaceSpecifier: ["local"], ImportDefaultSpecifier: ["local"], ImportDeclaration: ["specifiers"], ExportSpecifier: ["exported"], ExportNamespaceSpecifier: ["exported"], ExportDefaultSpecifier: ["exported"], FunctionDeclaration: ["id", "params"], FunctionExpression: ["id", "params"], ArrowFunctionExpression: ["params"], ObjectMethod: ["params"], ClassMethod: ["params"], ClassPrivateMethod: ["params"], ForInStatement: ["left"], ForOfStatement: ["left"], ClassDeclaration: ["id"], ClassExpression: ["id"], RestElement: ["argument"], UpdateExpression: ["argument"], ObjectProperty: ["value"], AssignmentPattern: ["left"], ArrayPattern: ["elements"], ObjectPattern: ["properties"], VariableDeclaration: ["declarations"], VariableDeclarator: ["id"] };
      }, 179: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var r2 = n2(984);
        t2.default = function(e3, t3) {
          return (0, r2.default)(e3, t3, true);
        };
      }, 9787: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, n3) {
          "function" == typeof t3 && (t3 = { enter: t3 });
          const { enter: r3, exit: s } = t3;
          i(e3, r3, s, n3, []);
        };
        var r2 = n2(1678);
        function i(e3, t3, n3, s, a) {
          const o = r2.VISITOR_KEYS[e3.type];
          if (o) {
            t3 && t3(e3, a, s);
            for (const r3 of o) {
              const o2 = e3[r3];
              if (Array.isArray(o2)) for (let l = 0; l < o2.length; l++) {
                const c = o2[l];
                c && (a.push({ node: e3, key: r3, index: l }), i(c, t3, n3, s, a), a.pop());
              }
              else o2 && (a.push({ node: e3, key: r3 }), i(o2, t3, n3, s, a), a.pop());
            }
            n3 && n3(e3, a, s);
          }
        }
      }, 5139: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function e3(t3, n3, i) {
          if (!t3) return;
          const s = r2.VISITOR_KEYS[t3.type];
          if (s) {
            n3(t3, i = i || {});
            for (const r3 of s) {
              const s2 = t3[r3];
              if (Array.isArray(s2)) for (const t4 of s2) e3(t4, n3, i);
              else e3(s2, n3, i);
            }
          }
        };
        var r2 = n2(1678);
      }, 4619: (e2, t2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r2 = "") {
          if (n2.has(e3)) return;
          n2.add(e3);
          const { internal: i, trace: s } = function(e4, t4) {
            const { stackTraceLimit: n3, prepareStackTrace: r3 } = Error;
            let i2;
            if (Error.stackTraceLimit = 4, Error.prepareStackTrace = function(e5, t5) {
              i2 = t5;
            }, new Error().stack, Error.stackTraceLimit = n3, Error.prepareStackTrace = r3, !i2) return { internal: false, trace: "" };
            const s2 = i2.slice(2, 4);
            return { internal: /[\\/]@babel[\\/]/.test(s2[1].getFileName()), trace: s2.map((e5) => `    at ${e5}`).join("\n") };
          }();
          i || console.warn(`${r2}\`${e3}\` has been deprecated, please migrate to \`${t3}\`
${s}`);
        };
        const n2 = /* @__PURE__ */ new Set();
      }, 9906: (e2, t2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, n2) {
          t3 && n2 && (t3[e3] = Array.from(new Set([].concat(t3[e3], n2[e3]).filter(Boolean))));
        };
      }, 8730: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
          const n3 = e3.value.split(/\r\n|\n|\r/);
          let s = 0;
          for (let e4 = 0; e4 < n3.length; e4++) n3[e4].match(/[^ \t]/) && (s = e4);
          let a = "";
          for (let e4 = 0; e4 < n3.length; e4++) {
            const t4 = n3[e4], r3 = 0 === e4, i2 = e4 === n3.length - 1, o = e4 === s;
            let l = t4.replace(/\t/g, " ");
            r3 || (l = l.replace(/^[ ]+/, "")), i2 || (l = l.replace(/[ ]+$/, "")), l && (o || (l += " "), a += l);
          }
          a && t3.push((0, i.inherits)((0, r2.stringLiteral)(a), e3));
        };
        var r2 = n2(1411), i = n2(6067);
      }, 9960: (e2, t2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
          const n2 = Object.keys(t3);
          for (const r2 of n2) if (e3[r2] !== t3[r2]) return false;
          return true;
        };
      }, 2051: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
          const n3 = e3.split(".");
          return (e4) => (0, r2.default)(e4, n3, t3);
        };
        var r2 = n2(2693);
      }, 9869: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.isAccessor = function(e3, t3) {
          return !!e3 && ("ClassAccessorProperty" === e3.type && (null == t3 || (0, r2.default)(e3, t3)));
        }, t2.isAnyTypeAnnotation = function(e3, t3) {
          return !!e3 && "AnyTypeAnnotation" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isArgumentPlaceholder = function(e3, t3) {
          return !!e3 && "ArgumentPlaceholder" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isArrayExpression = function(e3, t3) {
          return !!e3 && "ArrayExpression" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isArrayPattern = function(e3, t3) {
          return !!e3 && "ArrayPattern" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isArrayTypeAnnotation = function(e3, t3) {
          return !!e3 && "ArrayTypeAnnotation" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isArrowFunctionExpression = function(e3, t3) {
          return !!e3 && "ArrowFunctionExpression" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isAssignmentExpression = function(e3, t3) {
          return !!e3 && "AssignmentExpression" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isAssignmentPattern = function(e3, t3) {
          return !!e3 && "AssignmentPattern" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isAwaitExpression = function(e3, t3) {
          return !!e3 && "AwaitExpression" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isBigIntLiteral = function(e3, t3) {
          return !!e3 && "BigIntLiteral" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isBinary = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "BinaryExpression":
            case "LogicalExpression":
              break;
            default:
              return false;
          }
          return null == t3 || (0, r2.default)(e3, t3);
        }, t2.isBinaryExpression = function(e3, t3) {
          return !!e3 && "BinaryExpression" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isBindExpression = function(e3, t3) {
          return !!e3 && "BindExpression" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isBlock = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "BlockStatement":
            case "Program":
            case "TSModuleBlock":
              break;
            case "Placeholder":
              if ("BlockStatement" === e3.expectedNode) break;
            default:
              return false;
          }
          return null == t3 || (0, r2.default)(e3, t3);
        }, t2.isBlockParent = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "BlockStatement":
            case "CatchClause":
            case "DoWhileStatement":
            case "ForInStatement":
            case "ForStatement":
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "Program":
            case "ObjectMethod":
            case "SwitchStatement":
            case "WhileStatement":
            case "ArrowFunctionExpression":
            case "ForOfStatement":
            case "ClassMethod":
            case "ClassPrivateMethod":
            case "StaticBlock":
            case "TSModuleBlock":
              break;
            case "Placeholder":
              if ("BlockStatement" === e3.expectedNode) break;
            default:
              return false;
          }
          return null == t3 || (0, r2.default)(e3, t3);
        }, t2.isBlockStatement = function(e3, t3) {
          return !!e3 && "BlockStatement" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isBooleanLiteral = function(e3, t3) {
          return !!e3 && "BooleanLiteral" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isBooleanLiteralTypeAnnotation = function(e3, t3) {
          return !!e3 && "BooleanLiteralTypeAnnotation" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isBooleanTypeAnnotation = function(e3, t3) {
          return !!e3 && "BooleanTypeAnnotation" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isBreakStatement = function(e3, t3) {
          return !!e3 && "BreakStatement" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isCallExpression = function(e3, t3) {
          return !!e3 && "CallExpression" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isCatchClause = function(e3, t3) {
          return !!e3 && "CatchClause" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isClass = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "ClassExpression":
            case "ClassDeclaration":
              break;
            default:
              return false;
          }
          return null == t3 || (0, r2.default)(e3, t3);
        }, t2.isClassAccessorProperty = function(e3, t3) {
          return !!e3 && "ClassAccessorProperty" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isClassBody = function(e3, t3) {
          return !!e3 && "ClassBody" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isClassDeclaration = function(e3, t3) {
          return !!e3 && "ClassDeclaration" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isClassExpression = function(e3, t3) {
          return !!e3 && "ClassExpression" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isClassImplements = function(e3, t3) {
          return !!e3 && "ClassImplements" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isClassMethod = function(e3, t3) {
          return !!e3 && "ClassMethod" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isClassPrivateMethod = function(e3, t3) {
          return !!e3 && "ClassPrivateMethod" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isClassPrivateProperty = function(e3, t3) {
          return !!e3 && "ClassPrivateProperty" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isClassProperty = function(e3, t3) {
          return !!e3 && "ClassProperty" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isCompletionStatement = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "BreakStatement":
            case "ContinueStatement":
            case "ReturnStatement":
            case "ThrowStatement":
              break;
            default:
              return false;
          }
          return null == t3 || (0, r2.default)(e3, t3);
        }, t2.isConditional = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "ConditionalExpression":
            case "IfStatement":
              break;
            default:
              return false;
          }
          return null == t3 || (0, r2.default)(e3, t3);
        }, t2.isConditionalExpression = function(e3, t3) {
          return !!e3 && "ConditionalExpression" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isContinueStatement = function(e3, t3) {
          return !!e3 && "ContinueStatement" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isDebuggerStatement = function(e3, t3) {
          return !!e3 && "DebuggerStatement" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isDecimalLiteral = function(e3, t3) {
          return !!e3 && "DecimalLiteral" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isDeclaration = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "FunctionDeclaration":
            case "VariableDeclaration":
            case "ClassDeclaration":
            case "ExportAllDeclaration":
            case "ExportDefaultDeclaration":
            case "ExportNamedDeclaration":
            case "ImportDeclaration":
            case "DeclareClass":
            case "DeclareFunction":
            case "DeclareInterface":
            case "DeclareModule":
            case "DeclareModuleExports":
            case "DeclareTypeAlias":
            case "DeclareOpaqueType":
            case "DeclareVariable":
            case "DeclareExportDeclaration":
            case "DeclareExportAllDeclaration":
            case "InterfaceDeclaration":
            case "OpaqueType":
            case "TypeAlias":
            case "EnumDeclaration":
            case "TSDeclareFunction":
            case "TSInterfaceDeclaration":
            case "TSTypeAliasDeclaration":
            case "TSEnumDeclaration":
            case "TSModuleDeclaration":
              break;
            case "Placeholder":
              if ("Declaration" === e3.expectedNode) break;
            default:
              return false;
          }
          return null == t3 || (0, r2.default)(e3, t3);
        }, t2.isDeclareClass = function(e3, t3) {
          return !!e3 && "DeclareClass" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isDeclareExportAllDeclaration = function(e3, t3) {
          return !!e3 && "DeclareExportAllDeclaration" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isDeclareExportDeclaration = function(e3, t3) {
          return !!e3 && "DeclareExportDeclaration" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isDeclareFunction = function(e3, t3) {
          return !!e3 && "DeclareFunction" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isDeclareInterface = function(e3, t3) {
          return !!e3 && "DeclareInterface" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isDeclareModule = function(e3, t3) {
          return !!e3 && "DeclareModule" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isDeclareModuleExports = function(e3, t3) {
          return !!e3 && "DeclareModuleExports" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isDeclareOpaqueType = function(e3, t3) {
          return !!e3 && "DeclareOpaqueType" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isDeclareTypeAlias = function(e3, t3) {
          return !!e3 && "DeclareTypeAlias" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isDeclareVariable = function(e3, t3) {
          return !!e3 && "DeclareVariable" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isDeclaredPredicate = function(e3, t3) {
          return !!e3 && "DeclaredPredicate" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isDecorator = function(e3, t3) {
          return !!e3 && "Decorator" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isDirective = function(e3, t3) {
          return !!e3 && "Directive" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isDirectiveLiteral = function(e3, t3) {
          return !!e3 && "DirectiveLiteral" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isDoExpression = function(e3, t3) {
          return !!e3 && "DoExpression" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isDoWhileStatement = function(e3, t3) {
          return !!e3 && "DoWhileStatement" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isEmptyStatement = function(e3, t3) {
          return !!e3 && "EmptyStatement" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isEmptyTypeAnnotation = function(e3, t3) {
          return !!e3 && "EmptyTypeAnnotation" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isEnumBody = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "EnumBooleanBody":
            case "EnumNumberBody":
            case "EnumStringBody":
            case "EnumSymbolBody":
              break;
            default:
              return false;
          }
          return null == t3 || (0, r2.default)(e3, t3);
        }, t2.isEnumBooleanBody = function(e3, t3) {
          return !!e3 && "EnumBooleanBody" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isEnumBooleanMember = function(e3, t3) {
          return !!e3 && "EnumBooleanMember" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isEnumDeclaration = function(e3, t3) {
          return !!e3 && "EnumDeclaration" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isEnumDefaultedMember = function(e3, t3) {
          return !!e3 && "EnumDefaultedMember" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isEnumMember = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "EnumBooleanMember":
            case "EnumNumberMember":
            case "EnumStringMember":
            case "EnumDefaultedMember":
              break;
            default:
              return false;
          }
          return null == t3 || (0, r2.default)(e3, t3);
        }, t2.isEnumNumberBody = function(e3, t3) {
          return !!e3 && "EnumNumberBody" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isEnumNumberMember = function(e3, t3) {
          return !!e3 && "EnumNumberMember" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isEnumStringBody = function(e3, t3) {
          return !!e3 && "EnumStringBody" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isEnumStringMember = function(e3, t3) {
          return !!e3 && "EnumStringMember" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isEnumSymbolBody = function(e3, t3) {
          return !!e3 && "EnumSymbolBody" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isExistsTypeAnnotation = function(e3, t3) {
          return !!e3 && "ExistsTypeAnnotation" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isExportAllDeclaration = function(e3, t3) {
          return !!e3 && "ExportAllDeclaration" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isExportDeclaration = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "ExportAllDeclaration":
            case "ExportDefaultDeclaration":
            case "ExportNamedDeclaration":
              break;
            default:
              return false;
          }
          return null == t3 || (0, r2.default)(e3, t3);
        }, t2.isExportDefaultDeclaration = function(e3, t3) {
          return !!e3 && "ExportDefaultDeclaration" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isExportDefaultSpecifier = function(e3, t3) {
          return !!e3 && "ExportDefaultSpecifier" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isExportNamedDeclaration = function(e3, t3) {
          return !!e3 && "ExportNamedDeclaration" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isExportNamespaceSpecifier = function(e3, t3) {
          return !!e3 && "ExportNamespaceSpecifier" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isExportSpecifier = function(e3, t3) {
          return !!e3 && "ExportSpecifier" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isExpression = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "ArrayExpression":
            case "AssignmentExpression":
            case "BinaryExpression":
            case "CallExpression":
            case "ConditionalExpression":
            case "FunctionExpression":
            case "Identifier":
            case "StringLiteral":
            case "NumericLiteral":
            case "NullLiteral":
            case "BooleanLiteral":
            case "RegExpLiteral":
            case "LogicalExpression":
            case "MemberExpression":
            case "NewExpression":
            case "ObjectExpression":
            case "SequenceExpression":
            case "ParenthesizedExpression":
            case "ThisExpression":
            case "UnaryExpression":
            case "UpdateExpression":
            case "ArrowFunctionExpression":
            case "ClassExpression":
            case "MetaProperty":
            case "Super":
            case "TaggedTemplateExpression":
            case "TemplateLiteral":
            case "YieldExpression":
            case "AwaitExpression":
            case "Import":
            case "BigIntLiteral":
            case "OptionalMemberExpression":
            case "OptionalCallExpression":
            case "TypeCastExpression":
            case "JSXElement":
            case "JSXFragment":
            case "BindExpression":
            case "DoExpression":
            case "RecordExpression":
            case "TupleExpression":
            case "DecimalLiteral":
            case "ModuleExpression":
            case "TopicReference":
            case "PipelineTopicExpression":
            case "PipelineBareFunction":
            case "PipelinePrimaryTopicReference":
            case "TSInstantiationExpression":
            case "TSAsExpression":
            case "TSSatisfiesExpression":
            case "TSTypeAssertion":
            case "TSNonNullExpression":
              break;
            case "Placeholder":
              switch (e3.expectedNode) {
                case "Expression":
                case "Identifier":
                case "StringLiteral":
                  break;
                default:
                  return false;
              }
              break;
            default:
              return false;
          }
          return null == t3 || (0, r2.default)(e3, t3);
        }, t2.isExpressionStatement = function(e3, t3) {
          return !!e3 && "ExpressionStatement" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isExpressionWrapper = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "ExpressionStatement":
            case "ParenthesizedExpression":
            case "TypeCastExpression":
              break;
            default:
              return false;
          }
          return null == t3 || (0, r2.default)(e3, t3);
        }, t2.isFile = function(e3, t3) {
          return !!e3 && "File" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isFlow = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "AnyTypeAnnotation":
            case "ArrayTypeAnnotation":
            case "BooleanTypeAnnotation":
            case "BooleanLiteralTypeAnnotation":
            case "NullLiteralTypeAnnotation":
            case "ClassImplements":
            case "DeclareClass":
            case "DeclareFunction":
            case "DeclareInterface":
            case "DeclareModule":
            case "DeclareModuleExports":
            case "DeclareTypeAlias":
            case "DeclareOpaqueType":
            case "DeclareVariable":
            case "DeclareExportDeclaration":
            case "DeclareExportAllDeclaration":
            case "DeclaredPredicate":
            case "ExistsTypeAnnotation":
            case "FunctionTypeAnnotation":
            case "FunctionTypeParam":
            case "GenericTypeAnnotation":
            case "InferredPredicate":
            case "InterfaceExtends":
            case "InterfaceDeclaration":
            case "InterfaceTypeAnnotation":
            case "IntersectionTypeAnnotation":
            case "MixedTypeAnnotation":
            case "EmptyTypeAnnotation":
            case "NullableTypeAnnotation":
            case "NumberLiteralTypeAnnotation":
            case "NumberTypeAnnotation":
            case "ObjectTypeAnnotation":
            case "ObjectTypeInternalSlot":
            case "ObjectTypeCallProperty":
            case "ObjectTypeIndexer":
            case "ObjectTypeProperty":
            case "ObjectTypeSpreadProperty":
            case "OpaqueType":
            case "QualifiedTypeIdentifier":
            case "StringLiteralTypeAnnotation":
            case "StringTypeAnnotation":
            case "SymbolTypeAnnotation":
            case "ThisTypeAnnotation":
            case "TupleTypeAnnotation":
            case "TypeofTypeAnnotation":
            case "TypeAlias":
            case "TypeAnnotation":
            case "TypeCastExpression":
            case "TypeParameter":
            case "TypeParameterDeclaration":
            case "TypeParameterInstantiation":
            case "UnionTypeAnnotation":
            case "Variance":
            case "VoidTypeAnnotation":
            case "EnumDeclaration":
            case "EnumBooleanBody":
            case "EnumNumberBody":
            case "EnumStringBody":
            case "EnumSymbolBody":
            case "EnumBooleanMember":
            case "EnumNumberMember":
            case "EnumStringMember":
            case "EnumDefaultedMember":
            case "IndexedAccessType":
            case "OptionalIndexedAccessType":
              break;
            default:
              return false;
          }
          return null == t3 || (0, r2.default)(e3, t3);
        }, t2.isFlowBaseAnnotation = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "AnyTypeAnnotation":
            case "BooleanTypeAnnotation":
            case "NullLiteralTypeAnnotation":
            case "MixedTypeAnnotation":
            case "EmptyTypeAnnotation":
            case "NumberTypeAnnotation":
            case "StringTypeAnnotation":
            case "SymbolTypeAnnotation":
            case "ThisTypeAnnotation":
            case "VoidTypeAnnotation":
              break;
            default:
              return false;
          }
          return null == t3 || (0, r2.default)(e3, t3);
        }, t2.isFlowDeclaration = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "DeclareClass":
            case "DeclareFunction":
            case "DeclareInterface":
            case "DeclareModule":
            case "DeclareModuleExports":
            case "DeclareTypeAlias":
            case "DeclareOpaqueType":
            case "DeclareVariable":
            case "DeclareExportDeclaration":
            case "DeclareExportAllDeclaration":
            case "InterfaceDeclaration":
            case "OpaqueType":
            case "TypeAlias":
              break;
            default:
              return false;
          }
          return null == t3 || (0, r2.default)(e3, t3);
        }, t2.isFlowPredicate = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "DeclaredPredicate":
            case "InferredPredicate":
              break;
            default:
              return false;
          }
          return null == t3 || (0, r2.default)(e3, t3);
        }, t2.isFlowType = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "AnyTypeAnnotation":
            case "ArrayTypeAnnotation":
            case "BooleanTypeAnnotation":
            case "BooleanLiteralTypeAnnotation":
            case "NullLiteralTypeAnnotation":
            case "ExistsTypeAnnotation":
            case "FunctionTypeAnnotation":
            case "GenericTypeAnnotation":
            case "InterfaceTypeAnnotation":
            case "IntersectionTypeAnnotation":
            case "MixedTypeAnnotation":
            case "EmptyTypeAnnotation":
            case "NullableTypeAnnotation":
            case "NumberLiteralTypeAnnotation":
            case "NumberTypeAnnotation":
            case "ObjectTypeAnnotation":
            case "StringLiteralTypeAnnotation":
            case "StringTypeAnnotation":
            case "SymbolTypeAnnotation":
            case "ThisTypeAnnotation":
            case "TupleTypeAnnotation":
            case "TypeofTypeAnnotation":
            case "UnionTypeAnnotation":
            case "VoidTypeAnnotation":
            case "IndexedAccessType":
            case "OptionalIndexedAccessType":
              break;
            default:
              return false;
          }
          return null == t3 || (0, r2.default)(e3, t3);
        }, t2.isFor = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "ForInStatement":
            case "ForStatement":
            case "ForOfStatement":
              break;
            default:
              return false;
          }
          return null == t3 || (0, r2.default)(e3, t3);
        }, t2.isForInStatement = function(e3, t3) {
          return !!e3 && "ForInStatement" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isForOfStatement = function(e3, t3) {
          return !!e3 && "ForOfStatement" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isForStatement = function(e3, t3) {
          return !!e3 && "ForStatement" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isForXStatement = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "ForInStatement":
            case "ForOfStatement":
              break;
            default:
              return false;
          }
          return null == t3 || (0, r2.default)(e3, t3);
        }, t2.isFunction = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ObjectMethod":
            case "ArrowFunctionExpression":
            case "ClassMethod":
            case "ClassPrivateMethod":
              break;
            default:
              return false;
          }
          return null == t3 || (0, r2.default)(e3, t3);
        }, t2.isFunctionDeclaration = function(e3, t3) {
          return !!e3 && "FunctionDeclaration" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isFunctionExpression = function(e3, t3) {
          return !!e3 && "FunctionExpression" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isFunctionParent = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ObjectMethod":
            case "ArrowFunctionExpression":
            case "ClassMethod":
            case "ClassPrivateMethod":
            case "StaticBlock":
            case "TSModuleBlock":
              break;
            default:
              return false;
          }
          return null == t3 || (0, r2.default)(e3, t3);
        }, t2.isFunctionTypeAnnotation = function(e3, t3) {
          return !!e3 && "FunctionTypeAnnotation" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isFunctionTypeParam = function(e3, t3) {
          return !!e3 && "FunctionTypeParam" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isGenericTypeAnnotation = function(e3, t3) {
          return !!e3 && "GenericTypeAnnotation" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isIdentifier = function(e3, t3) {
          return !!e3 && "Identifier" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isIfStatement = function(e3, t3) {
          return !!e3 && "IfStatement" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isImmutable = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "StringLiteral":
            case "NumericLiteral":
            case "NullLiteral":
            case "BooleanLiteral":
            case "BigIntLiteral":
            case "JSXAttribute":
            case "JSXClosingElement":
            case "JSXElement":
            case "JSXExpressionContainer":
            case "JSXSpreadChild":
            case "JSXOpeningElement":
            case "JSXText":
            case "JSXFragment":
            case "JSXOpeningFragment":
            case "JSXClosingFragment":
            case "DecimalLiteral":
              break;
            case "Placeholder":
              if ("StringLiteral" === e3.expectedNode) break;
            default:
              return false;
          }
          return null == t3 || (0, r2.default)(e3, t3);
        }, t2.isImport = function(e3, t3) {
          return !!e3 && "Import" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isImportAttribute = function(e3, t3) {
          return !!e3 && "ImportAttribute" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isImportDeclaration = function(e3, t3) {
          return !!e3 && "ImportDeclaration" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isImportDefaultSpecifier = function(e3, t3) {
          return !!e3 && "ImportDefaultSpecifier" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isImportNamespaceSpecifier = function(e3, t3) {
          return !!e3 && "ImportNamespaceSpecifier" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isImportOrExportDeclaration = s, t2.isImportSpecifier = function(e3, t3) {
          return !!e3 && "ImportSpecifier" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isIndexedAccessType = function(e3, t3) {
          return !!e3 && "IndexedAccessType" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isInferredPredicate = function(e3, t3) {
          return !!e3 && "InferredPredicate" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isInterfaceDeclaration = function(e3, t3) {
          return !!e3 && "InterfaceDeclaration" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isInterfaceExtends = function(e3, t3) {
          return !!e3 && "InterfaceExtends" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isInterfaceTypeAnnotation = function(e3, t3) {
          return !!e3 && "InterfaceTypeAnnotation" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isInterpreterDirective = function(e3, t3) {
          return !!e3 && "InterpreterDirective" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isIntersectionTypeAnnotation = function(e3, t3) {
          return !!e3 && "IntersectionTypeAnnotation" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isJSX = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "JSXAttribute":
            case "JSXClosingElement":
            case "JSXElement":
            case "JSXEmptyExpression":
            case "JSXExpressionContainer":
            case "JSXSpreadChild":
            case "JSXIdentifier":
            case "JSXMemberExpression":
            case "JSXNamespacedName":
            case "JSXOpeningElement":
            case "JSXSpreadAttribute":
            case "JSXText":
            case "JSXFragment":
            case "JSXOpeningFragment":
            case "JSXClosingFragment":
              break;
            default:
              return false;
          }
          return null == t3 || (0, r2.default)(e3, t3);
        }, t2.isJSXAttribute = function(e3, t3) {
          return !!e3 && "JSXAttribute" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isJSXClosingElement = function(e3, t3) {
          return !!e3 && "JSXClosingElement" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isJSXClosingFragment = function(e3, t3) {
          return !!e3 && "JSXClosingFragment" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isJSXElement = function(e3, t3) {
          return !!e3 && "JSXElement" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isJSXEmptyExpression = function(e3, t3) {
          return !!e3 && "JSXEmptyExpression" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isJSXExpressionContainer = function(e3, t3) {
          return !!e3 && "JSXExpressionContainer" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isJSXFragment = function(e3, t3) {
          return !!e3 && "JSXFragment" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isJSXIdentifier = function(e3, t3) {
          return !!e3 && "JSXIdentifier" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isJSXMemberExpression = function(e3, t3) {
          return !!e3 && "JSXMemberExpression" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isJSXNamespacedName = function(e3, t3) {
          return !!e3 && "JSXNamespacedName" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isJSXOpeningElement = function(e3, t3) {
          return !!e3 && "JSXOpeningElement" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isJSXOpeningFragment = function(e3, t3) {
          return !!e3 && "JSXOpeningFragment" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isJSXSpreadAttribute = function(e3, t3) {
          return !!e3 && "JSXSpreadAttribute" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isJSXSpreadChild = function(e3, t3) {
          return !!e3 && "JSXSpreadChild" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isJSXText = function(e3, t3) {
          return !!e3 && "JSXText" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isLVal = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "Identifier":
            case "MemberExpression":
            case "RestElement":
            case "AssignmentPattern":
            case "ArrayPattern":
            case "ObjectPattern":
            case "TSParameterProperty":
            case "TSAsExpression":
            case "TSSatisfiesExpression":
            case "TSTypeAssertion":
            case "TSNonNullExpression":
              break;
            case "Placeholder":
              switch (e3.expectedNode) {
                case "Pattern":
                case "Identifier":
                  break;
                default:
                  return false;
              }
              break;
            default:
              return false;
          }
          return null == t3 || (0, r2.default)(e3, t3);
        }, t2.isLabeledStatement = function(e3, t3) {
          return !!e3 && "LabeledStatement" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isLiteral = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "StringLiteral":
            case "NumericLiteral":
            case "NullLiteral":
            case "BooleanLiteral":
            case "RegExpLiteral":
            case "TemplateLiteral":
            case "BigIntLiteral":
            case "DecimalLiteral":
              break;
            case "Placeholder":
              if ("StringLiteral" === e3.expectedNode) break;
            default:
              return false;
          }
          return null == t3 || (0, r2.default)(e3, t3);
        }, t2.isLogicalExpression = function(e3, t3) {
          return !!e3 && "LogicalExpression" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isLoop = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "DoWhileStatement":
            case "ForInStatement":
            case "ForStatement":
            case "WhileStatement":
            case "ForOfStatement":
              break;
            default:
              return false;
          }
          return null == t3 || (0, r2.default)(e3, t3);
        }, t2.isMemberExpression = function(e3, t3) {
          return !!e3 && "MemberExpression" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isMetaProperty = function(e3, t3) {
          return !!e3 && "MetaProperty" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isMethod = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "ObjectMethod":
            case "ClassMethod":
            case "ClassPrivateMethod":
              break;
            default:
              return false;
          }
          return null == t3 || (0, r2.default)(e3, t3);
        }, t2.isMiscellaneous = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "Noop":
            case "Placeholder":
            case "V8IntrinsicIdentifier":
              break;
            default:
              return false;
          }
          return null == t3 || (0, r2.default)(e3, t3);
        }, t2.isMixedTypeAnnotation = function(e3, t3) {
          return !!e3 && "MixedTypeAnnotation" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isModuleDeclaration = function(e3, t3) {
          return (0, i.default)("isModuleDeclaration", "isImportOrExportDeclaration"), s(e3, t3);
        }, t2.isModuleExpression = function(e3, t3) {
          return !!e3 && "ModuleExpression" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isModuleSpecifier = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "ExportSpecifier":
            case "ImportDefaultSpecifier":
            case "ImportNamespaceSpecifier":
            case "ImportSpecifier":
            case "ExportNamespaceSpecifier":
            case "ExportDefaultSpecifier":
              break;
            default:
              return false;
          }
          return null == t3 || (0, r2.default)(e3, t3);
        }, t2.isNewExpression = function(e3, t3) {
          return !!e3 && "NewExpression" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isNoop = function(e3, t3) {
          return !!e3 && "Noop" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isNullLiteral = function(e3, t3) {
          return !!e3 && "NullLiteral" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isNullLiteralTypeAnnotation = function(e3, t3) {
          return !!e3 && "NullLiteralTypeAnnotation" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isNullableTypeAnnotation = function(e3, t3) {
          return !!e3 && "NullableTypeAnnotation" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isNumberLiteral = function(e3, t3) {
          return (0, i.default)("isNumberLiteral", "isNumericLiteral"), !!e3 && "NumberLiteral" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isNumberLiteralTypeAnnotation = function(e3, t3) {
          return !!e3 && "NumberLiteralTypeAnnotation" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isNumberTypeAnnotation = function(e3, t3) {
          return !!e3 && "NumberTypeAnnotation" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isNumericLiteral = function(e3, t3) {
          return !!e3 && "NumericLiteral" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isObjectExpression = function(e3, t3) {
          return !!e3 && "ObjectExpression" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isObjectMember = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "ObjectMethod":
            case "ObjectProperty":
              break;
            default:
              return false;
          }
          return null == t3 || (0, r2.default)(e3, t3);
        }, t2.isObjectMethod = function(e3, t3) {
          return !!e3 && "ObjectMethod" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isObjectPattern = function(e3, t3) {
          return !!e3 && "ObjectPattern" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isObjectProperty = function(e3, t3) {
          return !!e3 && "ObjectProperty" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isObjectTypeAnnotation = function(e3, t3) {
          return !!e3 && "ObjectTypeAnnotation" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isObjectTypeCallProperty = function(e3, t3) {
          return !!e3 && "ObjectTypeCallProperty" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isObjectTypeIndexer = function(e3, t3) {
          return !!e3 && "ObjectTypeIndexer" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isObjectTypeInternalSlot = function(e3, t3) {
          return !!e3 && "ObjectTypeInternalSlot" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isObjectTypeProperty = function(e3, t3) {
          return !!e3 && "ObjectTypeProperty" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isObjectTypeSpreadProperty = function(e3, t3) {
          return !!e3 && "ObjectTypeSpreadProperty" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isOpaqueType = function(e3, t3) {
          return !!e3 && "OpaqueType" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isOptionalCallExpression = function(e3, t3) {
          return !!e3 && "OptionalCallExpression" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isOptionalIndexedAccessType = function(e3, t3) {
          return !!e3 && "OptionalIndexedAccessType" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isOptionalMemberExpression = function(e3, t3) {
          return !!e3 && "OptionalMemberExpression" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isParenthesizedExpression = function(e3, t3) {
          return !!e3 && "ParenthesizedExpression" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isPattern = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "AssignmentPattern":
            case "ArrayPattern":
            case "ObjectPattern":
              break;
            case "Placeholder":
              if ("Pattern" === e3.expectedNode) break;
            default:
              return false;
          }
          return null == t3 || (0, r2.default)(e3, t3);
        }, t2.isPatternLike = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "Identifier":
            case "RestElement":
            case "AssignmentPattern":
            case "ArrayPattern":
            case "ObjectPattern":
            case "TSAsExpression":
            case "TSSatisfiesExpression":
            case "TSTypeAssertion":
            case "TSNonNullExpression":
              break;
            case "Placeholder":
              switch (e3.expectedNode) {
                case "Pattern":
                case "Identifier":
                  break;
                default:
                  return false;
              }
              break;
            default:
              return false;
          }
          return null == t3 || (0, r2.default)(e3, t3);
        }, t2.isPipelineBareFunction = function(e3, t3) {
          return !!e3 && "PipelineBareFunction" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isPipelinePrimaryTopicReference = function(e3, t3) {
          return !!e3 && "PipelinePrimaryTopicReference" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isPipelineTopicExpression = function(e3, t3) {
          return !!e3 && "PipelineTopicExpression" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isPlaceholder = function(e3, t3) {
          return !!e3 && "Placeholder" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isPrivate = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "ClassPrivateProperty":
            case "ClassPrivateMethod":
            case "PrivateName":
              break;
            default:
              return false;
          }
          return null == t3 || (0, r2.default)(e3, t3);
        }, t2.isPrivateName = function(e3, t3) {
          return !!e3 && "PrivateName" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isProgram = function(e3, t3) {
          return !!e3 && "Program" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isProperty = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "ObjectProperty":
            case "ClassProperty":
            case "ClassAccessorProperty":
            case "ClassPrivateProperty":
              break;
            default:
              return false;
          }
          return null == t3 || (0, r2.default)(e3, t3);
        }, t2.isPureish = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "StringLiteral":
            case "NumericLiteral":
            case "NullLiteral":
            case "BooleanLiteral":
            case "RegExpLiteral":
            case "ArrowFunctionExpression":
            case "BigIntLiteral":
            case "DecimalLiteral":
              break;
            case "Placeholder":
              if ("StringLiteral" === e3.expectedNode) break;
            default:
              return false;
          }
          return null == t3 || (0, r2.default)(e3, t3);
        }, t2.isQualifiedTypeIdentifier = function(e3, t3) {
          return !!e3 && "QualifiedTypeIdentifier" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isRecordExpression = function(e3, t3) {
          return !!e3 && "RecordExpression" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isRegExpLiteral = function(e3, t3) {
          return !!e3 && "RegExpLiteral" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isRegexLiteral = function(e3, t3) {
          return (0, i.default)("isRegexLiteral", "isRegExpLiteral"), !!e3 && "RegexLiteral" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isRestElement = function(e3, t3) {
          return !!e3 && "RestElement" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isRestProperty = function(e3, t3) {
          return (0, i.default)("isRestProperty", "isRestElement"), !!e3 && "RestProperty" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isReturnStatement = function(e3, t3) {
          return !!e3 && "ReturnStatement" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isScopable = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "BlockStatement":
            case "CatchClause":
            case "DoWhileStatement":
            case "ForInStatement":
            case "ForStatement":
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "Program":
            case "ObjectMethod":
            case "SwitchStatement":
            case "WhileStatement":
            case "ArrowFunctionExpression":
            case "ClassExpression":
            case "ClassDeclaration":
            case "ForOfStatement":
            case "ClassMethod":
            case "ClassPrivateMethod":
            case "StaticBlock":
            case "TSModuleBlock":
              break;
            case "Placeholder":
              if ("BlockStatement" === e3.expectedNode) break;
            default:
              return false;
          }
          return null == t3 || (0, r2.default)(e3, t3);
        }, t2.isSequenceExpression = function(e3, t3) {
          return !!e3 && "SequenceExpression" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isSpreadElement = function(e3, t3) {
          return !!e3 && "SpreadElement" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isSpreadProperty = function(e3, t3) {
          return (0, i.default)("isSpreadProperty", "isSpreadElement"), !!e3 && "SpreadProperty" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isStandardized = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "ArrayExpression":
            case "AssignmentExpression":
            case "BinaryExpression":
            case "InterpreterDirective":
            case "Directive":
            case "DirectiveLiteral":
            case "BlockStatement":
            case "BreakStatement":
            case "CallExpression":
            case "CatchClause":
            case "ConditionalExpression":
            case "ContinueStatement":
            case "DebuggerStatement":
            case "DoWhileStatement":
            case "EmptyStatement":
            case "ExpressionStatement":
            case "File":
            case "ForInStatement":
            case "ForStatement":
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "Identifier":
            case "IfStatement":
            case "LabeledStatement":
            case "StringLiteral":
            case "NumericLiteral":
            case "NullLiteral":
            case "BooleanLiteral":
            case "RegExpLiteral":
            case "LogicalExpression":
            case "MemberExpression":
            case "NewExpression":
            case "Program":
            case "ObjectExpression":
            case "ObjectMethod":
            case "ObjectProperty":
            case "RestElement":
            case "ReturnStatement":
            case "SequenceExpression":
            case "ParenthesizedExpression":
            case "SwitchCase":
            case "SwitchStatement":
            case "ThisExpression":
            case "ThrowStatement":
            case "TryStatement":
            case "UnaryExpression":
            case "UpdateExpression":
            case "VariableDeclaration":
            case "VariableDeclarator":
            case "WhileStatement":
            case "WithStatement":
            case "AssignmentPattern":
            case "ArrayPattern":
            case "ArrowFunctionExpression":
            case "ClassBody":
            case "ClassExpression":
            case "ClassDeclaration":
            case "ExportAllDeclaration":
            case "ExportDefaultDeclaration":
            case "ExportNamedDeclaration":
            case "ExportSpecifier":
            case "ForOfStatement":
            case "ImportDeclaration":
            case "ImportDefaultSpecifier":
            case "ImportNamespaceSpecifier":
            case "ImportSpecifier":
            case "MetaProperty":
            case "ClassMethod":
            case "ObjectPattern":
            case "SpreadElement":
            case "Super":
            case "TaggedTemplateExpression":
            case "TemplateElement":
            case "TemplateLiteral":
            case "YieldExpression":
            case "AwaitExpression":
            case "Import":
            case "BigIntLiteral":
            case "ExportNamespaceSpecifier":
            case "OptionalMemberExpression":
            case "OptionalCallExpression":
            case "ClassProperty":
            case "ClassAccessorProperty":
            case "ClassPrivateProperty":
            case "ClassPrivateMethod":
            case "PrivateName":
            case "StaticBlock":
              break;
            case "Placeholder":
              switch (e3.expectedNode) {
                case "Identifier":
                case "StringLiteral":
                case "BlockStatement":
                case "ClassBody":
                  break;
                default:
                  return false;
              }
              break;
            default:
              return false;
          }
          return null == t3 || (0, r2.default)(e3, t3);
        }, t2.isStatement = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "BlockStatement":
            case "BreakStatement":
            case "ContinueStatement":
            case "DebuggerStatement":
            case "DoWhileStatement":
            case "EmptyStatement":
            case "ExpressionStatement":
            case "ForInStatement":
            case "ForStatement":
            case "FunctionDeclaration":
            case "IfStatement":
            case "LabeledStatement":
            case "ReturnStatement":
            case "SwitchStatement":
            case "ThrowStatement":
            case "TryStatement":
            case "VariableDeclaration":
            case "WhileStatement":
            case "WithStatement":
            case "ClassDeclaration":
            case "ExportAllDeclaration":
            case "ExportDefaultDeclaration":
            case "ExportNamedDeclaration":
            case "ForOfStatement":
            case "ImportDeclaration":
            case "DeclareClass":
            case "DeclareFunction":
            case "DeclareInterface":
            case "DeclareModule":
            case "DeclareModuleExports":
            case "DeclareTypeAlias":
            case "DeclareOpaqueType":
            case "DeclareVariable":
            case "DeclareExportDeclaration":
            case "DeclareExportAllDeclaration":
            case "InterfaceDeclaration":
            case "OpaqueType":
            case "TypeAlias":
            case "EnumDeclaration":
            case "TSDeclareFunction":
            case "TSInterfaceDeclaration":
            case "TSTypeAliasDeclaration":
            case "TSEnumDeclaration":
            case "TSModuleDeclaration":
            case "TSImportEqualsDeclaration":
            case "TSExportAssignment":
            case "TSNamespaceExportDeclaration":
              break;
            case "Placeholder":
              switch (e3.expectedNode) {
                case "Statement":
                case "Declaration":
                case "BlockStatement":
                  break;
                default:
                  return false;
              }
              break;
            default:
              return false;
          }
          return null == t3 || (0, r2.default)(e3, t3);
        }, t2.isStaticBlock = function(e3, t3) {
          return !!e3 && "StaticBlock" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isStringLiteral = function(e3, t3) {
          return !!e3 && "StringLiteral" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isStringLiteralTypeAnnotation = function(e3, t3) {
          return !!e3 && "StringLiteralTypeAnnotation" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isStringTypeAnnotation = function(e3, t3) {
          return !!e3 && "StringTypeAnnotation" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isSuper = function(e3, t3) {
          return !!e3 && "Super" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isSwitchCase = function(e3, t3) {
          return !!e3 && "SwitchCase" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isSwitchStatement = function(e3, t3) {
          return !!e3 && "SwitchStatement" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isSymbolTypeAnnotation = function(e3, t3) {
          return !!e3 && "SymbolTypeAnnotation" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSAnyKeyword = function(e3, t3) {
          return !!e3 && "TSAnyKeyword" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSArrayType = function(e3, t3) {
          return !!e3 && "TSArrayType" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSAsExpression = function(e3, t3) {
          return !!e3 && "TSAsExpression" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSBaseType = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "TSAnyKeyword":
            case "TSBooleanKeyword":
            case "TSBigIntKeyword":
            case "TSIntrinsicKeyword":
            case "TSNeverKeyword":
            case "TSNullKeyword":
            case "TSNumberKeyword":
            case "TSObjectKeyword":
            case "TSStringKeyword":
            case "TSSymbolKeyword":
            case "TSUndefinedKeyword":
            case "TSUnknownKeyword":
            case "TSVoidKeyword":
            case "TSThisType":
            case "TSLiteralType":
              break;
            default:
              return false;
          }
          return null == t3 || (0, r2.default)(e3, t3);
        }, t2.isTSBigIntKeyword = function(e3, t3) {
          return !!e3 && "TSBigIntKeyword" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSBooleanKeyword = function(e3, t3) {
          return !!e3 && "TSBooleanKeyword" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSCallSignatureDeclaration = function(e3, t3) {
          return !!e3 && "TSCallSignatureDeclaration" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSConditionalType = function(e3, t3) {
          return !!e3 && "TSConditionalType" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSConstructSignatureDeclaration = function(e3, t3) {
          return !!e3 && "TSConstructSignatureDeclaration" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSConstructorType = function(e3, t3) {
          return !!e3 && "TSConstructorType" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSDeclareFunction = function(e3, t3) {
          return !!e3 && "TSDeclareFunction" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSDeclareMethod = function(e3, t3) {
          return !!e3 && "TSDeclareMethod" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSEntityName = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "Identifier":
            case "TSQualifiedName":
              break;
            case "Placeholder":
              if ("Identifier" === e3.expectedNode) break;
            default:
              return false;
          }
          return null == t3 || (0, r2.default)(e3, t3);
        }, t2.isTSEnumDeclaration = function(e3, t3) {
          return !!e3 && "TSEnumDeclaration" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSEnumMember = function(e3, t3) {
          return !!e3 && "TSEnumMember" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSExportAssignment = function(e3, t3) {
          return !!e3 && "TSExportAssignment" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSExpressionWithTypeArguments = function(e3, t3) {
          return !!e3 && "TSExpressionWithTypeArguments" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSExternalModuleReference = function(e3, t3) {
          return !!e3 && "TSExternalModuleReference" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSFunctionType = function(e3, t3) {
          return !!e3 && "TSFunctionType" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSImportEqualsDeclaration = function(e3, t3) {
          return !!e3 && "TSImportEqualsDeclaration" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSImportType = function(e3, t3) {
          return !!e3 && "TSImportType" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSIndexSignature = function(e3, t3) {
          return !!e3 && "TSIndexSignature" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSIndexedAccessType = function(e3, t3) {
          return !!e3 && "TSIndexedAccessType" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSInferType = function(e3, t3) {
          return !!e3 && "TSInferType" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSInstantiationExpression = function(e3, t3) {
          return !!e3 && "TSInstantiationExpression" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSInterfaceBody = function(e3, t3) {
          return !!e3 && "TSInterfaceBody" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSInterfaceDeclaration = function(e3, t3) {
          return !!e3 && "TSInterfaceDeclaration" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSIntersectionType = function(e3, t3) {
          return !!e3 && "TSIntersectionType" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSIntrinsicKeyword = function(e3, t3) {
          return !!e3 && "TSIntrinsicKeyword" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSLiteralType = function(e3, t3) {
          return !!e3 && "TSLiteralType" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSMappedType = function(e3, t3) {
          return !!e3 && "TSMappedType" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSMethodSignature = function(e3, t3) {
          return !!e3 && "TSMethodSignature" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSModuleBlock = function(e3, t3) {
          return !!e3 && "TSModuleBlock" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSModuleDeclaration = function(e3, t3) {
          return !!e3 && "TSModuleDeclaration" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSNamedTupleMember = function(e3, t3) {
          return !!e3 && "TSNamedTupleMember" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSNamespaceExportDeclaration = function(e3, t3) {
          return !!e3 && "TSNamespaceExportDeclaration" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSNeverKeyword = function(e3, t3) {
          return !!e3 && "TSNeverKeyword" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSNonNullExpression = function(e3, t3) {
          return !!e3 && "TSNonNullExpression" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSNullKeyword = function(e3, t3) {
          return !!e3 && "TSNullKeyword" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSNumberKeyword = function(e3, t3) {
          return !!e3 && "TSNumberKeyword" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSObjectKeyword = function(e3, t3) {
          return !!e3 && "TSObjectKeyword" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSOptionalType = function(e3, t3) {
          return !!e3 && "TSOptionalType" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSParameterProperty = function(e3, t3) {
          return !!e3 && "TSParameterProperty" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSParenthesizedType = function(e3, t3) {
          return !!e3 && "TSParenthesizedType" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSPropertySignature = function(e3, t3) {
          return !!e3 && "TSPropertySignature" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSQualifiedName = function(e3, t3) {
          return !!e3 && "TSQualifiedName" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSRestType = function(e3, t3) {
          return !!e3 && "TSRestType" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSSatisfiesExpression = function(e3, t3) {
          return !!e3 && "TSSatisfiesExpression" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSStringKeyword = function(e3, t3) {
          return !!e3 && "TSStringKeyword" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSSymbolKeyword = function(e3, t3) {
          return !!e3 && "TSSymbolKeyword" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSThisType = function(e3, t3) {
          return !!e3 && "TSThisType" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSTupleType = function(e3, t3) {
          return !!e3 && "TSTupleType" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSType = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "TSAnyKeyword":
            case "TSBooleanKeyword":
            case "TSBigIntKeyword":
            case "TSIntrinsicKeyword":
            case "TSNeverKeyword":
            case "TSNullKeyword":
            case "TSNumberKeyword":
            case "TSObjectKeyword":
            case "TSStringKeyword":
            case "TSSymbolKeyword":
            case "TSUndefinedKeyword":
            case "TSUnknownKeyword":
            case "TSVoidKeyword":
            case "TSThisType":
            case "TSFunctionType":
            case "TSConstructorType":
            case "TSTypeReference":
            case "TSTypePredicate":
            case "TSTypeQuery":
            case "TSTypeLiteral":
            case "TSArrayType":
            case "TSTupleType":
            case "TSOptionalType":
            case "TSRestType":
            case "TSUnionType":
            case "TSIntersectionType":
            case "TSConditionalType":
            case "TSInferType":
            case "TSParenthesizedType":
            case "TSTypeOperator":
            case "TSIndexedAccessType":
            case "TSMappedType":
            case "TSLiteralType":
            case "TSExpressionWithTypeArguments":
            case "TSImportType":
              break;
            default:
              return false;
          }
          return null == t3 || (0, r2.default)(e3, t3);
        }, t2.isTSTypeAliasDeclaration = function(e3, t3) {
          return !!e3 && "TSTypeAliasDeclaration" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSTypeAnnotation = function(e3, t3) {
          return !!e3 && "TSTypeAnnotation" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSTypeAssertion = function(e3, t3) {
          return !!e3 && "TSTypeAssertion" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSTypeElement = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "TSCallSignatureDeclaration":
            case "TSConstructSignatureDeclaration":
            case "TSPropertySignature":
            case "TSMethodSignature":
            case "TSIndexSignature":
              break;
            default:
              return false;
          }
          return null == t3 || (0, r2.default)(e3, t3);
        }, t2.isTSTypeLiteral = function(e3, t3) {
          return !!e3 && "TSTypeLiteral" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSTypeOperator = function(e3, t3) {
          return !!e3 && "TSTypeOperator" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSTypeParameter = function(e3, t3) {
          return !!e3 && "TSTypeParameter" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSTypeParameterDeclaration = function(e3, t3) {
          return !!e3 && "TSTypeParameterDeclaration" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSTypeParameterInstantiation = function(e3, t3) {
          return !!e3 && "TSTypeParameterInstantiation" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSTypePredicate = function(e3, t3) {
          return !!e3 && "TSTypePredicate" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSTypeQuery = function(e3, t3) {
          return !!e3 && "TSTypeQuery" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSTypeReference = function(e3, t3) {
          return !!e3 && "TSTypeReference" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSUndefinedKeyword = function(e3, t3) {
          return !!e3 && "TSUndefinedKeyword" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSUnionType = function(e3, t3) {
          return !!e3 && "TSUnionType" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSUnknownKeyword = function(e3, t3) {
          return !!e3 && "TSUnknownKeyword" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTSVoidKeyword = function(e3, t3) {
          return !!e3 && "TSVoidKeyword" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTaggedTemplateExpression = function(e3, t3) {
          return !!e3 && "TaggedTemplateExpression" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTemplateElement = function(e3, t3) {
          return !!e3 && "TemplateElement" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTemplateLiteral = function(e3, t3) {
          return !!e3 && "TemplateLiteral" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTerminatorless = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "BreakStatement":
            case "ContinueStatement":
            case "ReturnStatement":
            case "ThrowStatement":
            case "YieldExpression":
            case "AwaitExpression":
              break;
            default:
              return false;
          }
          return null == t3 || (0, r2.default)(e3, t3);
        }, t2.isThisExpression = function(e3, t3) {
          return !!e3 && "ThisExpression" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isThisTypeAnnotation = function(e3, t3) {
          return !!e3 && "ThisTypeAnnotation" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isThrowStatement = function(e3, t3) {
          return !!e3 && "ThrowStatement" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTopicReference = function(e3, t3) {
          return !!e3 && "TopicReference" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTryStatement = function(e3, t3) {
          return !!e3 && "TryStatement" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTupleExpression = function(e3, t3) {
          return !!e3 && "TupleExpression" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTupleTypeAnnotation = function(e3, t3) {
          return !!e3 && "TupleTypeAnnotation" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTypeAlias = function(e3, t3) {
          return !!e3 && "TypeAlias" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTypeAnnotation = function(e3, t3) {
          return !!e3 && "TypeAnnotation" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTypeCastExpression = function(e3, t3) {
          return !!e3 && "TypeCastExpression" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTypeParameter = function(e3, t3) {
          return !!e3 && "TypeParameter" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTypeParameterDeclaration = function(e3, t3) {
          return !!e3 && "TypeParameterDeclaration" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTypeParameterInstantiation = function(e3, t3) {
          return !!e3 && "TypeParameterInstantiation" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isTypeScript = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "TSParameterProperty":
            case "TSDeclareFunction":
            case "TSDeclareMethod":
            case "TSQualifiedName":
            case "TSCallSignatureDeclaration":
            case "TSConstructSignatureDeclaration":
            case "TSPropertySignature":
            case "TSMethodSignature":
            case "TSIndexSignature":
            case "TSAnyKeyword":
            case "TSBooleanKeyword":
            case "TSBigIntKeyword":
            case "TSIntrinsicKeyword":
            case "TSNeverKeyword":
            case "TSNullKeyword":
            case "TSNumberKeyword":
            case "TSObjectKeyword":
            case "TSStringKeyword":
            case "TSSymbolKeyword":
            case "TSUndefinedKeyword":
            case "TSUnknownKeyword":
            case "TSVoidKeyword":
            case "TSThisType":
            case "TSFunctionType":
            case "TSConstructorType":
            case "TSTypeReference":
            case "TSTypePredicate":
            case "TSTypeQuery":
            case "TSTypeLiteral":
            case "TSArrayType":
            case "TSTupleType":
            case "TSOptionalType":
            case "TSRestType":
            case "TSNamedTupleMember":
            case "TSUnionType":
            case "TSIntersectionType":
            case "TSConditionalType":
            case "TSInferType":
            case "TSParenthesizedType":
            case "TSTypeOperator":
            case "TSIndexedAccessType":
            case "TSMappedType":
            case "TSLiteralType":
            case "TSExpressionWithTypeArguments":
            case "TSInterfaceDeclaration":
            case "TSInterfaceBody":
            case "TSTypeAliasDeclaration":
            case "TSInstantiationExpression":
            case "TSAsExpression":
            case "TSSatisfiesExpression":
            case "TSTypeAssertion":
            case "TSEnumDeclaration":
            case "TSEnumMember":
            case "TSModuleDeclaration":
            case "TSModuleBlock":
            case "TSImportType":
            case "TSImportEqualsDeclaration":
            case "TSExternalModuleReference":
            case "TSNonNullExpression":
            case "TSExportAssignment":
            case "TSNamespaceExportDeclaration":
            case "TSTypeAnnotation":
            case "TSTypeParameterInstantiation":
            case "TSTypeParameterDeclaration":
            case "TSTypeParameter":
              break;
            default:
              return false;
          }
          return null == t3 || (0, r2.default)(e3, t3);
        }, t2.isTypeofTypeAnnotation = function(e3, t3) {
          return !!e3 && "TypeofTypeAnnotation" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isUnaryExpression = function(e3, t3) {
          return !!e3 && "UnaryExpression" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isUnaryLike = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "UnaryExpression":
            case "SpreadElement":
              break;
            default:
              return false;
          }
          return null == t3 || (0, r2.default)(e3, t3);
        }, t2.isUnionTypeAnnotation = function(e3, t3) {
          return !!e3 && "UnionTypeAnnotation" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isUpdateExpression = function(e3, t3) {
          return !!e3 && "UpdateExpression" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isUserWhitespacable = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "ObjectMethod":
            case "ObjectProperty":
            case "ObjectTypeInternalSlot":
            case "ObjectTypeCallProperty":
            case "ObjectTypeIndexer":
            case "ObjectTypeProperty":
            case "ObjectTypeSpreadProperty":
              break;
            default:
              return false;
          }
          return null == t3 || (0, r2.default)(e3, t3);
        }, t2.isV8IntrinsicIdentifier = function(e3, t3) {
          return !!e3 && "V8IntrinsicIdentifier" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isVariableDeclaration = function(e3, t3) {
          return !!e3 && "VariableDeclaration" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isVariableDeclarator = function(e3, t3) {
          return !!e3 && "VariableDeclarator" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isVariance = function(e3, t3) {
          return !!e3 && "Variance" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isVoidTypeAnnotation = function(e3, t3) {
          return !!e3 && "VoidTypeAnnotation" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isWhile = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "DoWhileStatement":
            case "WhileStatement":
              break;
            default:
              return false;
          }
          return null == t3 || (0, r2.default)(e3, t3);
        }, t2.isWhileStatement = function(e3, t3) {
          return !!e3 && "WhileStatement" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isWithStatement = function(e3, t3) {
          return !!e3 && "WithStatement" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        }, t2.isYieldExpression = function(e3, t3) {
          return !!e3 && "YieldExpression" === e3.type && (null == t3 || (0, r2.default)(e3, t3));
        };
        var r2 = n2(9960), i = n2(4619);
        function s(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "ExportAllDeclaration":
            case "ExportDefaultDeclaration":
            case "ExportNamedDeclaration":
            case "ImportDeclaration":
              break;
            default:
              return false;
          }
          return null == t3 || (0, r2.default)(e3, t3);
        }
      }, 5171: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, n3) {
          return !!t3 && ((0, i.default)(t3.type, e3) ? void 0 === n3 || (0, r2.default)(t3, n3) : !n3 && "Placeholder" === t3.type && e3 in a.FLIPPED_ALIAS_KEYS && (0, s.default)(t3.expectedNode, e3));
        };
        var r2 = n2(9960), i = n2(5179), s = n2(8894), a = n2(1678);
      }, 8443: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, n3) {
          if (n3 && "Identifier" === e3.type && "ObjectProperty" === t3.type && "ObjectExpression" === n3.type) return false;
          const i = r2.default.keys[t3.type];
          if (i) for (let n4 = 0; n4 < i.length; n4++) {
            const r3 = t3[i[n4]];
            if (Array.isArray(r3)) {
              if (r3.indexOf(e3) >= 0) return true;
            } else if (r3 === e3) return true;
          }
          return false;
        };
        var r2 = n2(984);
      }, 964: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
          return (0, r2.isFunctionDeclaration)(e3) || (0, r2.isClassDeclaration)(e3) || (0, i.default)(e3);
        };
        var r2 = n2(9869), i = n2(3066);
      }, 1689: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
          return !!(0, r2.default)(e3.type, "Immutable") || !!(0, i.isIdentifier)(e3) && "undefined" === e3.name;
        };
        var r2 = n2(5179), i = n2(9869);
      }, 3066: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
          return (0, r2.isVariableDeclaration)(e3) && ("var" !== e3.kind || e3[i.BLOCK_SCOPED_SYMBOL]);
        };
        var r2 = n2(9869), i = n2(3725);
      }, 4814: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
          return !(!e3 || !r2.VISITOR_KEYS[e3.type]);
        };
        var r2 = n2(1678);
      }, 7997: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function e3(t3, n3) {
          if ("object" != typeof t3 || "object" != typeof n3 || null == t3 || null == n3) return t3 === n3;
          if (t3.type !== n3.type) return false;
          const i = Object.keys(r2.NODE_FIELDS[t3.type] || t3.type), s = r2.VISITOR_KEYS[t3.type];
          for (const r3 of i) {
            const i2 = t3[r3], a = n3[r3];
            if (typeof i2 != typeof a) return false;
            if (null != i2 || null != a) {
              if (null == i2 || null == a) return false;
              if (Array.isArray(i2)) {
                if (!Array.isArray(a)) return false;
                if (i2.length !== a.length) return false;
                for (let t4 = 0; t4 < i2.length; t4++) if (!e3(i2[t4], a[t4])) return false;
              } else if ("object" != typeof i2 || null != s && s.includes(r3)) {
                if (!e3(i2, a)) return false;
              } else for (const e4 of Object.keys(i2)) if (i2[e4] !== a[e4]) return false;
            }
          }
          return true;
        };
        var r2 = n2(1678);
      }, 8894: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
          if (e3 === t3) return true;
          const n3 = r2.PLACEHOLDERS_ALIAS[e3];
          if (n3) {
            for (const e4 of n3) if (t3 === e4) return true;
          }
          return false;
        };
        var r2 = n2(1678);
      }, 3683: (e2, t2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, n2) {
          switch (t3.type) {
            case "MemberExpression":
            case "OptionalMemberExpression":
              return t3.property === e3 ? !!t3.computed : t3.object === e3;
            case "JSXMemberExpression":
              return t3.object === e3;
            case "VariableDeclarator":
              return t3.init === e3;
            case "ArrowFunctionExpression":
              return t3.body === e3;
            case "PrivateName":
            case "LabeledStatement":
            case "CatchClause":
            case "RestElement":
            case "BreakStatement":
            case "ContinueStatement":
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ExportNamespaceSpecifier":
            case "ExportDefaultSpecifier":
            case "ImportDefaultSpecifier":
            case "ImportNamespaceSpecifier":
            case "ImportSpecifier":
            case "ImportAttribute":
            case "JSXAttribute":
            case "ObjectPattern":
            case "ArrayPattern":
            case "MetaProperty":
              return false;
            case "ClassMethod":
            case "ClassPrivateMethod":
            case "ObjectMethod":
              return t3.key === e3 && !!t3.computed;
            case "ObjectProperty":
              return t3.key === e3 ? !!t3.computed : !n2 || "ObjectPattern" !== n2.type;
            case "ClassProperty":
            case "ClassAccessorProperty":
            case "TSPropertySignature":
              return t3.key !== e3 || !!t3.computed;
            case "ClassPrivateProperty":
            case "ObjectTypeProperty":
              return t3.key !== e3;
            case "ClassDeclaration":
            case "ClassExpression":
              return t3.superClass === e3;
            case "AssignmentExpression":
            case "AssignmentPattern":
              return t3.right === e3;
            case "ExportSpecifier":
              return (null == n2 || !n2.source) && t3.local === e3;
            case "TSEnumMember":
              return t3.id !== e3;
          }
          return true;
        };
      }, 2126: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
          return (!(0, r2.isBlockStatement)(e3) || !(0, r2.isFunction)(t3) && !(0, r2.isCatchClause)(t3)) && (!(!(0, r2.isPattern)(e3) || !(0, r2.isFunction)(t3) && !(0, r2.isCatchClause)(t3)) || (0, r2.isScopable)(e3));
        };
        var r2 = n2(9869);
      }, 8691: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
          return (0, r2.isImportDefaultSpecifier)(e3) || (0, r2.isIdentifier)(e3.imported || e3.exported, { name: "default" });
        };
        var r2 = n2(9869);
      }, 5179: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
          if (e3 === t3) return true;
          if (null == e3) return false;
          if (r2.ALIAS_KEYS[t3]) return false;
          const n3 = r2.FLIPPED_ALIAS_KEYS[t3];
          if (n3) {
            if (n3[0] === e3) return true;
            for (const t4 of n3) if (e3 === t4) return true;
          }
          return false;
        };
        var r2 = n2(1678);
      }, 7879: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
          return (0, r2.default)(e3) && !i.has(e3);
        };
        var r2 = n2(5820);
        const i = /* @__PURE__ */ new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile"]);
      }, 5820: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3 = true) {
          return "string" == typeof e3 && ((!t3 || !(0, r2.isKeyword)(e3) && !(0, r2.isStrictReservedWord)(e3, true)) && (0, r2.isIdentifierName)(e3));
        };
        var r2 = n2(9649);
      }, 3358: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
          return (0, r2.isVariableDeclaration)(e3, { kind: "var" }) && !e3[i.BLOCK_SCOPED_SYMBOL];
        };
        var r2 = n2(9869), i = n2(3725);
      }, 2693: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, n3) {
          if (!(0, r2.isMemberExpression)(e3)) return false;
          const i = Array.isArray(t3) ? t3 : t3.split("."), s = [];
          let a;
          for (a = e3; (0, r2.isMemberExpression)(a); a = a.object) s.push(a.property);
          if (s.push(a), s.length < i.length) return false;
          if (!n3 && s.length > i.length) return false;
          for (let e4 = 0, t4 = s.length - 1; e4 < i.length; e4++, t4--) {
            const n4 = s[t4];
            let a2;
            if ((0, r2.isIdentifier)(n4)) a2 = n4.name;
            else if ((0, r2.isStringLiteral)(n4)) a2 = n4.value;
            else {
              if (!(0, r2.isThisExpression)(n4)) return false;
              a2 = "this";
            }
            if (i[e4] !== a2) return false;
          }
          return true;
        };
        var r2 = n2(9869);
      }, 9733: (e2, t2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
          return !!e3 && /^[a-z]/.test(e3);
        };
      }, 4229: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var r2 = (0, n2(2051).default)("React.Component");
        t2.default = r2;
      }, 7750: (e2, t2, n2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, n3) {
          if (!e3) return;
          const a = r2.NODE_FIELDS[e3.type];
          if (!a) return;
          i(e3, t3, n3, a[t3]), s(e3, t3, n3);
        }, t2.validateChild = s, t2.validateField = i;
        var r2 = n2(1678);
        function i(e3, t3, n3, r3) {
          null != r3 && r3.validate && (r3.optional && null == n3 || r3.validate(e3, t3, n3));
        }
        function s(e3, t3, n3) {
          if (null == n3) return;
          const i2 = r2.NODE_PARENT_VALIDATIONS[n3.type];
          i2 && i2(e3, t3, n3);
        }
      }, 8487: (e2) => {
        "use strict";
        e2.exports = JSON.parse('{"builtin":{"Array":false,"ArrayBuffer":false,"Atomics":false,"BigInt":false,"BigInt64Array":false,"BigUint64Array":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"globalThis":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"SharedArrayBuffer":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"es5":{"Array":false,"Boolean":false,"constructor":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"propertyIsEnumerable":false,"RangeError":false,"ReferenceError":false,"RegExp":false,"String":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false},"es2015":{"Array":false,"ArrayBuffer":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"es2017":{"Array":false,"ArrayBuffer":false,"Atomics":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"SharedArrayBuffer":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"browser":{"AbortController":false,"AbortSignal":false,"addEventListener":false,"alert":false,"AnalyserNode":false,"Animation":false,"AnimationEffectReadOnly":false,"AnimationEffectTiming":false,"AnimationEffectTimingReadOnly":false,"AnimationEvent":false,"AnimationPlaybackEvent":false,"AnimationTimeline":false,"applicationCache":false,"ApplicationCache":false,"ApplicationCacheErrorEvent":false,"atob":false,"Attr":false,"Audio":false,"AudioBuffer":false,"AudioBufferSourceNode":false,"AudioContext":false,"AudioDestinationNode":false,"AudioListener":false,"AudioNode":false,"AudioParam":false,"AudioProcessingEvent":false,"AudioScheduledSourceNode":false,"AudioWorkletGlobalScope ":false,"AudioWorkletNode":false,"AudioWorkletProcessor":false,"BarProp":false,"BaseAudioContext":false,"BatteryManager":false,"BeforeUnloadEvent":false,"BiquadFilterNode":false,"Blob":false,"BlobEvent":false,"blur":false,"BroadcastChannel":false,"btoa":false,"BudgetService":false,"ByteLengthQueuingStrategy":false,"Cache":false,"caches":false,"CacheStorage":false,"cancelAnimationFrame":false,"cancelIdleCallback":false,"CanvasCaptureMediaStreamTrack":false,"CanvasGradient":false,"CanvasPattern":false,"CanvasRenderingContext2D":false,"ChannelMergerNode":false,"ChannelSplitterNode":false,"CharacterData":false,"clearInterval":false,"clearTimeout":false,"clientInformation":false,"ClipboardEvent":false,"close":false,"closed":false,"CloseEvent":false,"Comment":false,"CompositionEvent":false,"confirm":false,"console":false,"ConstantSourceNode":false,"ConvolverNode":false,"CountQueuingStrategy":false,"createImageBitmap":false,"Credential":false,"CredentialsContainer":false,"crypto":false,"Crypto":false,"CryptoKey":false,"CSS":false,"CSSConditionRule":false,"CSSFontFaceRule":false,"CSSGroupingRule":false,"CSSImportRule":false,"CSSKeyframeRule":false,"CSSKeyframesRule":false,"CSSMediaRule":false,"CSSNamespaceRule":false,"CSSPageRule":false,"CSSRule":false,"CSSRuleList":false,"CSSStyleDeclaration":false,"CSSStyleRule":false,"CSSStyleSheet":false,"CSSSupportsRule":false,"CustomElementRegistry":false,"customElements":false,"CustomEvent":false,"DataTransfer":false,"DataTransferItem":false,"DataTransferItemList":false,"defaultstatus":false,"defaultStatus":false,"DelayNode":false,"DeviceMotionEvent":false,"DeviceOrientationEvent":false,"devicePixelRatio":false,"dispatchEvent":false,"document":false,"Document":false,"DocumentFragment":false,"DocumentType":false,"DOMError":false,"DOMException":false,"DOMImplementation":false,"DOMMatrix":false,"DOMMatrixReadOnly":false,"DOMParser":false,"DOMPoint":false,"DOMPointReadOnly":false,"DOMQuad":false,"DOMRect":false,"DOMRectReadOnly":false,"DOMStringList":false,"DOMStringMap":false,"DOMTokenList":false,"DragEvent":false,"DynamicsCompressorNode":false,"Element":false,"ErrorEvent":false,"event":false,"Event":false,"EventSource":false,"EventTarget":false,"external":false,"fetch":false,"File":false,"FileList":false,"FileReader":false,"find":false,"focus":false,"FocusEvent":false,"FontFace":false,"FontFaceSetLoadEvent":false,"FormData":false,"frameElement":false,"frames":false,"GainNode":false,"Gamepad":false,"GamepadButton":false,"GamepadEvent":false,"getComputedStyle":false,"getSelection":false,"HashChangeEvent":false,"Headers":false,"history":false,"History":false,"HTMLAllCollection":false,"HTMLAnchorElement":false,"HTMLAreaElement":false,"HTMLAudioElement":false,"HTMLBaseElement":false,"HTMLBodyElement":false,"HTMLBRElement":false,"HTMLButtonElement":false,"HTMLCanvasElement":false,"HTMLCollection":false,"HTMLContentElement":false,"HTMLDataElement":false,"HTMLDataListElement":false,"HTMLDetailsElement":false,"HTMLDialogElement":false,"HTMLDirectoryElement":false,"HTMLDivElement":false,"HTMLDListElement":false,"HTMLDocument":false,"HTMLElement":false,"HTMLEmbedElement":false,"HTMLFieldSetElement":false,"HTMLFontElement":false,"HTMLFormControlsCollection":false,"HTMLFormElement":false,"HTMLFrameElement":false,"HTMLFrameSetElement":false,"HTMLHeadElement":false,"HTMLHeadingElement":false,"HTMLHRElement":false,"HTMLHtmlElement":false,"HTMLIFrameElement":false,"HTMLImageElement":false,"HTMLInputElement":false,"HTMLLabelElement":false,"HTMLLegendElement":false,"HTMLLIElement":false,"HTMLLinkElement":false,"HTMLMapElement":false,"HTMLMarqueeElement":false,"HTMLMediaElement":false,"HTMLMenuElement":false,"HTMLMetaElement":false,"HTMLMeterElement":false,"HTMLModElement":false,"HTMLObjectElement":false,"HTMLOListElement":false,"HTMLOptGroupElement":false,"HTMLOptionElement":false,"HTMLOptionsCollection":false,"HTMLOutputElement":false,"HTMLParagraphElement":false,"HTMLParamElement":false,"HTMLPictureElement":false,"HTMLPreElement":false,"HTMLProgressElement":false,"HTMLQuoteElement":false,"HTMLScriptElement":false,"HTMLSelectElement":false,"HTMLShadowElement":false,"HTMLSlotElement":false,"HTMLSourceElement":false,"HTMLSpanElement":false,"HTMLStyleElement":false,"HTMLTableCaptionElement":false,"HTMLTableCellElement":false,"HTMLTableColElement":false,"HTMLTableElement":false,"HTMLTableRowElement":false,"HTMLTableSectionElement":false,"HTMLTemplateElement":false,"HTMLTextAreaElement":false,"HTMLTimeElement":false,"HTMLTitleElement":false,"HTMLTrackElement":false,"HTMLUListElement":false,"HTMLUnknownElement":false,"HTMLVideoElement":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"IdleDeadline":false,"IIRFilterNode":false,"Image":false,"ImageBitmap":false,"ImageBitmapRenderingContext":false,"ImageCapture":false,"ImageData":false,"indexedDB":false,"innerHeight":false,"innerWidth":false,"InputEvent":false,"IntersectionObserver":false,"IntersectionObserverEntry":false,"Intl":false,"isSecureContext":false,"KeyboardEvent":false,"KeyframeEffect":false,"KeyframeEffectReadOnly":false,"length":false,"localStorage":false,"location":true,"Location":false,"locationbar":false,"matchMedia":false,"MediaDeviceInfo":false,"MediaDevices":false,"MediaElementAudioSourceNode":false,"MediaEncryptedEvent":false,"MediaError":false,"MediaKeyMessageEvent":false,"MediaKeySession":false,"MediaKeyStatusMap":false,"MediaKeySystemAccess":false,"MediaList":false,"MediaQueryList":false,"MediaQueryListEvent":false,"MediaRecorder":false,"MediaSettingsRange":false,"MediaSource":false,"MediaStream":false,"MediaStreamAudioDestinationNode":false,"MediaStreamAudioSourceNode":false,"MediaStreamEvent":false,"MediaStreamTrack":false,"MediaStreamTrackEvent":false,"menubar":false,"MessageChannel":false,"MessageEvent":false,"MessagePort":false,"MIDIAccess":false,"MIDIConnectionEvent":false,"MIDIInput":false,"MIDIInputMap":false,"MIDIMessageEvent":false,"MIDIOutput":false,"MIDIOutputMap":false,"MIDIPort":false,"MimeType":false,"MimeTypeArray":false,"MouseEvent":false,"moveBy":false,"moveTo":false,"MutationEvent":false,"MutationObserver":false,"MutationRecord":false,"name":false,"NamedNodeMap":false,"NavigationPreloadManager":false,"navigator":false,"Navigator":false,"NetworkInformation":false,"Node":false,"NodeFilter":false,"NodeIterator":false,"NodeList":false,"Notification":false,"OfflineAudioCompletionEvent":false,"OfflineAudioContext":false,"offscreenBuffering":false,"OffscreenCanvas":true,"onabort":true,"onafterprint":true,"onanimationend":true,"onanimationiteration":true,"onanimationstart":true,"onappinstalled":true,"onauxclick":true,"onbeforeinstallprompt":true,"onbeforeprint":true,"onbeforeunload":true,"onblur":true,"oncancel":true,"oncanplay":true,"oncanplaythrough":true,"onchange":true,"onclick":true,"onclose":true,"oncontextmenu":true,"oncuechange":true,"ondblclick":true,"ondevicemotion":true,"ondeviceorientation":true,"ondeviceorientationabsolute":true,"ondrag":true,"ondragend":true,"ondragenter":true,"ondragleave":true,"ondragover":true,"ondragstart":true,"ondrop":true,"ondurationchange":true,"onemptied":true,"onended":true,"onerror":true,"onfocus":true,"ongotpointercapture":true,"onhashchange":true,"oninput":true,"oninvalid":true,"onkeydown":true,"onkeypress":true,"onkeyup":true,"onlanguagechange":true,"onload":true,"onloadeddata":true,"onloadedmetadata":true,"onloadstart":true,"onlostpointercapture":true,"onmessage":true,"onmessageerror":true,"onmousedown":true,"onmouseenter":true,"onmouseleave":true,"onmousemove":true,"onmouseout":true,"onmouseover":true,"onmouseup":true,"onmousewheel":true,"onoffline":true,"ononline":true,"onpagehide":true,"onpageshow":true,"onpause":true,"onplay":true,"onplaying":true,"onpointercancel":true,"onpointerdown":true,"onpointerenter":true,"onpointerleave":true,"onpointermove":true,"onpointerout":true,"onpointerover":true,"onpointerup":true,"onpopstate":true,"onprogress":true,"onratechange":true,"onrejectionhandled":true,"onreset":true,"onresize":true,"onscroll":true,"onsearch":true,"onseeked":true,"onseeking":true,"onselect":true,"onstalled":true,"onstorage":true,"onsubmit":true,"onsuspend":true,"ontimeupdate":true,"ontoggle":true,"ontransitionend":true,"onunhandledrejection":true,"onunload":true,"onvolumechange":true,"onwaiting":true,"onwheel":true,"open":false,"openDatabase":false,"opener":false,"Option":false,"origin":false,"OscillatorNode":false,"outerHeight":false,"outerWidth":false,"PageTransitionEvent":false,"pageXOffset":false,"pageYOffset":false,"PannerNode":false,"parent":false,"Path2D":false,"PaymentAddress":false,"PaymentRequest":false,"PaymentRequestUpdateEvent":false,"PaymentResponse":false,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceLongTaskTiming":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceNavigationTiming":false,"PerformanceObserver":false,"PerformanceObserverEntryList":false,"PerformancePaintTiming":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"PeriodicWave":false,"Permissions":false,"PermissionStatus":false,"personalbar":false,"PhotoCapabilities":false,"Plugin":false,"PluginArray":false,"PointerEvent":false,"PopStateEvent":false,"postMessage":false,"Presentation":false,"PresentationAvailability":false,"PresentationConnection":false,"PresentationConnectionAvailableEvent":false,"PresentationConnectionCloseEvent":false,"PresentationConnectionList":false,"PresentationReceiver":false,"PresentationRequest":false,"print":false,"ProcessingInstruction":false,"ProgressEvent":false,"PromiseRejectionEvent":false,"prompt":false,"PushManager":false,"PushSubscription":false,"PushSubscriptionOptions":false,"queueMicrotask":false,"RadioNodeList":false,"Range":false,"ReadableStream":false,"registerProcessor":false,"RemotePlayback":false,"removeEventListener":false,"Request":false,"requestAnimationFrame":false,"requestIdleCallback":false,"resizeBy":false,"ResizeObserver":false,"ResizeObserverEntry":false,"resizeTo":false,"Response":false,"RTCCertificate":false,"RTCDataChannel":false,"RTCDataChannelEvent":false,"RTCDtlsTransport":false,"RTCIceCandidate":false,"RTCIceGatherer":false,"RTCIceTransport":false,"RTCPeerConnection":false,"RTCPeerConnectionIceEvent":false,"RTCRtpContributingSource":false,"RTCRtpReceiver":false,"RTCRtpSender":false,"RTCSctpTransport":false,"RTCSessionDescription":false,"RTCStatsReport":false,"RTCTrackEvent":false,"screen":false,"Screen":false,"screenLeft":false,"ScreenOrientation":false,"screenTop":false,"screenX":false,"screenY":false,"ScriptProcessorNode":false,"scroll":false,"scrollbars":false,"scrollBy":false,"scrollTo":false,"scrollX":false,"scrollY":false,"SecurityPolicyViolationEvent":false,"Selection":false,"self":false,"ServiceWorker":false,"ServiceWorkerContainer":false,"ServiceWorkerRegistration":false,"sessionStorage":false,"setInterval":false,"setTimeout":false,"ShadowRoot":false,"SharedWorker":false,"SourceBuffer":false,"SourceBufferList":false,"speechSynthesis":false,"SpeechSynthesisEvent":false,"SpeechSynthesisUtterance":false,"StaticRange":false,"status":false,"statusbar":false,"StereoPannerNode":false,"stop":false,"Storage":false,"StorageEvent":false,"StorageManager":false,"styleMedia":false,"StyleSheet":false,"StyleSheetList":false,"SubtleCrypto":false,"SVGAElement":false,"SVGAngle":false,"SVGAnimatedAngle":false,"SVGAnimatedBoolean":false,"SVGAnimatedEnumeration":false,"SVGAnimatedInteger":false,"SVGAnimatedLength":false,"SVGAnimatedLengthList":false,"SVGAnimatedNumber":false,"SVGAnimatedNumberList":false,"SVGAnimatedPreserveAspectRatio":false,"SVGAnimatedRect":false,"SVGAnimatedString":false,"SVGAnimatedTransformList":false,"SVGAnimateElement":false,"SVGAnimateMotionElement":false,"SVGAnimateTransformElement":false,"SVGAnimationElement":false,"SVGCircleElement":false,"SVGClipPathElement":false,"SVGComponentTransferFunctionElement":false,"SVGDefsElement":false,"SVGDescElement":false,"SVGDiscardElement":false,"SVGElement":false,"SVGEllipseElement":false,"SVGFEBlendElement":false,"SVGFEColorMatrixElement":false,"SVGFEComponentTransferElement":false,"SVGFECompositeElement":false,"SVGFEConvolveMatrixElement":false,"SVGFEDiffuseLightingElement":false,"SVGFEDisplacementMapElement":false,"SVGFEDistantLightElement":false,"SVGFEDropShadowElement":false,"SVGFEFloodElement":false,"SVGFEFuncAElement":false,"SVGFEFuncBElement":false,"SVGFEFuncGElement":false,"SVGFEFuncRElement":false,"SVGFEGaussianBlurElement":false,"SVGFEImageElement":false,"SVGFEMergeElement":false,"SVGFEMergeNodeElement":false,"SVGFEMorphologyElement":false,"SVGFEOffsetElement":false,"SVGFEPointLightElement":false,"SVGFESpecularLightingElement":false,"SVGFESpotLightElement":false,"SVGFETileElement":false,"SVGFETurbulenceElement":false,"SVGFilterElement":false,"SVGForeignObjectElement":false,"SVGGElement":false,"SVGGeometryElement":false,"SVGGradientElement":false,"SVGGraphicsElement":false,"SVGImageElement":false,"SVGLength":false,"SVGLengthList":false,"SVGLinearGradientElement":false,"SVGLineElement":false,"SVGMarkerElement":false,"SVGMaskElement":false,"SVGMatrix":false,"SVGMetadataElement":false,"SVGMPathElement":false,"SVGNumber":false,"SVGNumberList":false,"SVGPathElement":false,"SVGPatternElement":false,"SVGPoint":false,"SVGPointList":false,"SVGPolygonElement":false,"SVGPolylineElement":false,"SVGPreserveAspectRatio":false,"SVGRadialGradientElement":false,"SVGRect":false,"SVGRectElement":false,"SVGScriptElement":false,"SVGSetElement":false,"SVGStopElement":false,"SVGStringList":false,"SVGStyleElement":false,"SVGSVGElement":false,"SVGSwitchElement":false,"SVGSymbolElement":false,"SVGTextContentElement":false,"SVGTextElement":false,"SVGTextPathElement":false,"SVGTextPositioningElement":false,"SVGTitleElement":false,"SVGTransform":false,"SVGTransformList":false,"SVGTSpanElement":false,"SVGUnitTypes":false,"SVGUseElement":false,"SVGViewElement":false,"TaskAttributionTiming":false,"Text":false,"TextDecoder":false,"TextEncoder":false,"TextEvent":false,"TextMetrics":false,"TextTrack":false,"TextTrackCue":false,"TextTrackCueList":false,"TextTrackList":false,"TimeRanges":false,"toolbar":false,"top":false,"Touch":false,"TouchEvent":false,"TouchList":false,"TrackEvent":false,"TransitionEvent":false,"TreeWalker":false,"UIEvent":false,"URL":false,"URLSearchParams":false,"ValidityState":false,"visualViewport":false,"VisualViewport":false,"VTTCue":false,"WaveShaperNode":false,"WebAssembly":false,"WebGL2RenderingContext":false,"WebGLActiveInfo":false,"WebGLBuffer":false,"WebGLContextEvent":false,"WebGLFramebuffer":false,"WebGLProgram":false,"WebGLQuery":false,"WebGLRenderbuffer":false,"WebGLRenderingContext":false,"WebGLSampler":false,"WebGLShader":false,"WebGLShaderPrecisionFormat":false,"WebGLSync":false,"WebGLTexture":false,"WebGLTransformFeedback":false,"WebGLUniformLocation":false,"WebGLVertexArrayObject":false,"WebSocket":false,"WheelEvent":false,"window":false,"Window":false,"Worker":false,"WritableStream":false,"XMLDocument":false,"XMLHttpRequest":false,"XMLHttpRequestEventTarget":false,"XMLHttpRequestUpload":false,"XMLSerializer":false,"XPathEvaluator":false,"XPathExpression":false,"XPathResult":false,"XSLTProcessor":false},"worker":{"addEventListener":false,"applicationCache":false,"atob":false,"Blob":false,"BroadcastChannel":false,"btoa":false,"Cache":false,"caches":false,"clearInterval":false,"clearTimeout":false,"close":true,"console":false,"fetch":false,"FileReaderSync":false,"FormData":false,"Headers":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"ImageData":false,"importScripts":true,"indexedDB":false,"location":false,"MessageChannel":false,"MessagePort":false,"name":false,"navigator":false,"Notification":false,"onclose":true,"onconnect":true,"onerror":true,"onlanguagechange":true,"onmessage":true,"onoffline":true,"ononline":true,"onrejectionhandled":true,"onunhandledrejection":true,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"postMessage":true,"Promise":false,"queueMicrotask":false,"removeEventListener":false,"Request":false,"Response":false,"self":true,"ServiceWorkerRegistration":false,"setInterval":false,"setTimeout":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false,"WebSocket":false,"Worker":false,"WorkerGlobalScope":false,"XMLHttpRequest":false},"node":{"__dirname":false,"__filename":false,"Buffer":false,"clearImmediate":false,"clearInterval":false,"clearTimeout":false,"console":false,"exports":true,"global":false,"Intl":false,"module":false,"process":false,"queueMicrotask":false,"require":false,"setImmediate":false,"setInterval":false,"setTimeout":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false},"commonjs":{"exports":true,"global":false,"module":false,"require":false},"amd":{"define":false,"require":false},"mocha":{"after":false,"afterEach":false,"before":false,"beforeEach":false,"context":false,"describe":false,"it":false,"mocha":false,"run":false,"setup":false,"specify":false,"suite":false,"suiteSetup":false,"suiteTeardown":false,"teardown":false,"test":false,"xcontext":false,"xdescribe":false,"xit":false,"xspecify":false},"jasmine":{"afterAll":false,"afterEach":false,"beforeAll":false,"beforeEach":false,"describe":false,"expect":false,"fail":false,"fdescribe":false,"fit":false,"it":false,"jasmine":false,"pending":false,"runs":false,"spyOn":false,"spyOnProperty":false,"waits":false,"waitsFor":false,"xdescribe":false,"xit":false},"jest":{"afterAll":false,"afterEach":false,"beforeAll":false,"beforeEach":false,"describe":false,"expect":false,"fdescribe":false,"fit":false,"it":false,"jest":false,"pit":false,"require":false,"test":false,"xdescribe":false,"xit":false,"xtest":false},"qunit":{"asyncTest":false,"deepEqual":false,"equal":false,"expect":false,"module":false,"notDeepEqual":false,"notEqual":false,"notOk":false,"notPropEqual":false,"notStrictEqual":false,"ok":false,"propEqual":false,"QUnit":false,"raises":false,"start":false,"stop":false,"strictEqual":false,"test":false,"throws":false},"phantomjs":{"console":true,"exports":true,"phantom":true,"require":true,"WebPage":true},"couch":{"emit":false,"exports":false,"getRow":false,"log":false,"module":false,"provides":false,"require":false,"respond":false,"send":false,"start":false,"sum":false},"rhino":{"defineClass":false,"deserialize":false,"gc":false,"help":false,"importClass":false,"importPackage":false,"java":false,"load":false,"loadClass":false,"Packages":false,"print":false,"quit":false,"readFile":false,"readUrl":false,"runCommand":false,"seal":false,"serialize":false,"spawn":false,"sync":false,"toint32":false,"version":false},"nashorn":{"__DIR__":false,"__FILE__":false,"__LINE__":false,"com":false,"edu":false,"exit":false,"java":false,"Java":false,"javafx":false,"JavaImporter":false,"javax":false,"JSAdapter":false,"load":false,"loadWithNewGlobal":false,"org":false,"Packages":false,"print":false,"quit":false},"wsh":{"ActiveXObject":true,"Enumerator":true,"GetObject":true,"ScriptEngine":true,"ScriptEngineBuildVersion":true,"ScriptEngineMajorVersion":true,"ScriptEngineMinorVersion":true,"VBArray":true,"WScript":true,"WSH":true,"XDomainRequest":true},"jquery":{"$":false,"jQuery":false},"yui":{"YAHOO":false,"YAHOO_config":false,"YUI":false,"YUI_config":false},"shelljs":{"cat":false,"cd":false,"chmod":false,"config":false,"cp":false,"dirs":false,"echo":false,"env":false,"error":false,"exec":false,"exit":false,"find":false,"grep":false,"ln":false,"ls":false,"mkdir":false,"mv":false,"popd":false,"pushd":false,"pwd":false,"rm":false,"sed":false,"set":false,"target":false,"tempdir":false,"test":false,"touch":false,"which":false},"prototypejs":{"$":false,"$$":false,"$A":false,"$break":false,"$continue":false,"$F":false,"$H":false,"$R":false,"$w":false,"Abstract":false,"Ajax":false,"Autocompleter":false,"Builder":false,"Class":false,"Control":false,"Draggable":false,"Draggables":false,"Droppables":false,"Effect":false,"Element":false,"Enumerable":false,"Event":false,"Field":false,"Form":false,"Hash":false,"Insertion":false,"ObjectRange":false,"PeriodicalExecuter":false,"Position":false,"Prototype":false,"Scriptaculous":false,"Selector":false,"Sortable":false,"SortableObserver":false,"Sound":false,"Template":false,"Toggle":false,"Try":false},"meteor":{"_":false,"$":false,"Accounts":false,"AccountsClient":false,"AccountsCommon":false,"AccountsServer":false,"App":false,"Assets":false,"Blaze":false,"check":false,"Cordova":false,"DDP":false,"DDPRateLimiter":false,"DDPServer":false,"Deps":false,"EJSON":false,"Email":false,"HTTP":false,"Log":false,"Match":false,"Meteor":false,"Mongo":false,"MongoInternals":false,"Npm":false,"Package":false,"Plugin":false,"process":false,"Random":false,"ReactiveDict":false,"ReactiveVar":false,"Router":false,"ServiceConfiguration":false,"Session":false,"share":false,"Spacebars":false,"Template":false,"Tinytest":false,"Tracker":false,"UI":false,"Utils":false,"WebApp":false,"WebAppInternals":false},"mongo":{"_isWindows":false,"_rand":false,"BulkWriteResult":false,"cat":false,"cd":false,"connect":false,"db":false,"getHostName":false,"getMemInfo":false,"hostname":false,"ISODate":false,"listFiles":false,"load":false,"ls":false,"md5sumFile":false,"mkdir":false,"Mongo":false,"NumberInt":false,"NumberLong":false,"ObjectId":false,"PlanCache":false,"print":false,"printjson":false,"pwd":false,"quit":false,"removeFile":false,"rs":false,"sh":false,"UUID":false,"version":false,"WriteResult":false},"applescript":{"$":false,"Application":false,"Automation":false,"console":false,"delay":false,"Library":false,"ObjC":false,"ObjectSpecifier":false,"Path":false,"Progress":false,"Ref":false},"serviceworker":{"addEventListener":false,"applicationCache":false,"atob":false,"Blob":false,"BroadcastChannel":false,"btoa":false,"Cache":false,"caches":false,"CacheStorage":false,"clearInterval":false,"clearTimeout":false,"Client":false,"clients":false,"Clients":false,"close":true,"console":false,"ExtendableEvent":false,"ExtendableMessageEvent":false,"fetch":false,"FetchEvent":false,"FileReaderSync":false,"FormData":false,"Headers":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"ImageData":false,"importScripts":false,"indexedDB":false,"location":false,"MessageChannel":false,"MessagePort":false,"name":false,"navigator":false,"Notification":false,"onclose":true,"onconnect":true,"onerror":true,"onfetch":true,"oninstall":true,"onlanguagechange":true,"onmessage":true,"onmessageerror":true,"onnotificationclick":true,"onnotificationclose":true,"onoffline":true,"ononline":true,"onpush":true,"onpushsubscriptionchange":true,"onrejectionhandled":true,"onsync":true,"onunhandledrejection":true,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"postMessage":true,"Promise":false,"queueMicrotask":false,"registration":false,"removeEventListener":false,"Request":false,"Response":false,"self":false,"ServiceWorker":false,"ServiceWorkerContainer":false,"ServiceWorkerGlobalScope":false,"ServiceWorkerMessageEvent":false,"ServiceWorkerRegistration":false,"setInterval":false,"setTimeout":false,"skipWaiting":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false,"WebSocket":false,"WindowClient":false,"Worker":false,"WorkerGlobalScope":false,"XMLHttpRequest":false},"atomtest":{"advanceClock":false,"fakeClearInterval":false,"fakeClearTimeout":false,"fakeSetInterval":false,"fakeSetTimeout":false,"resetTimeouts":false,"waitsForPromise":false},"embertest":{"andThen":false,"click":false,"currentPath":false,"currentRouteName":false,"currentURL":false,"fillIn":false,"find":false,"findAll":false,"findWithAssert":false,"keyEvent":false,"pauseTest":false,"resumeTest":false,"triggerEvent":false,"visit":false,"wait":false},"protractor":{"$":false,"$$":false,"browser":false,"by":false,"By":false,"DartObject":false,"element":false,"protractor":false},"shared-node-browser":{"clearInterval":false,"clearTimeout":false,"console":false,"setInterval":false,"setTimeout":false,"URL":false,"URLSearchParams":false},"webextensions":{"browser":false,"chrome":false,"opr":false},"greasemonkey":{"cloneInto":false,"createObjectIn":false,"exportFunction":false,"GM":false,"GM_addStyle":false,"GM_deleteValue":false,"GM_getResourceText":false,"GM_getResourceURL":false,"GM_getValue":false,"GM_info":false,"GM_listValues":false,"GM_log":false,"GM_openInTab":false,"GM_registerMenuCommand":false,"GM_setClipboard":false,"GM_setValue":false,"GM_xmlhttpRequest":false,"unsafeWindow":false},"devtools":{"$":false,"$_":false,"$$":false,"$0":false,"$1":false,"$2":false,"$3":false,"$4":false,"$x":false,"chrome":false,"clear":false,"copy":false,"debug":false,"dir":false,"dirxml":false,"getEventListeners":false,"inspect":false,"keys":false,"monitor":false,"monitorEvents":false,"profile":false,"profileEnd":false,"queryObjects":false,"table":false,"undebug":false,"unmonitor":false,"unmonitorEvents":false,"values":false}}');
      } }, t = {};
      function n(r2) {
        var i = t[r2];
        if (void 0 !== i) return i.exports;
        var s = t[r2] = { id: r2, loaded: false, exports: {} };
        return e[r2].call(s.exports, s, s.exports, n), s.loaded = true, s.exports;
      }
      n.n = (e2) => {
        var t2 = e2 && e2.__esModule ? () => e2.default : () => e2;
        return n.d(t2, { a: t2 }), t2;
      }, n.d = (e2, t2) => {
        for (var r2 in t2) n.o(t2, r2) && !n.o(e2, r2) && Object.defineProperty(e2, r2, { enumerable: true, get: t2[r2] });
      }, n.g = function() {
        if ("object" == typeof globalThis) return globalThis;
        try {
          return this || new Function("return this")();
        } catch (e2) {
          if ("object" == typeof window) return window;
        }
      }(), n.o = (e2, t2) => Object.prototype.hasOwnProperty.call(e2, t2), n.r = (e2) => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e2, "__esModule", { value: true });
      }, n.nmd = (e2) => (e2.paths = [], e2.children || (e2.children = []), e2);
      var r = {};
      return (() => {
        "use strict";
        n.r(r), n.d(r, { ABSTRACTION_LEVELS: () => ae, DEFINED_MODIFIERS: () => Te, MODIFIED_TYPES: () => c, MODIFIER_PRESETS: () => ge, TOKEN_TYPES: () => i, convertCodeToFlowTree: () => Or, convertCodeToSvg: () => wr, convertFlowTreeToSvg: () => Ir, createFlowTreeBuilder: () => xr, createFlowTreeModifier: () => Dr, createPresentationGenerator: () => Cr, createSVGRender: () => Ar, createShapesTreeEditor: () => vr });
        var e2, t2 = n(5686), i = { FUNCTION: "Function", FUNCTION_EXPRESSION: "FunctionExpression", FUNCTION_DECLARATION: "FunctionDeclaration", VARIABLE_DECLARATOR: "VariableDeclarator", ASSIGNMENT_EXPRESSION: "AssignmentExpression", MEMBER_EXPRESSION: "MemberExpression", VARIABLE_DECLARATION: "VariableDeclaration", UPDATE_EXPRESSION: "UpdateExpression", CALL_EXPRESSION: "CallExpression", NEW_EXPRESSION: "NewExpression", LOOP: "Loop", FOR_IN_STATEMENT: "ForInStatement", FOR_STATEMENT: "ForStatement", WHILE_STATEMENT: "WhileStatement", DO_WHILE_STATEMENT: "DoWhileStatement", CONTINUE: "ContinueStatement", CONDITIONAL: "Conditional", SWITCH_CASE: "SwitchCase", SWITCH_STATEMENT: "SwitchStatement", PROGRAM: "Program", RETURN: "ReturnStatement", BREAK: "BreakStatement", TRY_STATEMENT: "TryStatement", CATCH_CLAUSE: "CatchClause", WITH_STATEMENT: "WithStatement", THROW_STATEMENT: "ThrowStatement", DEBUGGER_STATEMENT: "DebuggerStatement", IDENTIFIER: "Identifier", ARRAY_EXPRESSION: "ArrayExpression", OBJECT_EXPRESSION: "ObjectExpression", OBJECT_PROPERTY: "ObjectProperty", OBJECT_METHOD: "ObjectMethod", BINARY_EXPRESSION: "BinaryExpression", EXPRESSION_STATEMENT: "ExpressionStatement", UNARY_EXPRESSION: "UnaryExpression", CONDITIONAL_EXPRESSION: "ConditionalExpression", STRING_LITERAL: "StringLiteral", NUMERIC_LITERAL: "NumericLiteral", THIS_EXPRESSION: "ThisExpression", LOGICAL_EXPRESSION: "LogicalExpression", ARROW_FUNCTION_EXPRESSION: "ArrowFunctionExpression", IMPORT_DECLARATION: "ImportDeclaration", IMPORT_DEFAULT_SPECIFIER: "ImportDefaultSpecifier", IMPORT_SPECIFIER: "ImportSpecifier", EXPORT_NAMED_DECLARATION: "ExportNamedDeclaration", EXPORT_DEFAULT_DECLARATION: "ExportDefaultDeclaration", CLASS_DECLARATION: "ClassDeclaration", CLASS_METHOD: "ClassMethod", FOR_OF_STATEMENT: "ForOfStatement", SPREAD_ELEMENT: "SpreadElement", SPREAD_PROPERTY: "SpreadProperty", REST_PROPERTY: "RestProperty", OBJECT_PATTERN: "ObjectPattern", ARRAY_PATTERN: "ArrayPattern", ASSIGNMENT_PATTERN: "AssignmentPattern" }, s = { BODY: "body", PROGRAM: "program", CONSEQUENT: "consequent", ALTERNATE: "alternate", TEST: "test" }, a = "RIGHT", o = "LEFT", l = "DOWN", c = { DESTRUCTED: "DESTRUCTED", CUSTOM: "CUSTOM" }, u = n(7848), p = function(e3) {
          return (0, u.default)(e3.node).code;
        }, h = function(e3) {
          var t3 = e3.parent;
          if (!t3 || t3.type !== i.VARIABLE_DECLARATOR && t3.type !== i.ASSIGNMENT_EXPRESSION && t3.type !== i.OBJECT_PROPERTY) return "";
          if (t3.left) return (0, u.default)(t3.left).code + " = ";
          var n2 = t3.id;
          return n2 ? n2.name + " = " : "";
        }, d = function(e3) {
          var t3 = e3.node, n2 = e3.parent && e3.parent.kind || "";
          if (t3.init && (b(t3.init) || t3.init.type === i.CONDITIONAL_EXPRESSION)) return "".concat(n2, " ").concat(t3.id.name, " = ");
          var r2;
          return r2 = t3.id.type === i.OBJECT_PATTERN ? "{...}" : t3.id.type === i.ARRAY_PATTERN ? "[...]" : t3.id.name, t3.init && [i.CALL_EXPRESSION, i.NEW_EXPRESSION].includes(t3.init.type) ? "".concat(n2, " ").concat(r2, " = ") + y({ node: t3.init }) : t3.init && t3.init.type === i.OBJECT_EXPRESSION ? "".concat(n2, " ").concat(r2, " = ").concat(T()) : t3.id && t3.id.type === i.OBJECT_PATTERN ? "".concat(n2, " {...} = ").concat(t3.init.name) : t3.id && t3.id.type === i.ARRAY_PATTERN ? "".concat(n2, " [...] = ").concat(t3.init.name) : n2 + " " + (0, u.default)(t3).code;
        }, f = function(e3) {
          return e3.name ? e3.name : (0, u.default)(e3).code;
        }, y = function(e3) {
          var t3 = e3.node, n2 = "";
          t3.arguments && t3.arguments.length && (n2 = t3.arguments.map(m).join(", "));
          var r2 = t3.callee;
          return r2.type === i.MEMBER_EXPRESSION && r2.object.type === i.CALL_EXPRESSION ? { name: ".".concat(r2.property.name, "(").concat(n2, ")"), chain: true } : n2 ? "".concat((0, u.default)(t3.callee).code, "(").concat(n2, ")") : (0, u.default)(t3).code;
        }, m = function(e3) {
          return b(e3) ? "*()" : e3.type === i.OBJECT_EXPRESSION ? T() : e3.name ? e3.name : e3.value ? e3.type === i.STRING_LITERAL ? "'".concat(e3.value, "'") : e3.value : (0, u.default)(e3).code;
        }, T = function(e3) {
          return e3 ? { name: "{*}", pathParentType: e3.parent.type } : "{*}";
        }, g = function(e3) {
          return [i.FUNCTION_EXPRESSION, i.FUNCTION, i.ARROW_FUNCTION_EXPRESSION, i.FUNCTION_DECLARATION].includes(e3);
        }, b = function(e3) {
          var t3 = [i.ARROW_FUNCTION_EXPRESSION, i.FUNCTION_EXPRESSION];
          return e3 && -1 !== t3.indexOf(e3.type);
        }, E = function(e3) {
          var t3 = e3.declaration, n2 = e3.specifiers;
          return t3 ? " " + S(t3) : n2 ? "" : (0, u.default)(n2).code;
        }, S = function(e3) {
          return -1 !== [i.FUNCTION_DECLARATION, i.ARROW_FUNCTION_EXPRESSION].indexOf(e3.type) ? e3.id ? e3.id.name : "function" : e3.type === i.VARIABLE_DECLARATION ? e3.declarations[0].id.name : e3.type === i.IDENTIFIER ? e3.name : e3.type === i.ASSIGNMENT_EXPRESSION ? e3.left.name : void 0;
        };
        function P(e3) {
          return P = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, P(e3);
        }
        function x(e3, t3, n2) {
          return (t3 = function(e4) {
            var t4 = function(e5, t5) {
              if ("object" !== P(e5) || null === e5) return e5;
              var n3 = e5[Symbol.toPrimitive];
              if (void 0 !== n3) {
                var r2 = n3.call(e5, "string");
                if ("object" !== P(r2)) return r2;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return String(e5);
            }(e4);
            return "symbol" === P(t4) ? t4 : String(t4);
          }(t3)) in e3 ? Object.defineProperty(e3, t3, { value: n2, enumerable: true, configurable: true, writable: true }) : e3[t3] = n2, e3;
        }
        var D = function(e3) {
          var t3 = e3.getStatementParent(), n2 = e3.parent || {};
          return ![s.CONSEQUENT, s.ALTERNATE].includes(e3.key) && (["params"].includes(e3.listKey) || t3.isReturnStatement() && "body" !== e3.key || (t3.isLoop() || t3.isConditional() || n2.type === i.CONDITIONAL_EXPRESSION) && ["test", "left", "right"].includes(e3.parentKey) || [i.RETURN, i.CALL_EXPRESSION, i.BINARY_EXPRESSION, i.UPDATE_EXPRESSION, i.ASSIGNMENT_EXPRESSION, i.LOGICAL_EXPRESSION, i.VARIABLE_DECLARATOR, i.MEMBER_EXPRESSION, i.NEW_EXPRESSION, i.FUNCTION_DECLARATION, i.FUNCTION_EXPRESSION, i.ARROW_FUNCTION_EXPRESSION, i.FUNCTION, i.OBJECT_PROPERTY, i.ASSIGNMENT_PATTERN, i.REST_PROPERTY, i.SPREAD_ELEMENT, i.ARRAY_EXPRESSION, i.UNARY_EXPRESSION, i.IMPORT_DEFAULT_SPECIFIER, i.IMPORT_SPECIFIER, i.IMPORT_DECLARATION, i.EXPORT_DEFAULT_DECLARATION, i.EXPORT_NAMED_DECLARATION, i.CLASS_DECLARATION, i.CLASS_METHOD, i.SWITCH_STATEMENT, i.SWITCH_CASE].includes(n2.type) && (!n2.body || n2.body.type !== e3.node.type));
        }, A = (x(e2 = {}, i.FUNCTION, { type: i.FUNCTION, getName: function(e3) {
          var t3, n2 = e3.node, r2 = (t3 = n2.params, "(".concat(t3.map(function(e4) {
            return e4.name ? e4.name : (0, u.default)(e4).code;
          }).join(", "), ")"));
          return { name: n2.id ? h(e3) + "function " + n2.id.name + r2 : n2.type === i.ARROW_FUNCTION_EXPRESSION ? h(e3) + r2 + " =>" : n2.type === i.CLASS_METHOD || n2.type === i.OBJECT_METHOD ? "constructor" === n2.kind ? "constructor" + r2 : n2.key.name + r2 : h(e3) + "function" + r2, pathParentType: e3.parent.type };
        }, body: true }), x(e2, i.RETURN, { type: i.RETURN, getName: function(e3) {
          var t3 = e3.node;
          return t3.argument && ([i.CONDITIONAL_EXPRESSION, i.OBJECT_EXPRESSION].includes(t3.argument.type) || g(t3.argument.type)) ? "return" : e3.node.argument ? "return ".concat((0, u.default)(e3.node.argument).code) : "return";
        }, body: true }), x(e2, i.VARIABLE_DECLARATOR, { type: i.VARIABLE_DECLARATOR, body: true, getName: d, ignore: function(e3) {
          var t3 = e3.getStatementParent();
          return !e3.node.init || b(e3.node.init) || t3.isLoop();
        } }), x(e2, i.ASSIGNMENT_EXPRESSION, { type: i.ASSIGNMENT_EXPRESSION, body: true, getName: function(e3) {
          var t3 = e3.node;
          return b(t3.right) || t3.right.type === i.CONDITIONAL_EXPRESSION ? "".concat(f(t3.left), " ").concat(t3.operator, " ") : t3.right.type === i.OBJECT_EXPRESSION ? "".concat(f(t3.left), " ").concat(t3.operator, " ").concat(T()) : [i.CALL_EXPRESSION, i.NEW_EXPRESSION].includes(t3.right.type) ? "".concat(f(t3.left), " ").concat(t3.operator, " ").concat(y({ node: t3.right })) : (0, u.default)(t3).code;
        }, ignore: function(e3) {
          var t3 = e3.getStatementParent();
          return t3.isVariableDeclaration() || e3.parent.type === i.LOGICAL_EXPRESSION || t3.isConditional() && e3.key === s.TEST || b(e3.node.right);
        } }), x(e2, i.CALL_EXPRESSION, { type: i.CALL_EXPRESSION, body: false, reversed: true, getName: y, ignore: function(e3) {
          var t3 = e3.getStatementParent(), n2 = e3.parent || {};
          return n2.type !== i.ARROW_FUNCTION_EXPRESSION && (t3.isVariableDeclaration() || [i.RETURN, i.CALL_EXPRESSION, i.NEW_EXPRESSION, i.UNARY_EXPRESSION, i.BINARY_EXPRESSION].includes(n2.type) || t3.isConditional() && n2.test && n2.test.type === i.CALL_EXPRESSION || e3.parent.type === i.ASSIGNMENT_EXPRESSION);
        } }), x(e2, i.UPDATE_EXPRESSION, { type: i.UPDATE_EXPRESSION, getName: p, ignore: function(e3) {
          return e3.getStatementParent().isVariableDeclaration();
        } }), x(e2, i.NEW_EXPRESSION, { type: i.NEW_EXPRESSION, getName: p, ignore: function(e3) {
          return e3.getStatementParent().isVariableDeclaration() || e3.parent.type === i.ASSIGNMENT_EXPRESSION || e3.parent.type === i.THROW_STATEMENT;
        } }), x(e2, i.LOOP, { type: i.LOOP, getName: function(e3) {
          var t3 = e3.node;
          if (t3.test) return (0, u.default)(t3.test).code;
          if (t3.left && t3.right) {
            var n2 = t3.type === i.FOR_OF_STATEMENT ? "of" : "in", r2 = t3.left.type === i.VARIABLE_DECLARATION ? t3.left.declarations.map(function(e4) {
              return d({ node: e4 });
            }).join(", ") : (0, u.default)(t3.left).code;
            return "".concat(r2, " ").concat(n2, " ").concat((0, u.default)(t3.right).code);
          }
        }, body: true }), x(e2, i.CONTINUE, { type: i.CONTINUE, getName: function(e3) {
          return e3.node.label ? "continue ".concat((0, u.default)(e3.node.label).code) : "continue";
        }, body: true }), x(e2, i.CONDITIONAL, { type: i.CONDITIONAL, getName: function(e3) {
          return "(".concat((0, u.default)(e3.node.test).code, ")");
        }, body: true }), x(e2, i.SWITCH_STATEMENT, { type: i.SWITCH_STATEMENT, getName: function(e3) {
          return "switch (".concat((0, u.default)(e3.node.discriminant).code, ")");
        }, body: true }), x(e2, i.SWITCH_CASE, { type: i.SWITCH_CASE, getName: function(e3) {
          return e3.node.test ? "case ".concat((0, u.default)(e3.node.test).code, ":") : "default:";
        }, body: true }), x(e2, i.BREAK, { type: i.BREAK, getName: function(e3) {
          return e3.node.label ? "break ".concat((0, u.default)(e3.node.label).code, ":") : "break";
        }, body: true }), x(e2, i.TRY_STATEMENT, { type: i.TRY_STATEMENT, getName: function(e3) {
          return "try";
        }, body: true }), x(e2, i.CATCH_CLAUSE, { type: i.CATCH_CLAUSE, getName: function(e3) {
          return e3.node.param ? "catch (".concat((0, u.default)(e3.node.param).code, ")") : "*catchConverter*";
        }, body: true }), x(e2, i.WITH_STATEMENT, { type: i.WITH_STATEMENT, getName: function(e3) {
          return "with (".concat((0, u.default)(e3.node.object).code, ")");
        }, body: true }), x(e2, i.PROGRAM, { type: i.PROGRAM, getName: function(e3) {
          return "".concat(e3.node.type, ": source ").concat(e3.node.sourceType);
        }, body: true }), x(e2, i.THROW_STATEMENT, { type: i.THROW_STATEMENT, getName: function(e3) {
          return "throw ".concat((0, u.default)(e3.node.argument).code);
        }, body: true }), x(e2, i.DEBUGGER_STATEMENT, { type: i.DEBUGGER_STATEMENT, getName: function(e3) {
          return "debugger";
        }, body: true }), x(e2, i.BINARY_EXPRESSION, { type: i.BINARY_EXPRESSION, getName: p, ignore: D }), x(e2, i.IDENTIFIER, { type: i.IDENTIFIER, getName: function(e3) {
          return e3.parent.type === i.SPREAD_PROPERTY ? "..." + p(e3) : p(e3);
        }, ignore: D }), x(e2, i.STRING_LITERAL, { type: i.STRING_LITERAL, getName: p, ignore: D }), x(e2, i.NUMERIC_LITERAL, { type: i.NUMERIC_LITERAL, getName: p, ignore: D }), x(e2, i.OBJECT_EXPRESSION, { type: i.OBJECT_EXPRESSION, getName: T, ignore: function(e3) {
          var t3 = e3.node;
          return !(!t3.properties || t3.properties.length) || [i.OBJECT_PROPERTY, i.ASSIGNMENT_EXPRESSION, i.VARIABLE_DECLARATOR].includes(e3.parent.type);
        }, body: true }), x(e2, i.OBJECT_PROPERTY, { type: i.OBJECT_PROPERTY, getName: function(e3) {
          var t3 = e3.node;
          return t3.value && g(t3.value.type) ? t3.key.name + ": " : t3.value && t3.value.type === i.OBJECT_EXPRESSION ? t3.key.name + ": " + T() : (0, u.default)(t3).code;
        }, ignore: function(e3) {
          var t3 = e3.parentPath;
          return ["params", "left"].includes(t3.parentKey);
        }, body: true }), x(e2, i.IMPORT_DECLARATION, { type: i.IMPORT_DECLARATION, getName: function(e3) {
          var t3 = e3.node;
          return "import from" + (0, u.default)(t3.source).code;
        }, body: true }), x(e2, i.IMPORT_DEFAULT_SPECIFIER, { type: i.IMPORT_DEFAULT_SPECIFIER, getName: p }), x(e2, i.IMPORT_SPECIFIER, { type: i.IMPORT_SPECIFIER, getName: p }), x(e2, i.EXPORT_DEFAULT_DECLARATION, { type: i.EXPORT_DEFAULT_DECLARATION, getName: function(e3) {
          var t3 = e3.node;
          return "export default ".concat(E(t3));
        }, body: true }), x(e2, i.EXPORT_NAMED_DECLARATION, { type: i.EXPORT_NAMED_DECLARATION, getName: function(e3) {
          var t3 = e3.node;
          return "export".concat(E(t3));
        }, body: true }), x(e2, i.CLASS_DECLARATION, { type: i.CLASS_DECLARATION, getName: function(e3) {
          var t3 = e3.node;
          return "class ".concat((0, u.default)(t3.id).code, " ").concat(t3.superClass ? " extends ".concat((0, u.default)(t3.superClass).code) : "");
        }, body: true }), x(e2, i.OBJECT_PATTERN, { type: i.OBJECT_PATTERN, getName: function() {
          return "{...}";
        }, ignore: function(e3) {
          return "params" === e3.listKey || [i.VARIABLE_DECLARATOR, i.ASSIGNMENT_PATTERN].includes(e3.parent.type);
        }, body: true }), x(e2, i.ARRAY_PATTERN, { type: i.ARRAY_PATTERN, getName: function() {
          return "[...]";
        }, ignore: function(e3) {
          return "params" === e3.listKey || [i.VARIABLE_DECLARATOR, i.ASSIGNMENT_PATTERN].includes(e3.parent.type);
        }, body: true }), e2), v = Object.keys(A).map(function(e3) {
          return A[e3];
        }), C = n(7191), w = n(9996), O = n.n(w);
        function I(e3, t3) {
          (null == t3 || t3 > e3.length) && (t3 = e3.length);
          for (var n2 = 0, r2 = new Array(t3); n2 < t3; n2++) r2[n2] = e3[n2];
          return r2;
        }
        var N = function(e3, t3) {
          return Object.assign.apply(null, [{ state: e3 }].concat(function(e4) {
            if (Array.isArray(e4)) return I(e4);
          }(n2 = t3.map(function(t4) {
            return t4(e3);
          })) || function(e4) {
            if ("undefined" != typeof Symbol && null != e4[Symbol.iterator] || null != e4["@@iterator"]) return Array.from(e4);
          }(n2) || function(e4, t4) {
            if (e4) {
              if ("string" == typeof e4) return I(e4, t4);
              var n3 = Object.prototype.toString.call(e4).slice(8, -1);
              return "Object" === n3 && e4.constructor && (n3 = e4.constructor.name), "Map" === n3 || "Set" === n3 ? Array.from(e4) : "Arguments" === n3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3) ? I(e4, t4) : void 0;
            }
          }(n2) || function() {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }()));
          var n2;
        }, F = function(e3, t3) {
          return O()(e3, t3);
        }, k = function(e3) {
          return { list: e3 ? [e3] : [], getCurrent: function() {
            if (this.list.length) return this.list[this.list.length - 1];
          }, stepIn: function(e4) {
            this.list.push(e4);
          }, stepOut: function() {
            this.list.pop();
          } };
        }, L = function(e3) {
          console.error(e3);
        };
        const _ = { sourceType: "module", plugins: ["objectRestSpread", "jsx", "typescript", "classProperties", "asyncGenerators", "dynamicImport", "exportDefaultFrom", "exportNamespaceFrom", "optionalChaining", "nullishCoalescingOperator"] };
        function M(e3) {
          return M = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, M(e3);
        }
        function B(e3, t3) {
          var n2 = Object.keys(e3);
          if (Object.getOwnPropertySymbols) {
            var r2 = Object.getOwnPropertySymbols(e3);
            t3 && (r2 = r2.filter(function(t4) {
              return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
            })), n2.push.apply(n2, r2);
          }
          return n2;
        }
        function j(e3) {
          for (var t3 = 1; t3 < arguments.length; t3++) {
            var n2 = null != arguments[t3] ? arguments[t3] : {};
            t3 % 2 ? B(Object(n2), true).forEach(function(t4) {
              var r2, i2, s2;
              r2 = e3, i2 = t4, s2 = n2[t4], (i2 = function(e4) {
                var t5 = function(e5, t6) {
                  if ("object" !== M(e5) || null === e5) return e5;
                  var n3 = e5[Symbol.toPrimitive];
                  if (void 0 !== n3) {
                    var r3 = n3.call(e5, "string");
                    if ("object" !== M(r3)) return r3;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                  }
                  return String(e5);
                }(e4);
                return "symbol" === M(t5) ? t5 : String(t5);
              }(i2)) in r2 ? Object.defineProperty(r2, i2, { value: s2, enumerable: true, configurable: true, writable: true }) : r2[i2] = s2;
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(n2)) : B(Object(n2)).forEach(function(t4) {
              Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(n2, t4));
            });
          }
          return e3;
        }
        var R = function(e3) {
          var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n2 = [];
          try {
            n2 = C.parse(e3, F(_, t3));
          } catch (e4) {
            throw L("Error at parseCodeToAST: " + e4.message, e4.loc, e4.stack), e4;
          }
          return n2;
        }, U = function(e3, t3) {
          return function(n2, r2) {
            if (!e3.ignore || !e3.ignore(n2)) {
              var i2 = j({}, q(e3, n2));
              r2 && r2(i2) || W(t3, i2);
            }
          };
        }, V = function(e3, t3) {
          return function(n2, r2) {
            if (!e3.ignore || !e3.ignore(n2)) {
              var i2 = K(e3, t3, n2, r2);
              t3.stepIn(i2);
            }
          };
        }, K = function(e3, t3, n2, r2) {
          var i2 = j(j({}, q(e3, n2)), {}, { body: [] });
          return r2 && r2(i2) || W(t3, i2), i2;
        }, W = function(e3, t3) {
          var n2 = e3.getCurrent();
          t3.parent = n2, (n2.body || n2).push(t3);
        }, X = function(e3) {
          var t3 = e3.find(function(e4) {
            return e4.parentKey === s.PROGRAM || e4.isStatementOrBlock();
          }) || {};
          return t3.key;
        }, Y = function(e3, t3) {
          return function(n2) {
            e3.ignore && e3.ignore(n2) || t3.stepOut();
          };
        }, q = function(e3, t3) {
          var n2 = e3.getName(t3), r2 = j(j({}, "string" == typeof n2 ? { name: n2 } : n2), {}, { type: e3.type, key: X(t3), isBodyEntry: t3.key === s.BODY });
          return r2.name || (r2.name = ""), e3.type !== t3.node.type && (r2.subType = t3.node.type), r2;
        };
        function H(e3) {
          return H = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, H(e3);
        }
        function J(e3, t3) {
          var n2 = Object.keys(e3);
          if (Object.getOwnPropertySymbols) {
            var r2 = Object.getOwnPropertySymbols(e3);
            t3 && (r2 = r2.filter(function(t4) {
              return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
            })), n2.push.apply(n2, r2);
          }
          return n2;
        }
        function $(e3) {
          for (var t3 = 1; t3 < arguments.length; t3++) {
            var n2 = null != arguments[t3] ? arguments[t3] : {};
            t3 % 2 ? J(Object(n2), true).forEach(function(t4) {
              var r2, i2, s2;
              r2 = e3, i2 = t4, s2 = n2[t4], (i2 = function(e4) {
                var t5 = function(e5, t6) {
                  if ("object" !== H(e5) || null === e5) return e5;
                  var n3 = e5[Symbol.toPrimitive];
                  if (void 0 !== n3) {
                    var r3 = n3.call(e5, "string");
                    if ("object" !== H(r3)) return r3;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                  }
                  return String(e5);
                }(e4);
                return "symbol" === H(t5) ? t5 : String(t5);
              }(i2)) in r2 ? Object.defineProperty(r2, i2, { value: s2, enumerable: true, configurable: true, writable: true }) : r2[i2] = s2;
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(n2)) : J(Object(n2)).forEach(function(t4) {
              Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(n2, t4));
            });
          }
          return e3;
        }
        var G = function() {
          var e3 = A[i.FUNCTION];
          return $($({}, e3), {}, { getName: function(t3) {
            var n2 = e3.getName(t3);
            return t3.parent.type === i.OBJECT_PROPERTY && t3.parent.key && (n2 = $($({}, n2), {}, { name: t3.parent.key.name + ": " + n2.name })), n2;
          }, ignore: function(t3) {
            return e3.ignore && e3.ignore(t3) || t3.parent.type === i.CALL_EXPRESSION;
          } });
        };
        function z(e3) {
          return z = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, z(e3);
        }
        function Q(e3, t3) {
          var n2 = Object.keys(e3);
          if (Object.getOwnPropertySymbols) {
            var r2 = Object.getOwnPropertySymbols(e3);
            t3 && (r2 = r2.filter(function(t4) {
              return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
            })), n2.push.apply(n2, r2);
          }
          return n2;
        }
        function Z(e3) {
          for (var t3 = 1; t3 < arguments.length; t3++) {
            var n2 = null != arguments[t3] ? arguments[t3] : {};
            t3 % 2 ? Q(Object(n2), true).forEach(function(t4) {
              var r2, i2, s2;
              r2 = e3, i2 = t4, s2 = n2[t4], (i2 = function(e4) {
                var t5 = function(e5, t6) {
                  if ("object" !== z(e5) || null === e5) return e5;
                  var n3 = e5[Symbol.toPrimitive];
                  if (void 0 !== n3) {
                    var r3 = n3.call(e5, "string");
                    if ("object" !== z(r3)) return r3;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                  }
                  return String(e5);
                }(e4);
                return "symbol" === z(t5) ? t5 : String(t5);
              }(i2)) in r2 ? Object.defineProperty(r2, i2, { value: s2, enumerable: true, configurable: true, writable: true }) : r2[i2] = s2;
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(n2)) : Q(Object(n2)).forEach(function(t4) {
              Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(n2, t4));
            });
          }
          return e3;
        }
        var ee = function(e3) {
          return e3 && e3.type === i.CALL_EXPRESSION;
        };
        function te(e3) {
          return te = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, te(e3);
        }
        function ne(e3) {
          return function(e4) {
            if (Array.isArray(e4)) return re(e4);
          }(e3) || function(e4) {
            if ("undefined" != typeof Symbol && null != e4[Symbol.iterator] || null != e4["@@iterator"]) return Array.from(e4);
          }(e3) || function(e4, t3) {
            if (e4) {
              if ("string" == typeof e4) return re(e4, t3);
              var n2 = Object.prototype.toString.call(e4).slice(8, -1);
              return "Object" === n2 && e4.constructor && (n2 = e4.constructor.name), "Map" === n2 || "Set" === n2 ? Array.from(e4) : "Arguments" === n2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2) ? re(e4, t3) : void 0;
            }
          }(e3) || function() {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }();
        }
        function re(e3, t3) {
          (null == t3 || t3 > e3.length) && (t3 = e3.length);
          for (var n2 = 0, r2 = new Array(t3); n2 < t3; n2++) r2[n2] = e3[n2];
          return r2;
        }
        var ie, se, ae = { FUNCTION: { defined: [], custom: [G()] }, FUNCTION_DEPENDENCIES: { defined: [i.CALL_EXPRESSION], custom: [G(), (se = A[i.ASSIGNMENT_EXPRESSION], Z(Z({}, se), {}, { getName: function(e3) {
          var t3 = e3.node;
          return y({ node: t3.right });
        }, ignore: function(e3) {
          return se.ignore(e3) || !ee(e3.node.right);
        } })), (ie = A[i.VARIABLE_DECLARATOR], Z(Z({}, ie), {}, { getName: function(e3) {
          var t3 = e3.node;
          return y({ node: t3.init });
        }, ignore: function(e3) {
          return ie.ignore(e3) || !ee(e3.node.init);
        } }))] }, CLASS: [i.CLASS_DECLARATION], IMPORT: [i.IMPORT_DECLARATION, i.IMPORT_SPECIFIER, i.IMPORT_DEFAULT_SPECIFIER], EXPORT: [i.EXPORT_NAMED_DECLARATION, i.EXPORT_DEFAULT_DECLARATION] };
        function oe(e3) {
          return function(e4) {
            if (Array.isArray(e4)) return le(e4);
          }(e3) || function(e4) {
            if ("undefined" != typeof Symbol && null != e4[Symbol.iterator] || null != e4["@@iterator"]) return Array.from(e4);
          }(e3) || function(e4, t3) {
            if (e4) {
              if ("string" == typeof e4) return le(e4, t3);
              var n2 = Object.prototype.toString.call(e4).slice(8, -1);
              return "Object" === n2 && e4.constructor && (n2 = e4.constructor.name), "Map" === n2 || "Set" === n2 ? Array.from(e4) : "Arguments" === n2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2) ? le(e4, t3) : void 0;
            }
          }(e3) || function() {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }();
        }
        function le(e3, t3) {
          (null == t3 || t3 > e3.length) && (t3 = e3.length);
          for (var n2 = 0, r2 = new Array(t3); n2 < t3; n2++) r2[n2] = e3[n2];
          return r2;
        }
        var ce = function e3(t3, n2, r2, i2) {
          var s2 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : {}, a2 = s2.getBody || function(e4) {
            return e4.body;
          };
          n2(t3), a2(t3).forEach(function(t4) {
            r2(t4), a2(t4) && e3(t4, n2, r2, i2, s2);
          }), i2(t3);
        }, ue = function(e3, t3) {
          for (var n2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : function(e4) {
            return e4.body;
          }, r2 = [].concat(e3); r2.length; ) {
            var i2 = r2.shift();
            t3(i2);
            var s2 = n2(i2);
            s2 && (r2 = [].concat(oe(r2), oe(s2)));
          }
        }, pe = function(e3, t3) {
          return "function" == typeof e3 ? e3(t3) : e3;
        }, he = { name: function(e3, t3) {
          e3.name = pe(t3, e3);
        }, prefixName: function(e3, t3) {
          e3.prefixName = pe(t3, e3);
        }, type: function(e3, t3) {
          e3.type = pe(t3, e3);
        }, body: function(e3, t3) {
          e3.body = pe(t3, e3);
        }, parent: function(e3, t3) {
          e3.parent = pe(t3, e3);
        } };
        function de(e3) {
          return function(e4) {
            if (Array.isArray(e4)) return fe(e4);
          }(e3) || function(e4) {
            if ("undefined" != typeof Symbol && null != e4[Symbol.iterator] || null != e4["@@iterator"]) return Array.from(e4);
          }(e3) || function(e4, t3) {
            if (e4) {
              if ("string" == typeof e4) return fe(e4, t3);
              var n2 = Object.prototype.toString.call(e4).slice(8, -1);
              return "Object" === n2 && e4.constructor && (n2 = e4.constructor.name), "Map" === n2 || "Set" === n2 ? Array.from(e4) : "Arguments" === n2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2) ? fe(e4, t3) : void 0;
            }
          }(e3) || function() {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }();
        }
        function fe(e3, t3) {
          (null == t3 || t3 > e3.length) && (t3 = e3.length);
          for (var n2 = 0, r2 = new Array(t3); n2 < t3; n2++) r2[n2] = e3[n2];
          return r2;
        }
        var ye = function(e3, t3) {
          var n2 = e3.name.split(".".concat(t3, "("))[0];
          return n2.includes("=") ? n2.split("=") : [n2];
        }, me = function(e3, t3) {
          return e3.name.includes(".".concat(t3, "("));
        }, Te = { forEach: { test: function(e3) {
          return me(e3, "forEach");
        }, updates: { name: function(e3) {
          return "each in  ".concat(ye(e3, "forEach")[0]);
        }, type: i.LOOP, body: function(e3) {
          return de(e3.body[0].body);
        } } }, filter: { test: function(e3) {
          return me(e3, "filter");
        }, updates: { name: function(e3) {
          return "in ".concat(ye(e3, "filter")[1], " to ").concat(ye(e3, "filter")[0]);
        }, prefixName: "filter", type: i.LOOP } }, map: { test: function(e3) {
          return me(e3, "map");
        }, updates: { name: function(e3) {
          return "from ".concat(ye(e3, "map")[1], " to ").concat(ye(e3, "map")[0]);
        }, prefixName: "map", type: i.LOOP } } }, ge = { es5ArrayIterators: [Te.forEach, Te.filter, Te.map] };
        function be(e3) {
          return be = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, be(e3);
        }
        function Ee(e3) {
          return function(e4) {
            if (Array.isArray(e4)) return Se(e4);
          }(e3) || function(e4) {
            if ("undefined" != typeof Symbol && null != e4[Symbol.iterator] || null != e4["@@iterator"]) return Array.from(e4);
          }(e3) || function(e4, t3) {
            if (e4) {
              if ("string" == typeof e4) return Se(e4, t3);
              var n2 = Object.prototype.toString.call(e4).slice(8, -1);
              return "Object" === n2 && e4.constructor && (n2 = e4.constructor.name), "Map" === n2 || "Set" === n2 ? Array.from(e4) : "Arguments" === n2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2) ? Se(e4, t3) : void 0;
            }
          }(e3) || function() {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }();
        }
        function Se(e3, t3) {
          (null == t3 || t3 > e3.length) && (t3 = e3.length);
          for (var n2 = 0, r2 = new Array(t3); n2 < t3; n2++) r2[n2] = e3[n2];
          return r2;
        }
        function Pe(e3, t3) {
          var n2 = Object.keys(e3);
          if (Object.getOwnPropertySymbols) {
            var r2 = Object.getOwnPropertySymbols(e3);
            t3 && (r2 = r2.filter(function(t4) {
              return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
            })), n2.push.apply(n2, r2);
          }
          return n2;
        }
        function xe(e3) {
          for (var t3 = 1; t3 < arguments.length; t3++) {
            var n2 = null != arguments[t3] ? arguments[t3] : {};
            t3 % 2 ? Pe(Object(n2), true).forEach(function(t4) {
              var r2, i2, s2;
              r2 = e3, i2 = t4, s2 = n2[t4], (i2 = function(e4) {
                var t5 = function(e5, t6) {
                  if ("object" !== be(e5) || null === e5) return e5;
                  var n3 = e5[Symbol.toPrimitive];
                  if (void 0 !== n3) {
                    var r3 = n3.call(e5, "string");
                    if ("object" !== be(r3)) return r3;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                  }
                  return String(e5);
                }(e4);
                return "symbol" === be(t5) ? t5 : String(t5);
              }(i2)) in r2 ? Object.defineProperty(r2, i2, { value: s2, enumerable: true, configurable: true, writable: true }) : r2[i2] = s2;
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(n2)) : Pe(Object(n2)).forEach(function(t4) {
              Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(n2, t4));
            });
          }
          return e3;
        }
        var De = function() {
          var e3, t3 = (e3 = [], { addModifier: function(t4) {
            [].concat(t4).forEach(function(t5) {
              return e3.push(t5);
            });
          }, create: function(e4, t4) {
            this.addModifier({ test: e4, updates: t4 });
          }, runModifier: function(e4, t4) {
            !function(e5, t5) {
              var n2 = function(e6, t6) {
                var n3 = [];
                return ue(e6, function(e7) {
                  t6(e7) && n3.push(e7);
                }), n3;
              }(e5, t5.test);
              if (n2.length) {
                var r2 = Object.keys(t5.updates || {});
                r2.filter(function(e6) {
                  return "subTreeUpdate" !== e6;
                }).forEach(function(e6) {
                  n2.forEach(function(n3) {
                    he[e6](n3, t5.updates[e6]);
                  });
                }), r2.includes("subTreeUpdate") && t5.updates.subTreeUpdate(n2, e5);
              }
            }(e4, t4);
          }, applyTo: function(t4) {
            var n2 = this;
            e3.forEach(function(e4) {
              return n2.runModifier(t4, e4);
            });
          } });
          return { setModifier: function(e4) {
            t3.addModifier(e4);
          }, registerNewModifier: function(e4, n2) {
            t3.create(e4, n2);
          }, destructNodeTree: function(e4, t4) {
            this.setModifier(function(e5, t5) {
              return { test: e5, updates: { name: t5, body: [], type: c.DESTRUCTED } };
            }(e4, t4));
          }, applyToFlowTree: function(e4) {
            return t3.applyTo(e4), e4;
          } };
        };
        const Ae = function() {
          var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, n2 = e3.astParser, r2 = void 0 === n2 ? {} : n2, s2 = e3.astVisitor, a2 = void 0 === s2 ? {} : s2, o2 = xe({}, r2), l2 = xe({ definitionsMap: Ee(v), globalIgnore: null }, a2), c2 = De();
          return c2.setModifier({ test: function(e4) {
            return e4.pathParentType === i.CALL_EXPRESSION;
          }, updates: { subTreeUpdate: function(e4) {
            e4.forEach(function(e5) {
              for (var t3 = e5.parent.body, n3 = t3.indexOf(e5) + 1; n3 < t3.length; n3++) {
                var r3 = t3[n3];
                if (r3 && r3.type === i.CALL_EXPRESSION) return e5.parent.body = t3.filter(function(t4) {
                  return t4 !== e5;
                }), void (r3.body = [].concat(de(r3.body || []), [e5]));
              }
            });
          } } }), c2.setModifier({ test: function(e4) {
            return e4.isBodyEntry && e4.parent && e4.parent.subType === i.ARROW_FUNCTION_EXPRESSION;
          }, updates: { name: function(e4) {
            return "return " + e4.name;
          }, type: i.RETURN } }), { setAbstractionLevel: function(e4) {
            l2.definitionsMap = function(e5) {
              var t3 = [i.PROGRAM], n3 = [];
              return [].concat(e5).forEach(function(e6) {
                return "string" == typeof e6 ? t3.push(e6) : Array.isArray(e6) ? t3 = t3.concat(ne(e6)) : void ("object" === te(e6) && (t3 = t3.concat(ne(e6.defined || [])), n3 = n3.concat(ne(e6.custom || []))));
              }), v.filter(function(e6) {
                return -1 !== t3.indexOf(e6.type);
              }).concat(n3);
            }(e4);
          }, resetAbstractionLevelToNormal: function() {
            l2.definitionsMap = Ee(v);
          }, setIgnoreFilter: function(e4) {
            l2.globalIgnore = e4;
          }, build: function(e4) {
            var t3 = this.buildAst(e4);
            return this.buildFlowTreeFromAst(t3);
          }, buildAst: function(e4) {
            return R(e4, o2);
          }, buildFlowTreeFromAst: function(e4) {
            var n3 = [];
            try {
              n3 = function(e5, n4) {
                var r3, s3, a3, o3, l3, c3, u2 = [];
                (0, t2.default)(e5, (s3 = u2, a3 = (r3 = n4).definitionsMap, o3 = r3.globalIgnore, l3 = k(s3), c3 = function(e6) {
                  return function(t3) {
                    return e6(t3, o3);
                  };
                }, a3.reduce(function(e6, t3) {
                  return t3.body ? e6[t3.type] = { enter: c3(V(t3, l3)), exit: c3(Y(t3, l3)) } : e6[t3.type] = t3.reversed ? { exit: c3(U(t3, l3)) } : c3(U(t3, l3)), e6;
                }, {})));
                var p2 = u2.length && u2[0] || {};
                return p2.type === i.PROGRAM ? p2 : { name: "Root", type: i.PROGRAM, body: u2 };
              }(e4, l2), c2.applyToFlowTree(n3);
            } catch (e5) {
              throw L("Error at buildFlowTreeFromAst" + e5.message, e5.stack), e5;
            }
            return n3;
          } };
        };
        function ve(e3) {
          return ve = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, ve(e3);
        }
        function Ce(e3, t3) {
          var n2 = Object.keys(e3);
          if (Object.getOwnPropertySymbols) {
            var r2 = Object.getOwnPropertySymbols(e3);
            t3 && (r2 = r2.filter(function(t4) {
              return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
            })), n2.push.apply(n2, r2);
          }
          return n2;
        }
        function we(e3) {
          for (var t3 = 1; t3 < arguments.length; t3++) {
            var n2 = null != arguments[t3] ? arguments[t3] : {};
            t3 % 2 ? Ce(Object(n2), true).forEach(function(t4) {
              var r2, i2, s2;
              r2 = e3, i2 = t4, s2 = n2[t4], (i2 = function(e4) {
                var t5 = function(e5, t6) {
                  if ("object" !== ve(e5) || null === e5) return e5;
                  var n3 = e5[Symbol.toPrimitive];
                  if (void 0 !== n3) {
                    var r3 = n3.call(e5, "string");
                    if ("object" !== ve(r3)) return r3;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                  }
                  return String(e5);
                }(e4);
                return "symbol" === ve(t5) ? t5 : String(t5);
              }(i2)) in r2 ? Object.defineProperty(r2, i2, { value: s2, enumerable: true, configurable: true, writable: true }) : r2[i2] = s2;
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(n2)) : Ce(Object(n2)).forEach(function(t4) {
              Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(n2, t4));
            });
          }
          return e3;
        }
        var Oe = { strokeColor: "#444", defaultFillColor: "#fff", textColor: "#222", arrowFillColor: "#333", rectangleFillColor: "#90caf9", rectangleDotFillColor: "#ede7f6", functionFillColor: "#a5d6a7", rootCircleFillColor: "#fff59d", loopFillColor: "#b39ddb", conditionFillColor: "#ce93d8", destructedNodeFillColor: "#ffcc80", classFillColor: "#80cbc4", debuggerFillColor: "#EF5350", exportFillColor: "#81d4fa", throwFillColor: "#ef9a9a", tryFillColor: "#FFE082", objectFillColor: "#9fa8da", callFillColor: "#C5E1A5", debugModeFillColor: "#666" }, Ie = function(e3) {
          var t3 = we({ strokeColor: e3.strokeColor, strokeWidth: 1, fillColor: e3.defaultFillColor, textColor: e3.textColor, fontFamily: "monospace", fontSize: 13, lineHeight: 5, symbolHeight: 10, symbolWidth: 7.8, horizontalPadding: 15, verticalPadding: 10, childOffset: 37, margin: 10, roundBorder: 2, complexTypeExtraSpace: 15, debugFontSize: 8, debugTextColor: e3.debugModeFillColor }, e3);
          return { BaseShape: t3, ConnectionArrow: { arrow: { size: { x: 8, y: 6 }, fillColor: e3.arrowFillColor }, line: { strokeColor: e3.strokeColor, strokeWidth: 1, curveTurnRadius: 4 }, lineTurnOffset: 20 }, Shape: we({}, t3), Rectangle: we(we({}, t3), {}, { fillColor: e3.rectangleFillColor, dot: we(we({}, t3), {}, { offset: 4, radius: 2, fillColor: e3.rectangleDotFillColor }), roundBorder: 3 }), VerticalEdgedRectangle: we(we({}, t3), {}, { fillColor: e3.functionFillColor, edgeOffset: 10 }), RootCircle: we(we({}, t3), {}, { radius: 15, padding: 3, fillColor: e3.rootCircleFillColor }), LoopRhombus: we(we({}, t3), {}, { fillColor: e3.loopFillColor, thinPartOffset: 15, rhombusSize: 50, roundBorder: 3, doubleLayerOffsetA: 4, doubleLayerOffsetB: 8, childOffset: 20, positionTopShift: 20 }), ConditionRhombus: we(we({}, t3), {}, { fillColor: e3.conditionFillColor, thinPartOffset: 15, roundBorder: 3, childOffset: 20, alternateBranchOffset: 40, markOffset: { x: 15, y: 5 }, margin: 20 }), RootStartPoint: { center: { x: 25, y: 25 }, childOffset: { x: 25, y: 65 } }, ReturnStatement: we(we({}, t3), {}, { roundBorder: 3, fillColor: e3.rectangleFillColor, arrow: we(we({}, t3), {}, { handlerLength: 5, sizeX: 16, sizeY: 22, fillColor: e3.functionFillColor }) }), DestructedNode: we(we({}, t3), {}, { fillColor: e3.destructedNodeFillColor, roundBorder: 2, suffix: we(we({}, t3), {}, { roundBorder: 2, fillColor: e3.destructedNodeFillColor, width: 8, space: 4 }) }), ClassDeclaration: we(we({}, t3), {}, { fillColor: e3.classFillColor, edgeOffset: 10 }), DebuggerStatement: we(we({}, t3), {}, { fillColor: e3.debuggerFillColor, roundBorder: 2 }), ExportDeclaration: we(we({}, t3), {}, { roundBorder: 3, fillColor: e3.exportFillColor, arrow: we(we({}, t3), {}, { handlerLength: 5, sizeX: 20, sizeY: 28, fillColor: e3.defaultFillColor }) }), ImportDeclaration: we(we({}, t3), {}, { fillColor: e3.defaultFillColor, edgeOffset: 5 }), ImportSpecifier: we(we({}, t3), {}, { fillColor: e3.exportFillColor }), ThrowStatement: we(we({}, t3), {}, { fillColor: e3.throwFillColor }), TryStatement: we(we({}, t3), {}, { fillColor: e3.tryFillColor }), CatchClause: we(we({}, t3), {}, { fillColor: e3.throwFillColor, arrow: we(we({}, t3), {}, { handlerLength: 2, sizeX: 16, sizeY: 28, fillColor: e3.throwFillColor }) }), SwitchStatement: we(we({}, t3), {}, { fillColor: e3.conditionFillColor, thinPartOffset: 15, roundBorder: 3, childOffset: 20, alternateBranchOffset: 40, markOffset: { x: 15, y: 5 }, margin: 20 }), BreakStatement: we(we({}, t3), {}, { fillColor: e3.rectangleFillColor, arrow: we(we({}, t3), {}, { handlerLength: 5, sizeX: 16, sizeY: 28, fillColor: e3.conditionFillColor }) }), SwitchCase: we(we({}, t3), {}, { fillColor: e3.conditionFillColor }), ContinueStatement: we(we({}, t3), {}, { fillColor: e3.rectangleFillColor, arrow: we(we({}, t3), {}, { handlerLength: 5, sizeX: 16, sizeY: 28, fillColor: e3.loopFillColor }) }), ObjectProperty: we(we({}, t3), {}, { fillColor: e3.rectangleFillColor }), CallExpression: we(we({}, t3), {}, { dot: we(we({}, t3), {}, { offset: 6, radius: 4, fillColor: e3.rectangleDotFillColor }), fillColor: e3.callFillColor }) };
        };
        const Ne = Ie(Oe);
        function Fe(e3) {
          return Fe = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, Fe(e3);
        }
        function ke(e3, t3) {
          var n2 = Object.keys(e3);
          if (Object.getOwnPropertySymbols) {
            var r2 = Object.getOwnPropertySymbols(e3);
            t3 && (r2 = r2.filter(function(t4) {
              return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
            })), n2.push.apply(n2, r2);
          }
          return n2;
        }
        function Le(e3) {
          for (var t3 = 1; t3 < arguments.length; t3++) {
            var n2 = null != arguments[t3] ? arguments[t3] : {};
            t3 % 2 ? ke(Object(n2), true).forEach(function(t4) {
              var r2, i2, s2;
              r2 = e3, i2 = t4, s2 = n2[t4], (i2 = function(e4) {
                var t5 = function(e5, t6) {
                  if ("object" !== Fe(e5) || null === e5) return e5;
                  var n3 = e5[Symbol.toPrimitive];
                  if (void 0 !== n3) {
                    var r3 = n3.call(e5, "string");
                    if ("object" !== Fe(r3)) return r3;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                  }
                  return String(e5);
                }(e4);
                return "symbol" === Fe(t5) ? t5 : String(t5);
              }(i2)) in r2 ? Object.defineProperty(r2, i2, { value: s2, enumerable: true, configurable: true, writable: true }) : r2[i2] = s2;
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(n2)) : ke(Object(n2)).forEach(function(t4) {
              Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(n2, t4));
            });
          }
          return e3;
        }
        var _e, Me = Le(Le({}, ("#A6A6A6", _e = we({}, Oe), Object.keys(_e).forEach(function(e3) {
          _e[e3] = "#A6A6A6";
        }), _e)), {}, { strokeColor: "#333", defaultFillColor: "#A6A6A6", textColor: "#333", arrowFillColor: "#333" });
        const Be = Ie(Me), je = Ie({ strokeColor: "#ccc", defaultFillColor: "#fff", textColor: "#ccc", arrowFillColor: "#ccc", rectangleFillColor: "#ede7f6", rectangleDotFillColor: "#ede7f6", functionFillColor: "#f1f8e9", rootCircleFillColor: "#fffde7", loopFillColor: "#e3f2fd", conditionFillColor: "#f3e5f5", destructedNodeFillColor: "#fff8e1", classFillColor: "#e0f2f1", debuggerFillColor: "#ffebee", exportFillColor: "#e1f5fe", throwFillColor: "#fce4ec", tryFillColor: "#fff8e1", objectFillColor: "#f9fbe7", callFillColor: "#f9fbe7", debugModeFillColor: "#666" }), Re = Ie({ strokeColor: "#555", defaultFillColor: "#fff", textColor: "#333", arrowFillColor: "#444", rectangleFillColor: "#bbdefb", rectangleDotFillColor: "#ede7f6", functionFillColor: "#c8e6c9", rootCircleFillColor: "#fff9c4", loopFillColor: "#d1c4e9", conditionFillColor: "#e1bee7", destructedNodeFillColor: "#ffecb3", classFillColor: "#b2dfdb", debuggerFillColor: "#ffcdd2", exportFillColor: "#b3e5fc", throwFillColor: "#ffccbc", tryFillColor: "#FFE082", objectFillColor: "#d1c4e9", callFillColor: "#dcedc8", debugModeFillColor: "#666" });
        var Ue, Ve = ["common"];
        function Ke(e3) {
          return Ke = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, Ke(e3);
        }
        function We(e3, t3) {
          var n2 = Object.keys(e3);
          if (Object.getOwnPropertySymbols) {
            var r2 = Object.getOwnPropertySymbols(e3);
            t3 && (r2 = r2.filter(function(t4) {
              return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
            })), n2.push.apply(n2, r2);
          }
          return n2;
        }
        function Xe(e3) {
          for (var t3 = 1; t3 < arguments.length; t3++) {
            var n2 = null != arguments[t3] ? arguments[t3] : {};
            t3 % 2 ? We(Object(n2), true).forEach(function(t4) {
              Ye(e3, t4, n2[t4]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(n2)) : We(Object(n2)).forEach(function(t4) {
              Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(n2, t4));
            });
          }
          return e3;
        }
        function Ye(e3, t3, n2) {
          return (t3 = function(e4) {
            var t4 = function(e5, t5) {
              if ("object" !== Ke(e5) || null === e5) return e5;
              var n3 = e5[Symbol.toPrimitive];
              if (void 0 !== n3) {
                var r2 = n3.call(e5, "string");
                if ("object" !== Ke(r2)) return r2;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return String(e5);
            }(e4);
            return "symbol" === Ke(t4) ? t4 : String(t4);
          }(t3)) in e3 ? Object.defineProperty(e3, t3, { value: n2, enumerable: true, configurable: true, writable: true }) : e3[t3] = n2, e3;
        }
        var qe = "DEFAULT", He = "BLACK_AND_WHITE", Je = "BLURRED", $e = "LIGHT", Ge = (Ye(Ue = {}, qe, Ne), Ye(Ue, He, Be), Ye(Ue, Je, je), Ye(Ue, $e, Re), Ue), ze = function(e3) {
          return !Ge[e3] === e3 === qe ? Ge.DEFAULT : et(Ne, Ge[e3]);
        }, Qe = function() {
          return ze(qe);
        }, Ze = function() {
          return ze(Je);
        }, et = function(e3, t3) {
          var n2 = t3.common, r2 = function(e4, t4) {
            if (null == e4) return {};
            var n3, r3, i3 = function(e5, t5) {
              if (null == e5) return {};
              var n4, r4, i4 = {}, s3 = Object.keys(e5);
              for (r4 = 0; r4 < s3.length; r4++) n4 = s3[r4], t5.indexOf(n4) >= 0 || (i4[n4] = e5[n4]);
              return i4;
            }(e4, t4);
            if (Object.getOwnPropertySymbols) {
              var s2 = Object.getOwnPropertySymbols(e4);
              for (r3 = 0; r3 < s2.length; r3++) n3 = s2[r3], t4.indexOf(n3) >= 0 || Object.prototype.propertyIsEnumerable.call(e4, n3) && (i3[n3] = e4[n3]);
            }
            return i3;
          }(t3, Ve), i2 = F(e3, r2);
          return n2 ? Object.keys(i2).reduce(function(e4, t4) {
            return Xe(Xe({}, e4), {}, Ye({}, t4, Xe(Xe({}, i2[t4]), n2)));
          }, {}) : i2;
        }, tt = function(e3, t3, n2, r2, i2, s2) {
          var a2 = k(), o2 = t3;
          ce(e3, function(e4) {
            a2.stepIn(o2), n2(e4, a2.getCurrent());
          }, function(e4) {
            o2 = r2(e4, a2.getCurrent());
          }, function(e4) {
            a2.getCurrent() && i2(e4, a2.getCurrent()), a2.stepOut();
          }, s2);
        }, nt = function(e3) {
          if (!e3 || !e3.length) throw new Error("List is not specified.");
          var t3 = e3[0], n2 = t3.min.x, r2 = t3.max.x, i2 = t3.min.y, s2 = t3.max.y;
          return e3.forEach(function(e4) {
            var t4 = e4.min, a2 = e4.max;
            t4.x < n2 && (n2 = t4.x), t4.y < i2 && (i2 = t4.y), a2.x > r2 && (r2 = a2.x), a2.y > s2 && (s2 = a2.y);
          }), { min: { x: n2, y: i2 }, max: { x: r2, y: s2 } };
        }, rt = function(e3, t3) {
          return [].concat(e3).map(function(e4) {
            return { x: e4.x + t3.x, y: e4.y + t3.y };
          });
        }, it = [{ from: "fillColor", to: "fill" }, { from: "strokeColor", to: "stroke" }, { from: "strokeWidth", to: "stroke-width" }, { from: "fillOpacity", to: "fill-opacity" }, { from: "strokeOpacity", to: "stroke-opacity" }], st = function(e3) {
          return it.map(function(t3) {
            return e3[t3.from] ? "".concat(t3.to, ":").concat(e3[t3.from]) : null;
          }).filter(function(e4) {
            return e4;
          }).join("; ");
        }, at = function(e3, t3, n2, r2, i2) {
          return '<polygon points="'.concat(e3, ",").concat(t3 + r2 / 2, " ").concat(e3 + n2 / 2, ",").concat(t3, " ").concat(e3 + n2, ",").concat(t3 + r2 / 2, " ").concat(e3 + n2 / 2, ",").concat(t3 + r2, '"\n            style="').concat(st(i2), '" />');
        }, ot = function(e3, t3, n2, r2, i2) {
          return '<rect x="'.concat(e3, '" y="').concat(t3, '"\n            width="').concat(n2, '" height="').concat(r2, '"\n            rx="').concat(i2.roundBorder, '" ry="').concat(i2.roundBorder, '"\n            style="').concat(st(i2), '" />');
        }, lt = function(e3, t3, n2, r2, i2) {
          return '<rect x="'.concat(e3, '" y="').concat(t3, '"\n            width="').concat(n2, '" height="').concat(r2, '"\n            style="').concat(st(i2), '" />');
        }, ct = function(e3, t3, n2, r2, i2) {
          return '<line x1="'.concat(e3, '" y1="').concat(t3, '" x2="').concat(n2, '" y2="').concat(r2, '"\n                style="').concat(st(i2), '" />');
        }, ut = function(e3, t3, n2, r2) {
          return '<circle cx="'.concat(e3, '" cy="').concat(t3, '" r="').concat(n2, '"\n        style="').concat(st(r2), '" />');
        }, pt = function(e3, t3, n2, r2) {
          return '<text x="'.concat(e3, '" y="').concat(t3, '"\n        font-family="').concat(n2.fontFamily, '" font-size="').concat(n2.fontSize, '" fill="').concat(n2.textColor, '">').concat(r2, "</text>");
        }, ht = function(e3, t3) {
          var n2 = e3.map(function(e4, t4) {
            return t4 ? "L".concat(e4.x, ", ").concat(e4.y) : "M".concat(e4.x, ", ").concat(e4.y);
          }).join(" ");
          return '<path d="'.concat(n2, ' Z" \n        ').concat(function(e4) {
            return it.map(function(t4) {
              return e4[t4.from] ? "".concat(t4.to, '="').concat(e4[t4.from], '"') : null;
            }).filter(function(e5) {
              return e5;
            }).join(" ");
          }(t3), " />");
        }, dt = function(e3, t3, n2) {
          return e3.x === t3.x ? "L".concat(e3.x, " ").concat(ft(e3.y, t3.y, n2)) : e3.y === t3.y ? "L".concat(ft(e3.x, t3.x, n2), " ").concat(e3.y, " ") : void 0;
        }, ft = function(e3, t3, n2) {
          return e3 > t3 ? e3 - n2 : e3 + n2;
        }, yt = function(e3, t3, n2) {
          return e3 > t3 ? t3 + n2 : t3 - n2;
        }, mt = n(737), Tt = n.n(mt);
        const gt = function({ onlyFirst: e3 = false } = {}) {
          const t3 = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
          return new RegExp(t3, e3 ? void 0 : "g");
        }();
        var bt = n(4021);
        var Et = function(e3) {
          for (var t3 = [e3], n2 = "node-id:|".concat(e3.name, "|"); t3.length; ) {
            var r2 = t3.shift();
            r2 && (n2 += r2.name ? r2.name[0] : "-", r2.parent && t3.push(r2.parent));
          }
          return n2.replace(/\s/g, "").toUpperCase();
        }, St = function e3(t3) {
          var n2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : function(e4) {
            return e4.body;
          }, r2 = [];
          return [].concat(t3).forEach(function(t4) {
            var i2 = n2(t4);
            i2 && i2.length ? r2 = r2.concat(t4, e3(i2, n2)) : r2.push(t4);
          }), r2;
        };
        function Pt(e3) {
          return Pt = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, Pt(e3);
        }
        function xt(e3, t3) {
          var n2 = Object.keys(e3);
          if (Object.getOwnPropertySymbols) {
            var r2 = Object.getOwnPropertySymbols(e3);
            t3 && (r2 = r2.filter(function(t4) {
              return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
            })), n2.push.apply(n2, r2);
          }
          return n2;
        }
        function Dt(e3) {
          for (var t3 = 1; t3 < arguments.length; t3++) {
            var n2 = null != arguments[t3] ? arguments[t3] : {};
            t3 % 2 ? xt(Object(n2), true).forEach(function(t4) {
              var r2, i2, s2;
              r2 = e3, i2 = t4, s2 = n2[t4], (i2 = function(e4) {
                var t5 = function(e5, t6) {
                  if ("object" !== Pt(e5) || null === e5) return e5;
                  var n3 = e5[Symbol.toPrimitive];
                  if (void 0 !== n3) {
                    var r3 = n3.call(e5, "string");
                    if ("object" !== Pt(r3)) return r3;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                  }
                  return String(e5);
                }(e4);
                return "symbol" === Pt(t5) ? t5 : String(t5);
              }(i2)) in r2 ? Object.defineProperty(r2, i2, { value: s2, enumerable: true, configurable: true, writable: true }) : r2[i2] = s2;
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(n2)) : xt(Object(n2)).forEach(function(t4) {
              Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(n2, t4));
            });
          }
          return e3;
        }
        var At = function(e3, t3) {
          function n2(n3, r2, i2) {
            return e3(vt(n3, r2, i2, t3));
          }
          return n2.getThemeFieldName = function() {
            return t3;
          }, n2;
        }, vt = function(e3, t3, n2, r2) {
          var i2, s2, a2 = t3.x, o2 = t3.y, l2 = (i2 = e3.name, s2 = n2.maxNameLength || 50, i2.length <= s2 ? [i2] : [i2.slice(0, s2) + "..."]), c2 = l2.length, u2 = l2.reduce(function(e4, t4) {
            var n3 = function(e5, t5) {
              if ("string" != typeof e5 || 0 === e5.length) return 0;
              if ((t5 = { ambiguousIsNarrow: true, countAnsiEscapeCodes: false, ...t5 }).countAnsiEscapeCodes || (e5 = function(e6) {
                if ("string" != typeof e6) throw new TypeError(`Expected a \`string\`, got \`${typeof e6}\``);
                return e6.replace(gt, "");
              }(e5)), 0 === e5.length) return 0;
              const n4 = t5.ambiguousIsNarrow ? 1 : 2;
              let r3 = 0;
              for (const { segment: t6 } of new Intl.Segmenter().segment(e5)) {
                const e6 = t6.codePointAt(0);
                if (!(e6 <= 31 || e6 >= 127 && e6 <= 159 || e6 >= 768 && e6 <= 879)) if (/[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26F9(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC3\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC08\uDC26](?:\u200D\u2B1B)?|[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC2\uDECE-\uDEDB\uDEE0-\uDEE8]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g.test(t6)) r3 += 2;
                else switch (bt.eastAsianWidth(t6)) {
                  case "F":
                  case "W":
                    r3 += 2;
                    break;
                  case "A":
                    r3 += n4;
                    break;
                  default:
                    r3 += 1;
                }
              }
              return r3;
            }(t4);
            return n3 >= e4 ? n3 : e4;
          }, 0);
          return { id: "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(e4) {
            var t4 = 16 * Math.random() | 0;
            return ("x" === e4 ? t4 : 3 & t4 | 8).toString(16);
          }), nodePathId: Et(e3), type: r2, body: [], theme: n2, originalTheme: n2, node: e3, name: e3.name, prefixName: e3.prefixName, nameParts: l2, totalNamePartsNumber: c2, maxNamePartLength: u2, initialPosition: { x: a2, y: o2 } };
        }, Ct = function(e3) {
          return { fromPoint: Mt(e3), toPoint: Bt(e3), backPoint: jt(e3), childOffsetPoint: Rt(e3), boundaries: Ut(e3) };
        }, wt = function(e3) {
          return Dt(Dt({}, e3), {}, { position: _t(e3), dimensions: Lt(e3) });
        }, Ot = function(e3) {
          return { getBody: function() {
            return e3.body;
          }, getBoundaries: function() {
            return e3.boundaries;
          }, getBackPoint: function() {
            return e3.backPoint;
          }, getAssignedConnectionArrow: function() {
            return e3.connectionArrow;
          }, getChildOffsetPoint: function() {
            return e3.childOffsetPoint;
          }, getDimensions: function() {
            return e3.dimensions;
          }, getId: function() {
            return e3.id;
          }, getFromPoint: function() {
            return e3.fromPoint;
          }, getMargin: function() {
            return e3.theme.margin;
          }, getName: function() {
            return e3.name;
          }, getNode: function() {
            return e3.node;
          }, getNodeType: function() {
            return e3.node.type;
          }, getNodePathId: function() {
            return e3.nodePathId;
          }, getNodeKey: function() {
            return e3.node.key;
          }, getParent: function() {
            return e3.parent;
          }, getPosition: function() {
            return e3.position;
          }, getToPoint: function() {
            return e3.toPoint;
          }, getShapeType: function() {
            return e3.type;
          } };
        }, It = function(e3) {
          return Object.assign({}, /* @__PURE__ */ function(e4) {
            return { printName: function(t3) {
              var n2 = e4.position, r2 = e4.theme, i2 = e4.nameParts, s2 = t3 || n2, a2 = s2.x, o2 = s2.y, l2 = i2.map(function(e5, t4) {
                return '<tspan x="'.concat(a2 + r2.horizontalPadding, '" y="').concat(o2 + 2 * r2.verticalPadding * (t4 + 1), '">').concat(Tt()(e5), "</tspan>");
              }).join("");
              return "".concat(i2[0].length <= e4.name.length + 3 ? "<title>".concat(Tt()(e4.name), "</title>") : "", '\n            <text x="').concat(a2 + r2.horizontalPadding, '" y="').concat(o2 + 2 * r2.verticalPadding, '"\n                font-family="').concat(r2.fontFamily, '" font-size="').concat(r2.fontSize, '" fill="').concat(r2.textColor, '">\n                ').concat(l2, "\n            </text>");
            }, printDebugInfo: function() {
              if (!(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).debug) return "";
              var t3 = e4.position, n2 = e4.dimensions, r2 = e4.theme, i2 = e4.nodePathId;
              return '<text x="'.concat(t3.x + 3 * r2.horizontalPadding, '" y="').concat(t3.y + n2.h + r2.verticalPadding, '"\n                font-family="').concat(r2.fontFamily, '" font-size="').concat(r2.debugFontSize, '" fill="').concat(r2.debugTextColor, '">\n                ').concat(i2, "\n            </text>");
            } };
          }(e3), /* @__PURE__ */ function(e4) {
            return { getChildBoundaries: function(t3) {
              var n2 = e4.body, r2 = e4.boundaries;
              if (!n2.length) return r2;
              var i2 = St({ getBody: function() {
                return t3 ? n2.filter(t3) : n2;
              }, getBoundaries: function() {
                return r2;
              } }, function(e5) {
                return e5.getBody();
              });
              return nt(i2.map(function(e5) {
                return e5.getBoundaries();
              }));
            } };
          }(e3), /* @__PURE__ */ function(e4) {
            return { addChild: function(t3) {
              e4.body.push(t3);
            }, setParent: function(t3) {
              e4.parent = t3;
            }, connectChild: function(e5) {
              this.addChild(e5), e5.setParent(this);
            }, updateTheme: function(t3) {
              e4.theme = F(e4.theme, t3);
            }, assignConnectionArrow: function(t3) {
              e4.connectionArrow = t3;
            } };
          }(e3));
        }, Nt = function(e3) {
          return e3.maxNamePartLength * e3.theme.symbolWidth;
        }, Ft = function(e3) {
          return 2 * e3.theme.horizontalPadding + Nt(e3);
        }, kt = function(e3) {
          return 2 * e3.theme.verticalPadding + (n2 = (t3 = e3).totalNamePartsNumber, r2 = t3.theme, n2 * r2.symbolHeight + (n2 - 1) * r2.lineHeight);
          var t3, n2, r2;
        }, Lt = function(e3) {
          return { w: Ft(e3), h: kt(e3) };
        }, _t = function(e3) {
          return Dt({}, e3.initialPosition);
        }, Mt = function(e3) {
          var t3 = e3.position, n2 = e3.dimensions, r2 = e3.theme;
          return { x: t3.x + r2.childOffset / 2, y: t3.y + n2.h };
        }, Bt = function(e3) {
          var t3 = e3.position, n2 = e3.dimensions;
          return { x: t3.x, y: t3.y + n2.h / 2 };
        }, jt = function(e3) {
          var t3 = e3.position, n2 = e3.dimensions;
          return { x: t3.x + n2.w, y: t3.y + n2.h / 2 };
        }, Rt = function(e3) {
          var t3 = e3.theme, n2 = e3.dimensions;
          return { x: t3.childOffset, y: n2.h + t3.childOffset / 2 };
        }, Ut = function(e3) {
          var t3 = e3.position, n2 = e3.dimensions;
          return { min: { x: t3.x, y: t3.y }, max: { x: t3.x + n2.w, y: t3.y + n2.h } };
        };
        function Vt(e3) {
          return Vt = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, Vt(e3);
        }
        function Kt(e3, t3) {
          var n2 = Object.keys(e3);
          if (Object.getOwnPropertySymbols) {
            var r2 = Object.getOwnPropertySymbols(e3);
            t3 && (r2 = r2.filter(function(t4) {
              return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
            })), n2.push.apply(n2, r2);
          }
          return n2;
        }
        function Wt(e3) {
          for (var t3 = 1; t3 < arguments.length; t3++) {
            var n2 = null != arguments[t3] ? arguments[t3] : {};
            t3 % 2 ? Kt(Object(n2), true).forEach(function(t4) {
              var r2, i2, s2;
              r2 = e3, i2 = t4, s2 = n2[t4], (i2 = function(e4) {
                var t5 = function(e5, t6) {
                  if ("object" !== Vt(e5) || null === e5) return e5;
                  var n3 = e5[Symbol.toPrimitive];
                  if (void 0 !== n3) {
                    var r3 = n3.call(e5, "string");
                    if ("object" !== Vt(r3)) return r3;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                  }
                  return String(e5);
                }(e4);
                return "symbol" === Vt(t5) ? t5 : String(t5);
              }(i2)) in r2 ? Object.defineProperty(r2, i2, { value: s2, enumerable: true, configurable: true, writable: true }) : r2[i2] = s2;
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(n2)) : Kt(Object(n2)).forEach(function(t4) {
              Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(n2, t4));
            });
          }
          return e3;
        }
        var Xt = function(e3) {
          return { print: function(t3) {
            var n2 = e3.theme, r2 = e3.position, i2 = r2.x, s2 = r2.y, a2 = e3.dimensions, o2 = a2.w, l2 = a2.h, c2 = { x: i2 + n2.edgeOffset, y: s2 };
            return "\n            <g>\n                ".concat(lt(i2, s2, o2, l2, n2), "\n                    \n                ").concat(ct(i2 + n2.edgeOffset, s2, i2 + n2.edgeOffset, s2 + l2, n2), "\n                ").concat(ct(i2 + o2 - n2.edgeOffset, s2, i2 + o2 - n2.edgeOffset, s2 + l2, n2), "\n             \n                ").concat(this.printName(c2), "\n                ").concat(this.printDebugInfo(t3), "\n            </g>");
          } };
        }, Yt = function(e3) {
          return 2 * (e3.theme.horizontalPadding + e3.theme.edgeOffset) + Nt(e3);
        }, qt = function(e3) {
          return { w: Yt(e3), h: kt(e3) };
        }, Ht = function(e3) {
          var t3 = function(e4) {
            return Wt(Wt({}, e4), {}, { position: _t(e4), dimensions: qt(e4) });
          }(e3);
          return t3 = Wt(Wt({}, t3), Ct(t3)), N(t3, [Ot, It, Xt]);
        };
        const Jt = At(Ht, "VerticalEdgedRectangle");
        var $t = function(e3) {
          return { print: function() {
            var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, n2 = e3.theme, r2 = n2.dot, i2 = e3.position, s2 = i2.x, a2 = i2.y, o2 = e3.dimensions, l2 = o2.w, c2 = o2.h, u2 = e3.node;
            return "\n                <g>\n                   ".concat(ot(s2, a2, l2, c2, n2), "\n                   ").concat(this.printName(), "\n                   ").concat(u2.chain ? ut(s2 + r2.offset, a2 + c2 - r2.offset, r2.radius, r2) : "", "\n                   ").concat(this.printDebugInfo(t3), "\n                </g>");
          } };
        }, Gt = function(e3) {
          var t3 = function(e4) {
            var t4 = wt(e4);
            return Dt(Dt({}, t4), Ct(t4));
          }(e3);
          return N(t3, [Ot, It, $t]);
        };
        const zt = At(Gt, "Rectangle");
        var Qt = function(e3) {
          return { w: Zt(e3), h: en(e3) };
        }, Zt = function(e3) {
          return en(e3) + Ft(e3);
        }, en = function(e3) {
          return 2 * e3.theme.thinPartOffset + kt(e3);
        }, tn = function(e3) {
          var t3 = e3.position, n2 = e3.dimensions;
          return { x: t3.x + n2.h / 2, y: t3.y + n2.h };
        }, nn = function(e3) {
          var t3 = e3.dimensions, n2 = e3.theme;
          return { x: t3.h / 2 + n2.childOffset, y: t3.h + n2.childOffset / 2 };
        };
        function rn(e3) {
          return rn = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, rn(e3);
        }
        function sn(e3, t3) {
          var n2 = Object.keys(e3);
          if (Object.getOwnPropertySymbols) {
            var r2 = Object.getOwnPropertySymbols(e3);
            t3 && (r2 = r2.filter(function(t4) {
              return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
            })), n2.push.apply(n2, r2);
          }
          return n2;
        }
        function an(e3) {
          for (var t3 = 1; t3 < arguments.length; t3++) {
            var n2 = null != arguments[t3] ? arguments[t3] : {};
            t3 % 2 ? sn(Object(n2), true).forEach(function(t4) {
              var r2, i2, s2;
              r2 = e3, i2 = t4, s2 = n2[t4], (i2 = function(e4) {
                var t5 = function(e5, t6) {
                  if ("object" !== rn(e5) || null === e5) return e5;
                  var n3 = e5[Symbol.toPrimitive];
                  if (void 0 !== n3) {
                    var r3 = n3.call(e5, "string");
                    if ("object" !== rn(r3)) return r3;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                  }
                  return String(e5);
                }(e4);
                return "symbol" === rn(t5) ? t5 : String(t5);
              }(i2)) in r2 ? Object.defineProperty(r2, i2, { value: s2, enumerable: true, configurable: true, writable: true }) : r2[i2] = s2;
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(n2)) : sn(Object(n2)).forEach(function(t4) {
              Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(n2, t4));
            });
          }
          return e3;
        }
        var on = function(e3) {
          var t3 = e3.position, n2 = e3.dimensions;
          return { x: t3.x + n2.w, y: t3.y + n2.h / 2 };
        }, ln = function(e3) {
          return { getAlternateFromPoint: function() {
            return e3.alternateFromPoint;
          } };
        }, cn = function(e3) {
          return { getConsequentBranchChildBoundary: function() {
            return this.getChildBoundaries(function(e4) {
              return e4.state.node.key === s.CONSEQUENT;
            });
          }, getAlternativeBranchChildOffsetPoint: function() {
            var t3 = e3.theme, n2 = {};
            n2.y = e3.position.y + e3.childOffsetPoint.y, n2.x = this.getConsequentBranchChildBoundary().max.x, n2.x += t3.alternateBranchOffset;
            var r2 = e3.position.x + e3.dimensions.w + t3.childOffset;
            return n2.x <= r2 && (n2.x = r2), n2;
          }, checkIfChildExist: function(t3) {
            return e3.body.filter(function(e4) {
              return e4.getNodeKey() === t3;
            }).length;
          }, printConditionMarks: function() {
            var t3 = e3.theme, n2 = e3.position, r2 = n2.x, a2 = n2.y, o2 = e3.dimensions.h, l2 = e3.dimensions.w, c2 = e3.node.subType === i.CONDITIONAL_EXPRESSION ? "?" : "if";
            return "".concat(pt(r2 + o2 / 2 - c2.length * t3.symbolWidth / 2, a2 + o2 / 2 + t3.symbolHeight / 2, t3, c2), " ").concat(pt(r2 + o2 / 2 + t3.symbolWidth, a2 + o2 + t3.symbolWidth / 4, t3, "+"), " ").concat(this.checkIfChildExist(s.ALTERNATE) ? pt(r2 + l2 + t3.symbolWidth / 2, a2 + o2 / 2 - t3.symbolWidth / 4, t3, "-") : "");
          }, print: function(t3) {
            var n2 = e3.theme, r2 = e3.position, i2 = r2.x, s2 = r2.y, a2 = e3.dimensions, o2 = a2.w, l2 = a2.h, c2 = l2, u2 = l2 - 2 * n2.thinPartOffset, p2 = { x: i2 + c2, y: s2 + u2 / 2 };
            return "<g>\n            ".concat(ot(i2 + l2 / 2, s2 + l2 / 4, o2 - c2 / 2, u2, n2), "                \n            ").concat(at(i2, s2, c2, c2, n2), "\n            ").concat(this.printName(p2), "\n            ").concat(this.printDebugInfo(t3), "\n            ").concat(this.printConditionMarks(), "\n        </g>");
          } };
        }, un = function(e3) {
          var t3 = function(e4) {
            return an(an({}, e4), {}, { position: _t(e4), dimensions: Qt(e4) });
          }(e3);
          return t3 = an(an({}, t3), function(e4) {
            return { fromPoint: tn(e4), childOffsetPoint: nn(e4), toPoint: (t4 = e4, n2 = t4.position, r2 = t4.dimensions, { x: n2.x, y: n2.y + r2.h / 2 }), backPoint: jt(e4), boundaries: Ut(e4), alternateFromPoint: on(e4) };
            var t4, n2, r2;
          }(t3)), N(t3, [Ot, ln, It, cn]);
        };
        const pn = At(un, "ConditionRhombus");
        var hn;
        function dn(e3) {
          return dn = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, dn(e3);
        }
        function fn(e3, t3) {
          var n2 = Object.keys(e3);
          if (Object.getOwnPropertySymbols) {
            var r2 = Object.getOwnPropertySymbols(e3);
            t3 && (r2 = r2.filter(function(t4) {
              return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
            })), n2.push.apply(n2, r2);
          }
          return n2;
        }
        function yn(e3) {
          for (var t3 = 1; t3 < arguments.length; t3++) {
            var n2 = null != arguments[t3] ? arguments[t3] : {};
            t3 % 2 ? fn(Object(n2), true).forEach(function(t4) {
              mn(e3, t4, n2[t4]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(n2)) : fn(Object(n2)).forEach(function(t4) {
              Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(n2, t4));
            });
          }
          return e3;
        }
        function mn(e3, t3, n2) {
          return (t3 = function(e4) {
            var t4 = function(e5, t5) {
              if ("object" !== dn(e5) || null === e5) return e5;
              var n3 = e5[Symbol.toPrimitive];
              if (void 0 !== n3) {
                var r2 = n3.call(e5, "string");
                if ("object" !== dn(r2)) return r2;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return String(e5);
            }(e4);
            return "symbol" === dn(t4) ? t4 : String(t4);
          }(t3)) in e3 ? Object.defineProperty(e3, t3, { value: n2, enumerable: true, configurable: true, writable: true }) : e3[t3] = n2, e3;
        }
        var Tn = (mn(hn = {}, i.FOR_OF_STATEMENT, "for"), mn(hn, i.FOR_IN_STATEMENT, "for"), mn(hn, i.FOR_STATEMENT, "for"), mn(hn, i.WHILE_STATEMENT, "while"), mn(hn, i.DO_WHILE_STATEMENT, "while"), hn), gn = function(e3) {
          return { getMidPoint: function() {
            return e3.midPoint;
          }, getLoopedConnectionArrow: function() {
            return e3.loopedConnectionArrow;
          } };
        }, bn = function(e3) {
          return { assignLoopedConnectionArrow: function(t3) {
            e3.loopedConnectionArrow = t3;
          }, printConditionMarks: function() {
            var t3 = e3.theme, n2 = e3.position, r2 = n2.x, i2 = n2.y, s2 = e3.dimensions.h, a2 = e3.prefixName || Tn[e3.node.subType] || "for";
            return pt(r2 + s2 / 2 - a2.length * t3.symbolWidth / 2, i2 + s2 / 2 + t3.symbolHeight / 2, t3, a2);
          }, print: function(t3) {
            var n2 = e3.theme, r2 = e3.position, i2 = r2.x, s2 = r2.y, a2 = e3.dimensions, o2 = a2.w, l2 = a2.h, c2 = l2, u2 = l2 - 2 * n2.thinPartOffset, p2 = { x: i2 + c2, y: s2 + u2 / 2 };
            return "<g>\n\n            ".concat(ot(i2 + l2 / 2, s2 + l2 / 4, o2 - c2 / 2, u2, n2), "\n            ").concat(at(i2, s2, c2, c2, n2), "\n                \n            ").concat(this.printName(p2), "\n            ").concat(this.printDebugInfo(t3), "\n            ").concat(this.printConditionMarks(), "\n        </g>");
          } };
        };
        const En = At(function(e3) {
          var t3 = function(e4) {
            return yn(yn({}, e4), {}, { position: (t4 = e4, n2 = t4.initialPosition, r2 = t4.theme, { x: n2.x, y: n2.y + r2.positionTopShift }), dimensions: Qt(e4) });
            var t4, n2, r2;
          }(e3);
          return t3 = yn(yn({}, t3), function(e4) {
            return { fromPoint: tn(e4), childOffsetPoint: nn(e4), toPoint: Bt(e4), backPoint: jt(e4), boundaries: Ut(e4), midPoint: (t4 = e4, n2 = t4.position, r2 = t4.dimensions, { x: n2.x + r2.h / 2, y: n2.y }) };
            var t4, n2, r2;
          }(t3)), N(t3, [Ot, gn, It, bn]);
        }, "LoopRhombus");
        function Sn(e3) {
          return Sn = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, Sn(e3);
        }
        function Pn(e3, t3) {
          var n2 = Object.keys(e3);
          if (Object.getOwnPropertySymbols) {
            var r2 = Object.getOwnPropertySymbols(e3);
            t3 && (r2 = r2.filter(function(t4) {
              return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
            })), n2.push.apply(n2, r2);
          }
          return n2;
        }
        function xn(e3) {
          for (var t3 = 1; t3 < arguments.length; t3++) {
            var n2 = null != arguments[t3] ? arguments[t3] : {};
            t3 % 2 ? Pn(Object(n2), true).forEach(function(t4) {
              var r2, i2, s2;
              r2 = e3, i2 = t4, s2 = n2[t4], (i2 = function(e4) {
                var t5 = function(e5, t6) {
                  if ("object" !== Sn(e5) || null === e5) return e5;
                  var n3 = e5[Symbol.toPrimitive];
                  if (void 0 !== n3) {
                    var r3 = n3.call(e5, "string");
                    if ("object" !== Sn(r3)) return r3;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                  }
                  return String(e5);
                }(e4);
                return "symbol" === Sn(t5) ? t5 : String(t5);
              }(i2)) in r2 ? Object.defineProperty(r2, i2, { value: s2, enumerable: true, configurable: true, writable: true }) : r2[i2] = s2;
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(n2)) : Pn(Object(n2)).forEach(function(t4) {
              Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(n2, t4));
            });
          }
          return e3;
        }
        var Dn = function(e3) {
          return { print: function() {
            var t3 = e3.theme, n2 = e3.position, r2 = n2.x, i2 = n2.y, s2 = e3.dimensions, a2 = s2.w, o2 = s2.h, l2 = t3.radius, c2 = { x: r2 + l2, y: i2 - l2 };
            return "\n            <g>\n               ".concat(lt(r2, i2 - l2 + l2 / 4, a2 + l2, o2 - 2 * t3.padding, t3), "\n               ").concat(ut(r2, i2, l2, t3), "\n               ").concat(this.printName(c2), "\n            </g>");
          }, setChildOffsetPoint: function(t3) {
            e3.childOffsetPoint = t3;
          } };
        };
        const An = At(function(e3) {
          var t3 = wt(e3);
          return t3 = xn(xn({}, t3), function(e4) {
            return { fromPoint: (t4 = e4, n2 = t4.position, r2 = t4.theme.radius, { x: n2.x, y: n2.y + r2 }), boundaries: Ut(e4) };
            var t4, n2, r2;
          }(t3)), N(t3, [Ot, It, Dn]);
        }, "RootCircle");
        function vn(e3) {
          return vn = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, vn(e3);
        }
        function Cn(e3, t3) {
          var n2 = Object.keys(e3);
          if (Object.getOwnPropertySymbols) {
            var r2 = Object.getOwnPropertySymbols(e3);
            t3 && (r2 = r2.filter(function(t4) {
              return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
            })), n2.push.apply(n2, r2);
          }
          return n2;
        }
        function wn(e3) {
          for (var t3 = 1; t3 < arguments.length; t3++) {
            var n2 = null != arguments[t3] ? arguments[t3] : {};
            t3 % 2 ? Cn(Object(n2), true).forEach(function(t4) {
              var r2, i2, s2;
              r2 = e3, i2 = t4, s2 = n2[t4], (i2 = function(e4) {
                var t5 = function(e5, t6) {
                  if ("object" !== vn(e5) || null === e5) return e5;
                  var n3 = e5[Symbol.toPrimitive];
                  if (void 0 !== n3) {
                    var r3 = n3.call(e5, "string");
                    if ("object" !== vn(r3)) return r3;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                  }
                  return String(e5);
                }(e4);
                return "symbol" === vn(t5) ? t5 : String(t5);
              }(i2)) in r2 ? Object.defineProperty(r2, i2, { value: s2, enumerable: true, configurable: true, writable: true }) : r2[i2] = s2;
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(n2)) : Cn(Object(n2)).forEach(function(t4) {
              Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(n2, t4));
            });
          }
          return e3;
        }
        var On = function(e3) {
          return { print: function(t3) {
            var n2 = e3.theme, r2 = n2.arrow, i2 = e3.position, s2 = i2.x, a2 = i2.y, o2 = e3.dimensions.h, l2 = e3.dimensions.w - r2.handlerLength - r2.sizeX, c2 = { x: s2, y: a2 }, u2 = { x: r2.sizeX, y: r2.sizeY }, p2 = ht(rt([{ x: 0, y: 0 }, { x: u2.x, y: u2.y / 2 }, { x: 0, y: u2.y }], { x: s2 + l2 + r2.handlerLength, y: a2 + o2 / 2 - u2.y / 2 }), r2);
            return "\n            <g>\n                ".concat(ot(s2, a2, l2, o2, n2), "\n                \n                ").concat(ct(s2 + l2, a2 + o2 / 2 - r2.handlerLength, s2 + l2 + r2.handlerLength, a2 + o2 / 2 - r2.handlerLength, r2), "\n                \n                ").concat(ct(s2 + l2, a2 + o2 / 2 + r2.handlerLength, s2 + l2 + r2.handlerLength, a2 + o2 / 2 + r2.handlerLength, r2), "\n\n                ").concat(p2, "\n                             \n                ").concat(this.printName(c2), "\n                ").concat(this.printDebugInfo(t3), "\n            </g>");
          } };
        }, In = function(e3) {
          var t3 = e3.theme, n2 = t3.arrow;
          return 2 * t3.horizontalPadding + n2.handlerLength + n2.sizeX + Nt(e3);
        }, Nn = function(e3) {
          return { w: In(e3), h: kt(e3) };
        }, Fn = function(e3) {
          var t3 = function(e4) {
            return wn(wn({}, e4), {}, { position: _t(e4), dimensions: Nn(e4) });
          }(e3);
          return t3 = wn(wn({}, t3), Ct(t3)), N(t3, [Ot, It, On]);
        };
        const kn = At(Fn, "ReturnStatement");
        function Ln(e3) {
          return Ln = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, Ln(e3);
        }
        function _n(e3, t3) {
          var n2 = Object.keys(e3);
          if (Object.getOwnPropertySymbols) {
            var r2 = Object.getOwnPropertySymbols(e3);
            t3 && (r2 = r2.filter(function(t4) {
              return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
            })), n2.push.apply(n2, r2);
          }
          return n2;
        }
        function Mn(e3) {
          for (var t3 = 1; t3 < arguments.length; t3++) {
            var n2 = null != arguments[t3] ? arguments[t3] : {};
            t3 % 2 ? _n(Object(n2), true).forEach(function(t4) {
              var r2, i2, s2;
              r2 = e3, i2 = t4, s2 = n2[t4], (i2 = function(e4) {
                var t5 = function(e5, t6) {
                  if ("object" !== Ln(e5) || null === e5) return e5;
                  var n3 = e5[Symbol.toPrimitive];
                  if (void 0 !== n3) {
                    var r3 = n3.call(e5, "string");
                    if ("object" !== Ln(r3)) return r3;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                  }
                  return String(e5);
                }(e4);
                return "symbol" === Ln(t5) ? t5 : String(t5);
              }(i2)) in r2 ? Object.defineProperty(r2, i2, { value: s2, enumerable: true, configurable: true, writable: true }) : r2[i2] = s2;
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(n2)) : _n(Object(n2)).forEach(function(t4) {
              Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(n2, t4));
            });
          }
          return e3;
        }
        var Bn = function(e3) {
          return { print: function(t3) {
            var n2 = e3.theme, r2 = n2.suffix, i2 = e3.position, s2 = i2.x, a2 = i2.y, o2 = e3.dimensions.h, l2 = e3.dimensions.w - 2 * (r2.width + r2.space), c2 = { x: s2, y: a2 }, u2 = ot(s2 + l2 + r2.space, a2, r2.width, o2, r2), p2 = ot(s2 + l2 + 2 * r2.space + r2.width, a2, r2.width, o2, r2);
            return "\n            <g>\n                ".concat(ot(s2, a2, l2, o2, n2), "\n                \n                ").concat(u2, "\n                ").concat(p2, "\n                             \n                ").concat(this.printName(c2), "\n                ").concat(this.printDebugInfo(t3), "\n            </g>");
          } };
        }, jn = function(e3) {
          var t3 = e3.theme, n2 = t3.suffix;
          return 2 * t3.horizontalPadding + 2 * (n2.width + +n2.space) + Nt(e3);
        }, Rn = function(e3) {
          return { w: jn(e3), h: kt(e3) };
        };
        const Un = At(function(e3) {
          var t3 = function(e4) {
            return Mn(Mn({}, e4), {}, { position: _t(e4), dimensions: Rn(e4) });
          }(e3);
          return t3 = Mn(Mn({}, t3), Ct(t3)), N(t3, [Ot, It, Bn]);
        }, "DestructedNode"), Vn = At(Ht, "ClassDeclaration"), Kn = At(Gt, "DebuggerStatement"), Wn = At(Fn, "ExportDeclaration"), Xn = At(Ht, "ImportDeclaration"), Yn = At(Gt, "ImportSpecifier"), qn = At(Gt, "ThrowStatement"), Hn = At(Gt, "TryStatement"), Jn = At(Fn, "CatchClause"), $n = At(un, "SwitchStatement"), Gn = At(Fn, "BreakStatement"), zn = At(Gt, "SwitchCase"), Qn = At(Fn, "ContinueStatement"), Zn = At(Gt, "CallExpression"), er = At(Gt, "ObjectProperty");
        var tr = function(e3) {
          switch (e3.type) {
            case i.FUNCTION:
              return Jt;
            case i.LOOP:
              return En;
            case i.CONDITIONAL:
              return pn;
            case i.RETURN:
              return kn;
            case c.DESTRUCTED:
              return Un;
            case i.CLASS_DECLARATION:
              return Vn;
            case i.DEBUGGER_STATEMENT:
              return Kn;
            case i.EXPORT_DEFAULT_DECLARATION:
            case i.EXPORT_NAMED_DECLARATION:
              return Wn;
            case i.IMPORT_DECLARATION:
              return Xn;
            case i.IMPORT_DEFAULT_SPECIFIER:
            case i.IMPORT_SPECIFIER:
              return Yn;
            case i.THROW_STATEMENT:
              return qn;
            case i.PROGRAM:
              return An;
            case i.TRY_STATEMENT:
              return Hn;
            case i.CATCH_CLAUSE:
              return Jn;
            case i.SWITCH_STATEMENT:
              return $n;
            case i.BREAK:
              return Gn;
            case i.SWITCH_CASE:
              return zn;
            case i.CONTINUE:
              return Qn;
            case i.OBJECT_PROPERTY:
              return er;
            case i.CALL_EXPRESSION:
              return Zn;
            default:
              return zt;
          }
        }, nr = function() {
          return "ConnectionArrow";
        }, rr = function(e3) {
          return { getFieldName: nr };
        }, ir = function(e3) {
          return { updateTheme: function(t3) {
            e3.theme = F(e3.theme, t3);
          } };
        }, sr = function(e3) {
          return { printLine: function(t3) {
            return function(e4, t4) {
              var n2 = e4.map(function(n3, r2) {
                if (!r2) return "M".concat(n3.x, ", ").concat(n3.y);
                var i2 = e4[r2 - 1];
                return r2 <= 1 ? dt(n3, i2, t4.curveTurnRadius) : "Q".concat(i2.x, " ").concat(i2.y, "\n                ").concat(function(e5, t5, n4) {
                  return e5.x === t5.x ? "".concat(t5.x, " ").concat(yt(e5.y, t5.y, n4)) : e5.y === t5.y ? "".concat(yt(e5.x, t5.x, n4), " ").concat(t5.y) : void 0;
                }(n3, i2, t4.curveTurnRadius), "\n                ").concat(dt(n3, i2, 2 * t4.curveTurnRadius));
              }).join(" ");
              return '<path d="'.concat(n2, '"\n        style="fill:none; ').concat(st(t4), '" />');
            }(t3, e3.theme.line);
          }, printArrow: function(t3, n2) {
            return ht(rt(n2, t3), e3.theme.arrow);
          }, printArrowByType: function(t3, n2) {
            var r2, i2 = n2.x, s2 = n2.y, c2 = e3.theme.arrow.size;
            switch (t3) {
              case a:
                return r2 = { x: i2 - c2.x, y: s2 - c2.y / 2 }, this.printArrow(r2, [{ x: 0, y: 0 }, { x: c2.x, y: c2.y / 2 }, { x: 0, y: c2.y }]);
              case o:
                return r2 = { x: i2, y: s2 - c2.y / 2 }, this.printArrow(r2, [{ x: 0, y: c2.y / 2 }, { x: c2.x, y: 0 }, { x: c2.x, y: c2.y }]);
              case l:
                return r2 = { x: i2 - c2.y / 2, y: s2 - c2.x }, this.printArrow(r2, [{ x: 0, y: 0 }, { x: c2.y / 2, y: c2.x }, { x: c2.y, y: 0 }]);
              default:
                return "";
            }
          }, print: function() {
            var t3 = e3.config, n2 = t3.linePoints, r2 = t3.arrowPoint, i2 = t3.arrowType, s2 = t3.noArrow;
            return s2 && (n2[n2.length - 1].x += e3.theme.arrow.size.x), "\n            <g>\n               ".concat(this.printLine(n2), "\n               ").concat(!s2 && this.printArrowByType(i2, r2), "\n            </g>");
          } };
        };
        function ar(e3) {
          return ar = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, ar(e3);
        }
        function or(e3, t3) {
          var n2 = Object.keys(e3);
          if (Object.getOwnPropertySymbols) {
            var r2 = Object.getOwnPropertySymbols(e3);
            t3 && (r2 = r2.filter(function(t4) {
              return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
            })), n2.push.apply(n2, r2);
          }
          return n2;
        }
        function lr(e3) {
          for (var t3 = 1; t3 < arguments.length; t3++) {
            var n2 = null != arguments[t3] ? arguments[t3] : {};
            t3 % 2 ? or(Object(n2), true).forEach(function(t4) {
              var r2, i2, s2;
              r2 = e3, i2 = t4, s2 = n2[t4], (i2 = function(e4) {
                var t5 = function(e5, t6) {
                  if ("object" !== ar(e5) || null === e5) return e5;
                  var n3 = e5[Symbol.toPrimitive];
                  if (void 0 !== n3) {
                    var r3 = n3.call(e5, "string");
                    if ("object" !== ar(r3)) return r3;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                  }
                  return String(e5);
                }(e4);
                return "symbol" === ar(t5) ? t5 : String(t5);
              }(i2)) in r2 ? Object.defineProperty(r2, i2, { value: s2, enumerable: true, configurable: true, writable: true }) : r2[i2] = s2;
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(n2)) : or(Object(n2)).forEach(function(t4) {
              Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(n2, t4));
            });
          }
          return e3;
        }
        function cr(e3) {
          return cr = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, cr(e3);
        }
        function ur(e3, t3) {
          var n2 = Object.keys(e3);
          if (Object.getOwnPropertySymbols) {
            var r2 = Object.getOwnPropertySymbols(e3);
            t3 && (r2 = r2.filter(function(t4) {
              return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
            })), n2.push.apply(n2, r2);
          }
          return n2;
        }
        var pr = function(e3, t3) {
          var n2, r2 = function(e4, t4) {
            var n3 = tr(e4), r3 = t4[n3.getThemeFieldName()], i2 = lr({}, t4.RootStartPoint), s2 = i2.center, a3 = i2.childOffset, o3 = n3(e4, s2, r3);
            return o3.setChildOffsetPoint(a3), o3;
          }(e3, t3), a2 = function(e4) {
            for (var t4 = 1; t4 < arguments.length; t4++) {
              var n3 = null != arguments[t4] ? arguments[t4] : {};
              t4 % 2 ? ur(Object(n3), true).forEach(function(t5) {
                var r3, i2, s2;
                r3 = e4, i2 = t5, s2 = n3[t5], (i2 = function(e5) {
                  var t6 = function(e6, t7) {
                    if ("object" !== cr(e6) || null === e6) return e6;
                    var n4 = e6[Symbol.toPrimitive];
                    if (void 0 !== n4) {
                      var r4 = n4.call(e6, "string");
                      if ("object" !== cr(r4)) return r4;
                      throw new TypeError("@@toPrimitive must return a primitive value.");
                    }
                    return String(e6);
                  }(e5);
                  return "symbol" === cr(t6) ? t6 : String(t6);
                }(i2)) in r3 ? Object.defineProperty(r3, i2, { value: s2, enumerable: true, configurable: true, writable: true }) : r3[i2] = s2;
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e4, Object.getOwnPropertyDescriptors(n3)) : ur(Object(n3)).forEach(function(t5) {
                Object.defineProperty(e4, t5, Object.getOwnPropertyDescriptor(n3, t5));
              });
            }
            return e4;
          }({}, r2.getChildOffsetPoint()), o2 = [];
          return tt(e3, r2, function(e4, t4) {
            a2.x += t4.getChildOffsetPoint().x;
          }, function(e4, r3) {
            if (a2.y += hr(t3, e4, n2), r3.getNodeType() === i.CONDITIONAL && e4.key === s.ALTERNATE && !r3.checkIfChildExist(s.ALTERNATE)) {
              var l2 = r3.getAlternativeBranchChildOffsetPoint();
              a2.x = l2.x + r3.getMargin(), a2.y = l2.y;
            }
            var c2 = function(e5, t4, n3) {
              var r4 = tr(e5), i2 = n3[r4.getThemeFieldName()];
              return r4(e5, t4, i2);
            }(e4, { x: a2.x, y: a2.y }, t3);
            return a2.x = c2.getPosition().x, a2.y = c2.getPosition().y, o2.push(c2), r3.connectChild(c2), a2.y += c2.getChildOffsetPoint().y, n2 = e4, c2;
          }, function(e4, t4) {
            e4.type === i.CONDITIONAL && (a2.y = t4.getChildBoundaries().max.y + t4.getMargin()), a2.x = t4.getPosition().x;
          }), { list: o2, root: r2 };
        }, hr = function(e3, t3) {
          var n2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, r2 = [i.FUNCTION, i.FUNCTION_DECLARATION, i.FUNCTION_EXPRESSION, i.ARROW_FUNCTION_EXPRESSION, i.CLASS_DECLARATION, i.IMPORT_DECLARATION, i.EXPORT_NAMED_DECLARATION, i.EXPORT_DEFAULT_DECLARATION];
          return r2.includes(t3.type) && !r2.includes(n2.type) && t3.pathParentType !== i.CALL_EXPRESSION ? e3.BaseShape.complexTypeExtraSpace : 0;
        }, dr = function(e3, t3) {
          var n2 = [], r2 = function(e4) {
            var r3 = function(e5, t4) {
              var n3 = t4.ConnectionArrow, r4 = function(e6, t5) {
                var n4 = e6.startPoint, r5 = e6.endPoint, i2 = e6.boundaryPoint, s3 = e6.arrowType, c2 = { linePoints: [], arrowPoint: { x: r5.x, y: r5.y } };
                switch (s3) {
                  case a:
                    c2.linePoints = [{ x: n4.x, y: n4.y }], c2.linePoints = i2 ? c2.linePoints.concat([{ x: i2.x, y: n4.y }, { x: i2.x, y: r5.y }, { x: r5.x, y: r5.y }]) : c2.linePoints.concat([{ x: n4.x, y: r5.y }, { x: r5.x, y: r5.y }]);
                    break;
                  case o:
                    c2.linePoints = [{ x: n4.x, y: n4.y }, { x: i2.x + t5.lineTurnOffset, y: n4.y }, { x: i2.x + t5.lineTurnOffset, y: r5.y }, { x: r5.x - t5.lineTurnOffset, y: r5.y }];
                    break;
                  case l:
                    c2.linePoints = [{ x: n4.x, y: n4.y }, { x: i2.x + t5.lineTurnOffset, y: n4.y }, { x: i2.x + t5.lineTurnOffset, y: r5.y - t5.lineTurnOffset }, { x: r5.x, y: r5.y - t5.lineTurnOffset }, { x: r5.x, y: r5.y }];
                }
                return c2;
              }(e5, n3);
              return function(e6, t5) {
                return N({ config: e6, theme: t5, originalTheme: t5 }, [ir, sr, rr]);
              }(lr(lr({}, e5), r4), n3);
            }(e4, t3);
            return n2.push(r3), r3;
          }, s2 = null;
          return tt(e3, e3, function(e4) {
          }, function(e4, t4) {
            s2 = e4;
            var n3 = yr(e4, t4), i2 = r2(n3);
            return e4.assignConnectionArrow(i2), e4;
          }, function(e4) {
            if (e4.getNodeType() === i.LOOP) {
              var t4 = e4.getChildBoundaries().max;
              e4.assignLoopedConnectionArrow(r2({ startPoint: s2.getBackPoint(), endPoint: e4.getMidPoint(), boundaryPoint: { x: t4.x }, arrowType: l }));
            }
          }, { getBody: function(e4) {
            return e4.getBody();
          } }), n2;
        }, fr = function(e3, t3) {
          return !![i.IMPORT_SPECIFIER, i.IMPORT_DEFAULT_SPECIFIER, i.OBJECT_PROPERTY].includes(e3.getNodeType()) || !(![i.FUNCTION_DECLARATION, i.FUNCTION_EXPRESSION, i.FUNCTION, i.ARROW_FUNCTION_EXPRESSION].includes(e3.getNodeType()) || ![i.CALL_EXPRESSION, i.VARIABLE_DECLARATOR, i.ASSIGNMENT_EXPRESSION, i.NEW_EXPRESSION].includes(t3.getNodeType())) || void 0;
        }, yr = function(e3, t3) {
          var n2 = { endPoint: e3.getToPoint(), arrowType: a, noArrow: fr(e3, t3) };
          if (e3.getNodeKey() === s.ALTERNATE && t3.getAlternativeBranchChildOffsetPoint) {
            var r2 = t3.getAlternativeBranchChildOffsetPoint();
            n2.startPoint = t3.getAlternateFromPoint(), n2.boundaryPoint = { x: r2.x };
          } else n2.startPoint = t3.getFromPoint();
          return n2;
        };
        const mr = function() {
          var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t3 = et(Qe(), e3);
          return { buildShapesTree: function(e4) {
            var n2 = [];
            try {
              n2 = function(e5, t4) {
                var n3, r2 = (n3 = { shapes: [], arrowConnections: [] }, { getShapes: function() {
                  return n3.shapes;
                }, addShapes: function(e6) {
                  return n3.shapes = n3.shapes.concat(e6), this;
                }, addArrowConnections: function(e6) {
                  return n3.arrowConnections = n3.arrowConnections.concat(e6), this;
                }, printChildren: function(e6) {
                  var t5 = "";
                  return [].concat(n3.shapes, n3.arrowConnections).forEach(function(n4) {
                    t5 += n4.print(e6);
                  }), t5;
                }, calculateDimensions: function() {
                  var e6 = nt(n3.shapes.map(function(e7) {
                    return e7.getBoundaries();
                  }));
                  return { w: Math.ceil(e6.max.x) + 25, h: Math.ceil(e6.max.y) + 25 };
                }, print: function(e6) {
                  var t5 = this.calculateDimensions(), n4 = t5.w, r3 = t5.h;
                  return '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n                <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" \n                width="'.concat(n4, '" height="').concat(r3, '" shape-rendering="optimizeSpeed">\n                ').concat(this.printChildren(e6), "\n            </svg>");
                } }), i2 = pr(e5, t4), s2 = dr(i2.root, t4);
                return r2.addShapes(i2.list).addShapes(i2.root), r2.addArrowConnections(s2), r2;
              }(e4, t3);
            } catch (e5) {
              throw L("Error at buildShapesTree" + e5.message, e5.stack), e5;
            }
            return n2;
          }, applyTheme: function(e4) {
            t3 = et(t3, e4);
          }, applyDefaultTheme: function() {
            this.applyTheme(Qe());
          }, applyBlackAndWhiteTheme: function() {
            this.applyTheme(ze(He));
          }, applyBlurredTheme: function() {
            this.applyTheme(Ze());
          }, applyLightTheme: function() {
            this.applyTheme(ze($e));
          }, applyColorBasedTheme: function(e4) {
            this.applyTheme(function(e5) {
              return Ie(e5);
            }(e4));
          } };
        };
        var Tr = function(e3) {
          var t3 = Ae();
          return t3.setAbstractionLevel(e3), function(e4) {
            return t3.buildFlowTreeFromAst(e4);
          };
        }, gr = Tr(ae.EXPORT), br = Tr([ae.EXPORT, ae.IMPORT]), Er = Tr([ae.EXPORT, ae.IMPORT, ae.CLASS, ae.FUNCTION]), Sr = Tr([ae.EXPORT, ae.IMPORT, ae.CLASS, ae.FUNCTION, ae.FUNCTION_DEPENDENCIES]), Pr = function(e3) {
          return Ae().buildFlowTreeFromAst(e3);
        }, xr = Ae, Dr = De, Ar = mr, vr = function(e3) {
          var t3 = function(e4, t4, n2) {
            t4 && e4.updateTheme(t4), n2 && (e4.getAssignedConnectionArrow().updateTheme(n2), e4.getLoopedConnectionArrow && e4.getLoopedConnectionArrow().updateTheme(n2));
          };
          return { findShape: function(t4) {
            var n2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
            return e3.getShapes().filter(function(e4, r2) {
              return r2 >= n2 && t4(e4);
            });
          }, applyShapeStyles: function(e4, n2, r2) {
            this.findShape(e4).forEach(function(e5) {
              t3(e5, n2, r2);
            });
          }, blur: function(e4) {
            var n2 = Ze();
            this.findShape(e4).forEach(function(e5) {
              var r2 = e5.getAssignedConnectionArrow();
              t3(e5, n2[e5.getShapeType()], r2 ? n2[r2.getFieldName()] : null);
            });
          }, focus: function(e4) {
            this.blur(function(t4) {
              return !e4(t4);
            });
          }, blurShapeBranch: function(e4) {
            var n2 = Ze();
            this.findShape(e4).forEach(function(e5) {
              return ue(e5, function(e6) {
                var r2 = e6.getAssignedConnectionArrow();
                t3(e6, n2[e6.getShapeType()], r2 ? n2[r2.getFieldName()] : null);
              }, function(e6) {
                return e6.state.body;
              });
            });
          }, focusShapeBranch: function(n2) {
            var r2 = this, i2 = Ze();
            [].concat(n2).forEach(function(n3, s2) {
              r2.findShape(n3).forEach(function(n4) {
                var a2 = St(n4, function(e4) {
                  return e4.state.body;
                }), o2 = e3.getShapes().indexOf(n4);
                r2.findShape(function(e4) {
                  return !a2.includes(e4);
                }, s2 > 0 ? o2 : 0).forEach(function(e4) {
                  var n5 = e4.getAssignedConnectionArrow();
                  t3(e4, i2[e4.getShapeType()], n5 ? i2[n5.getFieldName()] : null);
                });
              });
            });
          }, print: function(t4) {
            return e3 && e3.print(t4);
          } };
        }, Cr = function(e3) {
          return { buildSlides: function() {
            var t3 = mr(), n2 = R(e3);
            return [gr(n2), br(n2), Er(n2), Sr(n2), Pr(n2)].filter(function(e4) {
              return e4.body.length;
            }).map(t3.buildShapesTree).map(function(e4) {
              return e4.print();
            });
          } };
        }, wr = function(e3, t3) {
          return Ir(Or(e3), t3);
        }, Or = function(e3) {
          return xr().build(e3);
        }, Ir = function(e3, t3) {
          return Ar().buildShapesTree(e3).print(t3);
        };
      })(), r;
    })());
  }
});
export default require_js2flowchart();
/*! Bundled license information:

js2flowchart/dist/js2flowchart.js:
  (*! For license information please see js2flowchart.js.LICENSE.txt *)
*/
//# sourceMappingURL=js2flowchart.js.map
